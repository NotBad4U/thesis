%*****************************************
\chapter{Related Works}\label{ch:relatedworks}
%*****************************************

\section{The proof assistant TLAPS}

\subsection{The language}

\tlaplus is a specification language based on the Temporal Logic of Actions and Zermeloâ€“Fraenkel set theory with the Axiom of Choice (ZFC) \cite{tlabook,tla-ref}.
It is particularly used for specifying concurrent and distributed systems.
The \tlaplus Proof System (TLAPS) extends the language with a formal proof syntax and a tactical proof language \cite{tla-proofs}.

TLAPS includes a \emph{Proof Manager} that decomposes proofs into individual proof obligations, which are then dispatched to various backend provers.
These currently include Isabelle/\tlaplus \cite{isabelle-hol-ref}, Zenon \cite{zenonmodulo},
the SMT solvers cvc5 \cite{cvc5}, veriT \cite{verit} and Z3 \cite{z3}, and finally the LS4 prover for temporal logic.
Each obligation is translated into the logic supported by the corresponding backend.
For SMT solvers \cite{new-encoding-tlaps}, the supported logics include \textbf{UF}, \textbf{LIA}, and \textbf{NIA}.
At present, TLAPS does not verify the correctness of solver outputs, except in the case of Zenon, whose proofs can be independently validated by Isabelle,
and in the case of Isabelle/\tlaplus backend.

As the \cref{fig:interop-tla} suggests, the previous work discussed in \cref{ch:reconstruction} can be leveraged to verify \tlaplus proofs from the SMT solver backend.
The proposed approach involves extracting the output generated by the SMT backend, retrieving the corresponding proof from cvc5 or veriT, and reconstructing it within Lambdapi to establish its validity.


\subsection{Validating TLAPS proof}
\label{sec:validating-tlaps-proof}

% -------------- MODULE Cantor1 -----------------
% THEOREM cantor ==
%   \A S :
%     \A f \in [S -> SUBSET S] :
%       \E A \in SUBSET S :
%         \A x \in S :
%           f [x] # A
% PROOF
%   <1>1. TAKE S
%   <1>2. TAKE f \in [S -> SUBSET S]
%   <1>3. DEFINE T == { z \in S : z \notin f[z] }
%   <1>4. WITNESS T \in SUBSET S
%   <1>5. TAKE x \in S
%   <1>6. QED BY x \in T \/ x \notin T
\begin{figure}[tb]
\centering
\begin{nomodule}
\topbar{Cantor}
\[\begin{noj}
  \THEOREM\ cantor\ \deq \\
  \A S : \\
  \quad \A f \in [S \implies \SUBSET\ S] : \\
  \quad\quad \exists A \in \SUBSET\ S : \\
  \quad\quad\quad \forall x \in S : \\
  \quad\quad\quad\quad f \sq{x}{} \mathbin{\#} A \\
  \ps{1}{1.}\ \TAKE\ S \\
  \ps{1}{2.}\ \TAKE\ f \in [S \implies \SUBSET\ S]\\
  \ps{1}{3.}\ \DEFINE\ T\ \deq\ \{ z \in S : z \notin f[z] \}\\
  \ps{1}{4.}\ \WITNESS\ T\ \in \SUBSET\ S \\
  \ps{1}{5.}\ \TAKE\ x \in S \\
  \ps{1}{6.}\ \QED\ \BY\ x \in T \lor x \notin T
\end{noj}\]
\bottombar
\end{nomodule}
\caption{Cantor theorem in \tlaplus}
\label{fig:cantor-tlaps}
\end{figure}

\tlaplus proofs are hierarchically structured and are generally written topdown.
The assertion that the cantor theorem stating that no function ($f$) from a set ($S$) to its power set (\SUBSET\ $S$) can be surjective is formalized in \tlaplus as the theorem in \cref{fig:cantor-tlaps}.
Each proof in the hierarchy ends with a \QED\ step that asserts the proof's goal.
Proofs are incrementally decomposed into simpler subproofs across multiple levels. Each proof consists of labeled steps $\ps{i}{k.}$, that reflect their depth in the proof tree, where level $n$ indicates the nesting depth.
Steps may introduce assumptions, intermediate claims, or invoke previously proven results, using TLAPS tactics such as \ASSUME/\PROVE\, \TAKE\ or \WITNESS.
The proof is completed when the root goal is reduced to a collection of leaf obligations marked as \QED\ and discharged by backend provers.
Besides, TLAPS does not yet handle temporal reasoning.

For each step $\ps{i}{k.}$ in \tlaplus proof, there is a proof obligation that is to be proved.
The obligation contains a context of known facts, definitions, declarations, and a goal.
Obligations are sent to a suitable backend select by the PM (Zenon, Isabelle/TLA, SMT solvers) that tries to prove it.
In the case of \cref{fig:cantor-tlaps}, we will have 6 proof obligations $(\ps{1}{1.} - \ps{1}{6.})$ that will be discharged to the backend.
For example, the proof obligation relative to the final step $\ps{1}{6.}$ is given as follows:

% ===============================================


% ;;	ASSUME NEW CONSTANT CONSTANT_S_,
% ;;	       NEW CONSTANT CONSTANT_f_ \in [CONSTANT_S_ -> SUBSET CONSTANT_S_],
% ;;	       NEW CONSTANT CONSTANT_x_ \in CONSTANT_S_,
% ;;	       CONSTANT_x_
% ;;	       \in {CONSTANT_z_ \in CONSTANT_S_ :
% ;;	              CONSTANT_z_ \notin CONSTANT_f_[CONSTANT_z_]}
% ;;	       \/ CONSTANT_x_
% ;;	          \notin {CONSTANT_z_ \in CONSTANT_S_ :
% ;;	                    CONSTANT_z_ \notin CONSTANT_f_[CONSTANT_z_]} 
% ;;	PROVE  CONSTANT_f_[CONSTANT_x_]
% ;;	       # {CONSTANT_z_ \in CONSTANT_S_ :
% ;;	            CONSTANT_z_ \notin CONSTANT_f_[CONSTANT_z_]}
\begin{figure}[tb]
\centering
\[\begin{noj}
  \quad\begin{noj2}
    \ASSUME & \NEW\ \CONSTANT\ S, \\
            & \NEW\ \CONSTANT\ f  \in [ S \implies \SUBSET\ S ], \\
            & \NEW\ \CONSTANT\ X  \in S, \\
            & \quad X \in T \lor \quad X \notin T \\
    \PROVE  & f[X] \neq T
  \end{noj2}
\end{noj}\]
\caption{Proof obligation of step  $\ps{1}{6.}$}
\label{fig:cantor-po}
\end{figure}

It assumes an arbitrary set $S$, a function $f \in [S \implies \SUBSET\ S]$, and an arbitrary element $X \in S$.
The goal is to prove that $f[X] \neq \{ z \in S \mid z \notin f[z] \}$.
This corresponds to the diagonalization step: given the definition $T \deq \{ z \in S \mid z \notin f[z] \}$ from $\ps{1}{3.}$, we aim to show that $T$ is not in the image of $f$.
To this end, we must show that for any $X \in S$, $f[X] \neq T$.
The assumption $X \in T \lor X \notin T$ provides a complete case split, and in either case, the assumption $f[X] = T$ leads to a contradiction, which suffices to discharge the proof obligation.

There would be 4 proofs obligations that will be cover by the SMT solvers, and 2 by Zenon for the most simple one. 
The SMT backend of \tlaplus generated the corresponding SMT input problem presented in \cref{lst:cantor-smt}.
We use the \textit{Cantor} example to illustrate the general approach taken to encode set-theoretic reasoning, as all proof obligations produced by the backend follow a similar structure.
Full details of the SMT encoding for \tlaplus are provided in \cite{new-encoding-tlaps}.
Since \tlaplus is based on ZFC that does not include \emph{sort}, the backend introduces a universal uninterpreted sort \tt{Idv} (line 2) to represent the domain of all values.
Within this setting, the function symbol \tt{FunApp} (line 6) encodes function application (i.e. $f[x]$), while \tt{Mem} (line 7) denotes set membership ($\in$).
The declared constant symbols \tt{S} and \tt{f} correspond to the set $S$ and function $f$ in the original proof.
The auxiliary function \tt{SetSt\_flatnd\_1} defines the diagonal set $T = \{ z \in S \mid z \notin f[z] \}$ by comprehension; this is specified by a universally quantified axiom stating that an element $X$ belongs to \tt{SetSt\_flatnd\_1 A} if and only if $X \in A$ and $X \notin f[X]$.
This axiom captures the definition of $T$ in a first-order setting.
The disjunctive assertion \tt{(or (Mem x ...) (not (Mem x ...)))} encodes a \emph{classical} reasoning by cases over whether $x$ belongs to $T$, reflecting how the proof splits based on $x \in T$ or $x \notin T$ in the original \tlaplus argument. 
Finally, the goal is asserted as the negation of the equation \tt{(FunApp f x) = (SetSt\_flatnd\_1 S)}, encoded via a triggerable equality predicate \tt{TrigEq\_Idv}.
Triggers play a crucial role in optimizing the encoding, as discussed in \cite[\S3]{new-encoding-tlaps}.
This encoding faithfully mirrors the structure of the original \tlaplus proof obligation \cref{fig:cantor-po}.

\smallskip

\begin{lstlisting}[language=SMT, caption={Proof obligation of step $\ps{1}{6.}$ in Cantor theorem},label={lst:cantor-smt}]
;; Sorts
(declare-sort Idv 0)

;; Hypotheses

(declare-fun FunApp (Idv Idv) Idv)
(declare-fun Mem (Idv Idv) Bool)
(declare-fun TrigEq_Idv (Idv Idv) Bool)
...
(declare-fun S () Idv)
(declare-fun f () Idv)
(declare-fun SetSt_flatnd_1 (Idv) Idv)

;; Axiom: SetStDef SetSt_flatnd_1
(assert
  (!
    (forall ((a Idv) (x Idv))
      (!
        (= (Mem x (SetSt_flatnd_1 a))
          (and (Mem x a)
            (not
              (Mem x
                (FunApp CONSTANT_f_ x)))))
        :pattern ((Mem x (SetSt_flatnd_1 a)))
        :pattern ((Mem x a)
                   (SetSt_flatnd_1 a))))
    :named |SetStDef SetSt_flatnd_1|))

(assert (forall ((A Idv) (X Idv))
        ( = 
            (Mem X (SetSt_flatnd_1 A))
            (and (Mem X A) (not (Mem X (FunApp f X))))
        )
    )
)

;; Goal
(assert (! (not (not (TrigEq_Idv (FunApp f x_) (SetSt_flatnd_1 S)))) :named |Goal|))
\end{lstlisting}

\smallskip