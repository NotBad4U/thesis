%*****************************************
\chapter{Related Works}\label{ch:relatedworks}
%*****************************************

\section{Proof search with hammers}

Several proof assistants employ \emph{hammers} for discharging goals to automatic theorem provers (ATPs), including SMT solvers. Examples include Sledgehammer \cite{Sledgehammer} for Isabelle/HOL and CoqHammer \cite{coqhammer1,coqhammer2} for Coq.
The hammer translates the conjecture and facts supplied by the user or harvested
from the context to the input language of the back-end, invokes it, and in the
case of success attempts to reconstruct the proof in the logic of the proof
assistant, based on a trace of the proof found by the back-end.

This process can benefit significantly from detailed proofs by the back-ends.
For example, adoption by Sledgehammer of the Alethe format generated by the SMT solver veriT \cite{isabelle1,isabelle2} cut the failure rate of reconstruction by 50\% and reduced the checking time by 13\%.
These results encouraged us to base our approach on the Alethe trace format.
The reconstruction procedure uses the RARE framework with IsaRare \cite{IsaRare}, a tool that can automatically translate RARE rules into Isabelle/HOL lemmas.
For arithmetic steps, it uses Isabelle's procedure \tt{linarith}. This tactic is a decision procedure for real numbers, but not for integers or natural numbers.
Internally, it uses the Fourier–Motzkin elimination \cite{linear-arith-book}: it derives a contradiction via a linear combination of the equations.

In CoqHammer, proof reconstruction is performed by an \emph{auto}-type algorithm implemented in Ltac \cite{ltac}. The proof search procedure does primarily backward Prolog-style reasoning modifying the goal by applying hypotheses from the context.
The core of the search procedure may be seen as an extension of the Ben-Yelles algorithm to first-order intuitionistic logic with all connectives \cite{urzyczyn_intuitionistic_2016}.
The proof reconstruction procedure is augmented with  the use of existential metavariables like in \tt{eauto}, a looping check, some limited forward reasoning, the use of the \tt{congruence tactic}, and heuristic
rewriting using equational hypotheses.
CoqHammer is typically evaluated on a benchmark consisting of 4841 lemmas from the Coq standard library and the Mathematical Components library, which serves as the standard benchmark for hammering in Coq.
The reconstruction mechanism currently is able to re-prove only 85.2\% (4215 out of 4841) of the proofs founds by the ATPs.
It is capable of re-proving over 40\% of Coq standard library lemmas.

\section{SMT integration in proof assistants}

In contrast to Hammers, which are designed to interface with general-purpose automated theorem provers (ATPs) such as Vampire \cite{vampire}, E Prover \cite{eprover}, or SMT solvers \cite{z3}, other approaches establish direct connections between proof assistants and SMT solvers.  
For instance, SMTCoq \cite{smtcoq} and Lean-SMT \cite{lean-smt} integrate Coq and Lean, respectively, with external SAT and SMT solvers, thereby leveraging the theory reasoning capabilities of SMT solvers that are not fully exploited by Hammers.

\paragraph{SMTCoq} is a fully certified Coq plugin that checks proof witnesses coming from external SAT and SMT solvers. For proof reconstruction, SMTCoq relies on computational reflection: the certificate is directly processed by the reduction mechanism of Coq's kernel.
We initially attempted to convert the SMTCoq proof certificate to Lambdapi. However, we found the proof term generated by computational reflection, including subterms corresponding to arithmetic decision procedures in Micromega \cite{micromega}, to be too complex to be converted to Lambdapi.
%
Moreover, SMTCoq is based on an old version of the Alethe proof format, which is only supported by older versions of the veriT solver.

\paragraph{Lean-SMT} is a tactic that provides SMT solver integration in the Lean proof assistant, similar to how SMTCoq integrates SMT solvers with Coq.
Lean-SMT operates by translating Lean proof goals into SMT-LIB problems and leveraging the proof-producing SMT solver cvc5 to generate proofs, which are then reconstructed as native Lean proofs.
Lean-SMT employs the Cooperating Proof Calculus (CPC)
%
\footnote{See \url{https://cvc5.github.io/docs/cvc5-1.2.1/proofs/output_cpc.html}. A complete
list of the proof rules in CPC can be found at \url{https://cvc5.github.io/docs/cvc5-1.
2.1/api/cpp/enums/proofrule.html}. The semantics of the rules is also defined in the
Eunoia logical framework, described in the user manual of the Ethos proof checker:
\url{https://github.com/cvc5/ethos/blob/main/user_manual.md}.}
%
based on Eunoia, a logical framework and language under development as part of the forthcoming SMT-LIB 3 standard.
Unlike SMTCoq, which employs a formally verified checker that validates entire SMT proofs within Coq, Lean-SMT uses a proof replay approach that reconstructs each individual proof step within Lean.
This design choice was motivated by the observation of the authors that Coq proof assistant is designed to be very fast at this, while Lean, on the other hand, is not \cite{lean-perf}.
Additionally, the proof replay approach offers greater flexibility compared to SMTCoq's verified checker, as modifications to the supported proof format only require changes to the corresponding reconstruction tactics rather than re-proving the entire checker's correctness theorem.
Lean-SMT currently supports around 200 of cvc5's proof rules which amounts to approximately 30\%, and has been evaluated on both Sledgehammer benchmarks and SMT-COMP benchmarks, showing competitive performance with other proof checkers while maintaining a small trusted base.


\section{Proof Checker for SMT Solvers}

\paragraph{Carcara} \cite{carcara} is an independent proof checker and proof elaborator for SMT proof traces in the Alethe format that is implemented in Rust \cite{rust}.
Although Carcara is not a certified checker like SMTCoq or Lean-SMT, it allows a coarse-grained proof trace, containing implicit steps, to be elaborated to a fine-grained one that includes more detailed steps or adds missing parameters.
The resulting trace can be easier to check by a proof assistant, and our work benefits particularly from Carcara's proof trace elaboration given, the lack of meta-programming in the vernacular language of Lambdapi.

\paragraph{Ethos} is an under-development proof checker \footnote{\url{https://github.com/cvc5/ethos/tree/main}}, written in C++, designed to verify proofs produced in the Eunoia format.
Eunoia is a logical framework that provides a formally defined language for representing proof systems and serves as the specification basis for the Cooperating Proof Calculus (CPC) employed by the SMT solver cvc5.
It is grounded in the SMT-LIB $3$  standard \footnote{\url{https://smt-lib.org/version3.shtml}}, which generalizes and extends the widely adopted SMT-LIB $2$ language in order to support higher-order logic with polymorphism and dependent types but classical semantics.
In spirit, it is comparable to the \emph{Alethe} proof format, which has been co-developed with proof checkers in Isabelle/HOL. 
However, while Alethe primarily aims to provide a standardized exchange format for SMT solver proofs, Eunoia is conceived as a more general logical framework in which proof systems can be defined, extended, and modularly verified. 
Analogously, Ethos plays a role similar to that of Carcara, which provides an independent proof checker for SMT proofs.


\section{Unverified SMT backends: The TLAPS case}

Beyond the hammer and direct SMT integration approaches discussed above, TLAPS (TLA+ Proof System) exemplifies another proof assistant that relies on SMT solvers for automation but lacks proof verification capabilities, presenting an opportunity to apply the reconstruction methods developed in this thesis.

\subsection{The language}

\tlaplus is a specification language based on the Temporal Logic of Actions and Zermelo–Fraenkel set theory with the Axiom of Choice (ZFC) \cite{tlabook,tla-ref}.
It is particularly used for specifying concurrent and distributed systems.
The \tlaplus Proof System (TLAPS) extends the language with a formal proof syntax and a tactical proof language \cite{tla-proofs}.

TLAPS includes a \emph{Proof Manager} that decomposes proofs into individual proof obligations, which are then dispatched to various backend provers.
These currently include Isabelle/\tlaplus \cite{isabelle-hol-ref}, Zenon \cite{zenonmodulo},
the SMT solvers cvc5 \cite{cvc5}, veriT \cite{verit} and Z3 \cite{z3}, and finally the LS4 prover for temporal logic.
Each obligation is translated into the logic supported by the corresponding backend.
For SMT solvers \cite{new-encoding-tlaps}, the supported logics include \textbf{UF}, \textbf{LIA}, and \textbf{NIA}.
At present, TLAPS does not verify the correctness of solver outputs, except in the case of Zenon, whose proofs can be independently validated by Isabelle,
and in the case of Isabelle/\tlaplus backend.

As the \cref{fig:interop-tla} suggests, the previous work discussed in \cref{ch:reconstruction} can be leveraged to verify \tlaplus proofs from the SMT solver backend.
The proposed approach involves extracting the output generated by the SMT backend, retrieving the corresponding proof from cvc5 or veriT, and reconstructing it within Lambdapi to establish its validity.
 

\subsection{Validating TLAPS proof}
\label{sec:validating-tlaps-proof}

% -------------- MODULE Cantor1 -----------------
% THEOREM cantor ==
%   \A S :
%     \A f \in [S -> SUBSET S] :
%       \E A \in SUBSET S :
%         \A x \in S :
%           f [x] # A
% PROOF
%   <1>1. TAKE S
%   <1>2. TAKE f \in [S -> SUBSET S]
%   <1>3. DEFINE T == { z \in S : z \notin f[z] }
%   <1>4. WITNESS T \in SUBSET S
%   <1>5. TAKE x \in S
%   <1>6. QED BY x \in T \/ x \notin T
\begin{figure}[tb]
\centering
\begin{nomodule}
\topbar{Cantor}
\[\begin{noj}
  \THEOREM\ cantor\ \deq \\
  \A S : \\
  \quad \A f \in [S \implies \SUBSET\ S] : \\
  \quad\quad \exists A \in \SUBSET\ S : \\
  \quad\quad\quad \forall x \in S : \\
  \quad\quad\quad\quad f \sq{x}{} \mathbin{\#} A \\
  \ps{1}{1.}\ \TAKE\ S \\
  \ps{1}{2.}\ \TAKE\ f \in [S \implies \SUBSET\ S]\\
  \ps{1}{3.}\ \DEFINE\ T\ \deq\ \{ z \in S : z \notin f[z] \}\\
  \ps{1}{4.}\ \WITNESS\ T\ \in \SUBSET\ S \\
  \ps{1}{5.}\ \TAKE\ x \in S \\
  \ps{1}{6.}\ \QED\ \BY\ x \in T \lor x \notin T
\end{noj}\]
\bottombar
\end{nomodule}
\caption{Cantor theorem in \tlaplus}
\label{fig:cantor-tlaps}
\end{figure}

\tlaplus proofs are hierarchically structured and are generally written top-down.
The assertion that the Cantor theorem stating that no function ($f$) from a set ($S$) to its power set (\SUBSET\ $S$) can be surjective is formalized in \tlaplus as the theorem in \cref{fig:cantor-tlaps}.
Each proof in the hierarchy ends with a \QED\ step that asserts the proof's goal.
Proofs are incrementally decomposed into simpler subproofs across multiple levels. Each proof consists of labeled steps $\ps{i}{k.}$, that reflect their depth in the proof tree, where level $n$ indicates the nesting depth.
Steps may introduce assumptions, intermediate claims, or invoke previously proven results, using TLAPS tactics such as \ASSUME/\PROVE\, \TAKE\ or \WITNESS.
The proof is completed when the root goal is reduced to a collection of leaf obligations marked as \QED\ and discharged by backend provers.
Moreover, TLAPS does not yet handle temporal reasoning.

For each step $\ps{i}{k.}$ in \tlaplus proof, there is a proof obligation that is to be proved.
The obligation contains a context of known facts, definitions, declarations, and a goal.
Obligations are sent to a suitable backend selected by the PM (Zenon, Isabelle/TLA, SMT solvers) that tries to prove it.
In the case of \cref{fig:cantor-tlaps}, we will have 6 proof obligations $(\ps{1}{1.} - \ps{1}{6.})$ that will be discharged to the backend.
For example, the proof obligation relative to the final step $\ps{1}{6.}$ is given as follows:

% ===============================================


% ;;	ASSUME NEW CONSTANT CONSTANT_S_,
% ;;	       NEW CONSTANT CONSTANT_f_ \in [CONSTANT_S_ -> SUBSET CONSTANT_S_],
% ;;	       NEW CONSTANT CONSTANT_x_ \in CONSTANT_S_,
% ;;	       CONSTANT_x_
% ;;	       \in {CONSTANT_z_ \in CONSTANT_S_ :
% ;;	              CONSTANT_z_ \notin CONSTANT_f_[CONSTANT_z_]}
% ;;	       \/ CONSTANT_x_
% ;;	          \notin {CONSTANT_z_ \in CONSTANT_S_ :
% ;;	                    CONSTANT_z_ \notin CONSTANT_f_[CONSTANT_z_]} 
% ;;	PROVE  CONSTANT_f_[CONSTANT_x_]
% ;;	       # {CONSTANT_z_ \in CONSTANT_S_ :
% ;;	            CONSTANT_z_ \notin CONSTANT_f_[CONSTANT_z_]}
\begin{figure}[tb]
\centering
\[\begin{noj}
  \quad\begin{noj2}
    \ASSUME & \NEW\ \CONSTANT\ S, \\
            & \NEW\ \CONSTANT\ f  \in [ S \implies \SUBSET\ S ], \\
            & \NEW\ \CONSTANT\ X  \in S, \\
            & \quad X \in T \lor \quad X \notin T \\
    \PROVE  & f[X] \neq T
  \end{noj2}
\end{noj}\]
\caption{Proof obligation of step  $\ps{1}{6.}$}
\label{fig:cantor-po}
\end{figure}

It assumes an arbitrary set $S$, a function $f \in [S \implies \SUBSET\ S]$, and an arbitrary element $X \in S$.
The goal is to prove that $f[X] \neq \{ z \in S \mid z \notin f[z] \}$.
This corresponds to the diagonalization step: given the definition $T \deq \{ z \in S \mid z \notin f[z] \}$ from $\ps{1}{3.}$, we aim to show that $T$ is not in the image of $f$.
To this end, we must show that for any $X \in S$, $f[X] \neq T$.
The assumption $X \in T \lor X \notin T$ provides a complete case split, and in either case, the assumption $f[X] = T$ leads to a contradiction, which suffices to discharge the proof obligation.


\smallskip

\begin{lstlisting}[language=SMT, caption={Proof obligation of step $\ps{1}{6.}$ in Cantor theorem},label={lst:cantor-smt}]
;; Sorts
(declare-sort Idv 0)

;; Hypotheses

(declare-fun FunApp (Idv Idv) Idv)
(declare-fun Mem (Idv Idv) Bool)
(declare-fun TrigEq_Idv (Idv Idv) Bool)
...
(declare-fun S () Idv)
(declare-fun f () Idv)
(declare-fun SetSt_flatnd_1 (Idv) Idv)

;; Axiom: SetStDef SetSt_flatnd_1
(assert
  (!
    (forall ((a Idv) (x Idv))
      (!
        (= (Mem x (SetSt_flatnd_1 a))
          (and (Mem x a)
            (not
              (Mem x
                (FunApp CONSTANT_f_ x)))))
        :pattern ((Mem x (SetSt_flatnd_1 a)))
        :pattern ((Mem x a)
                   (SetSt_flatnd_1 a))))
    :named |SetStDef SetSt_flatnd_1|))

(assert (forall ((A Idv) (X Idv))
        ( = 
            (Mem X (SetSt_flatnd_1 A))
            (and (Mem X A) (not (Mem X (FunApp f X))))
        )
    )
)

;; Goal
(assert (! (not (not (TrigEq_Idv (FunApp f x_) (SetSt_flatnd_1 S)))) :named |Goal|))
\end{lstlisting}

\smallskip

There would be 4 proof obligations that will be covered by the SMT solvers, and 2 by Zenon for the most simplest one. 
The SMT backend of \tlaplus generated the corresponding SMT input problem presented in \cref{lst:cantor-smt}.
Since \tlaplus is based on ZFC, which does not include \emph{sort}, the backend introduces a universal uninterpreted sort \tt{Idv} (line 2) to represent the domain of all values.
Within this setting, the function symbol \tt{FunApp} (line 6) encodes function application (i.e. $f[x]$), while \tt{Mem} (line 7) denotes set membership ($\in$).
The declared constant symbols \tt{S} and \tt{f} correspond to the set $S$ and function $f$ in the original proof.
The auxiliary function \tt{SetSt\_flatnd\_1} defines the diagonal set $T = \{ z \in S \mid z \notin f[z] \}$ by comprehension; this is specified by a universally quantified axiom stating that an element $X$ belongs to \tt{SetSt\_flatnd\_1 A} if and only if $X \in A$ and $X \notin f[X]$.
This axiom captures the definition of $T$ in a first-order setting.
The disjunctive assertion \tt{(or (Mem x ...) (not (Mem x ...)))} encodes a \emph{classical} reasoning by cases over whether $x$ belongs to $T$, reflecting how the proof splits based on $x \in T$ or $x \notin T$ in the original \tlaplus argument. 
Finally, the goal is asserted as the negation of the equation \tt{(FunApp f x) = (SetSt\_flatnd\_1 S)}, encoded via a triggerable equality predicate \tt{TrigEq\_Idv}.
Triggers play a crucial role in optimizing the encoding, as discussed in \cite[\S3]{new-encoding-tlaps}.
%
This encoding faithfully mirrors the structure of the original \tlaplus proof obligation \cref{fig:cantor-po}.
We used the \textit{Cantor} example to illustrate the general approach taken to encode set-theoretic reasoning, as all proof obligations produced by the backend follow a similar structure.
Full details of the SMT encoding for \tlaplus are provided in \cite{new-encoding-tlaps}.

By leveraging the work presented in this thesis, we can establish a complete verification pipeline for TLAPS proofs: the SMT solver proof traces can be elaborated using Carcara to produce detailed Alethe format proofs, which are then reconstructed in Lambdapi using our reconstruction framework to verify their correctness.
This approach would transform TLAPS from a partially verified proof assistant into a fully certified system where all SMT-backed proofs undergo rigorous verification, thereby enhancing the trustworthiness of TLA+ specifications and their proofs.