\section{Translating the SMT input problem}

We now describe how we encode input problems expressed in a given
SMT-LIB signature \cite[\S 5.2.1]{smtlib}. In order to avoid a notational clash with the Lambdapi signature $\Sigma$, we denote the set of SMT-LIB sorts as $\Theta^\mathcal{S}$, the set of function symbols $\Theta^\cal{F}$, and the set of variables $\Theta^\cal{X}$.
Alethe does not support the sorts \texttt{Array} and \texttt{String}. Our translation is based on the following functions:
\begin{itemize}
\item $\cal{D}$ translates declarations of sorts and functions in $\Theta^\cal{S}$ and $\Theta^\mathcal{F}$ into constants,
\item $\cal{S}$ maps sorts to $\Sigma$ types,
\item $\cal{E}$ translates SMT expression to $\lpm$ terms,
\item $\cal{C}$ translates a list of commands  $c_1 \dots c_n$ of the form\\
  $i.~\Gamma \triangleright~\varphi~(\mathcal{R}~P)[A]$ to typing judgments $\Gamma \vdash_\Sigma i : N$ with $N$ the corresponding type of the clause $\varphi$.
\end{itemize}

\smallskip

\begin{definition}[Function $\mathcal{D}$ translating SMT sort and function symbol declarations]
For each sort symbol $s$ with arity $n$ in $\Theta^\cal{S}$ we create a constant $s: \set \ra \dots \ra \set$.
For each function symbol $f~\sigma^+$ in $\Theta^\cal{F}$ we create a constant $f: \cal{S}(\sigma^+)$.
\end{definition}

\smallskip

In other words, all SMT sorts used in the Alethe proof trace will be defined as constants that inhabit the type \set{} in the signature context $\Sigma$.
For every function declared in the SMT prelude, we define a constant whose arity follows the sort declared in the SMT prelude. The translation of sorts is formally defined as follows.

\smallskip

\begin{definition}[Function $\mathcal{S}$ translating sorts of expression] 
  The definition of $\mathcal{S}$(s) is as follows.
  \begin{itemize}
    \item Case $s =$ \smtinline{Bool}, then $\Sort{s} = \el\,o$,
    \item Case $s =$ \smtinline{Int}, then $\Sort{s} = \el~\tt{int}$,
    \item Case $s =$ \smtinline{Real}, then $\Sort{s} = \el\,\tt{rational}$,
    \item Case $s =$ \smtinline{BitVec} $n$, then $\Sort{s} = \el\,(\tt{bitvec}~\cal{E}(n))$,
    \item Case $s = \sigma_1\,\sigma_2 \dots \sigma_n$ then $\Sort{s} = \el{} (\mathcal{S}(\sigma_1) \leadsto \dots \leadsto \mathcal{S}(\sigma_n))$,
    \item otherwise $\Sort{s} = \el\, \mathcal{D}(s)$.
    % where the symbol $s$ on the right-hand side denotes the Lambdapi sort introduced for the SMT sort $s$.
  \end{itemize}
\end{definition}

\smallskip

\begin{example}{Translation of the prelude in \cref{lst:smtexampleinput}.}
\begin{lstlisting}[language=Lambdapi]
symbol U : Set;
symbol a : El U;
symbol b : El U;
symbol p : El (U â¤³ o);
\end{lstlisting}
\end{example}

\smallskip

\begin{definition}[Function $\cal{E}$ translating SMT expressions]
The definition of $\E{e}$ is as follows.
\begin{itemize}
\setlength{\parskip}{0pt}
\item Case e $= (p~t_1~t_2\dots~t_n)$ and $p$ a logical operator, then $\E{e} = \E{t_1}~p~\dots~p~\E{t_n}$.
\item Case e $= (g~t_1\dots~t_n)$ with $g \in \Theta^\cal{F}$,\\
  then $\E{e} = (\mathcal{D}(g)~\E{t_1}~\dots~\E{t_n})$.
\item Case e $= (\approx~t_1~t_2)$ then $\E{e} = (\E{t_1} = \E{t_2})$.
\item Case e $= (Q~x_1  \dots x_n ~t)$ and $Q\in \{\kw{forall}, \kw{exists}\}$\\
  then $\E{e} = Q x_1, \dots, Q x_n, \E{t}$. 
\item Case e $= (\kw{choice}~x : \sigma ~t)$ then $\E{e} = \epsilon~x: \cal{S}(\sigma),\, \E{t}$.
\item Case $e = (x: \sigma )$ with $x \in \Theta^\mathcal{X}$ a sorted variable, then $\E{e} = x: \cal{S}(\sigma)$.
\item Case $e = (\kw{ite}~c~t~e)$, then $\E{e} = \kw{ite}~\E{c}~\E{t}~\E{e}$.
\item Case $e = (\kw{xor}~a~b)$, then $\E{e} = \kw{xor}~\E{a}~\E{b}$.
\item Case $e = (\kw{distinct}~t_1 \dots t_n)$,\\
  then $\E{e} = \kw{distinct}~(\E{t_1} \colon\colon ...\, \colon\colon ~\E{b} \colon\colon \square)$.
\end{itemize}
\end{definition}

The last three cases in the above definition refer to operators \kw{ite}, \kw{xor} and \kw{distinct} that we defined in the Lambdapi prelude and that represent the homonyomous SMT operators.
The operator \kw{distinct} takes inputs of type $\kw{Vec}: \set \ra \N \ra \type$, that is, lists of size $n$. It has two constructors $\square : \kw{Vec}~a~0$ that represents the empty vector and $(\colon\colon): \Pi a : \set, \Pi\,n : \N, \el\, a \ra \kw{Vec}~a~n \ra \kw{Vec}~a~(n+1)$ that adds an element to the beginning of a vector.
We chose this data type because the \kw{distinct\_elim} rule in Alethe \cite[(Rule 93)]{alethespec} behaves differently depending on the size and the sort of terms.

\subsection{Encoding clauses}

Alethe distinguishes between clauses that appear in steps, such as \colorbox{green!30}{(cl~$l_1 \dots l_n$)} in \cref{eq:step}, and ordinary disjunction \cite[\S 4]{alethespec}. The syntax for clauses uses the \textcolor{purple}{\texttt{cl}} operator, while disjunction is represented as the standard SMT-LIB \textcolor{purple}{\texttt{or}}.
Alethe provides the \kw{or} rule for converting disjunctions into clauses:
\[
\begin{matrix*}[l]
  i. & \triangleright & \varphi_1 \lor \dots \lor \varphi_n  & (\dots) \\
  j. & \triangleright & (\texttt{\textcolor{purple}{cl}}~\varphi_1 \dots \varphi_n)  & (\kw{or}~i)[] \\
\end{matrix*}
\]

In particular, note that the ``literals'' appearing in clauses may actually be arbitrary formulas in Alethe. We define the type $\kw{Clause}$ that encodes an Alethe clause as a list of propositions. The constructor $\veedot$ prepends an element to a list, and $\nil$ is the empty list.
The append operator $\pp$ concatenates two lists. Logically, clauses are interpreted as disjunctions via the function $\cal{F}$ defined by rewriting rules. For convenience, we also introduce the predicate $\pic$ asserting that a clause is provable.

\begin{figure}
  \begin{align*}
  &\texttt{Clause}: \type & &\cal{F}: \texttt{Clause} \ra \prop \\
  &\nil: \texttt{Clause} & & \cal{F}~\nil \re \bot \\
  &\veedot: \prop \ra \texttt{Clause}  \ra \texttt{Clause} & & \cal{F}~x \veedot y \re x \lor (\cal{F}~y) \\
  & \pp: \texttt{Clause} \ra \texttt{Clause} \ra  \texttt{Clause} & &\pid (c : \texttt{Clause}) \coloneqq \pic (\cal{F}~c)  \\
  & \nil \mathop{\pp} x \re x & & \\
  & (x \veedot y) \mathop{\pp} z \re x \veedot (y \mathop{\pp} z) & &
  \end{align*}
  \caption{The \texttt{Clause} type and operations on clauses.}
\end{figure}

We can now prove the equivalence between clause and disjunction.

\smallskip

\begin{lemma}[Clause elimination]\label{lemma:clause-elim}
For any $p : \prop$ and $q,r : \texttt{Clause}$, If $\pid (p \veedot q)$ and $(\pid (p \veedot \nil) \ra  \pid r)$ and $(\pid q \ra  \pid r)$
then $\pid r$.
\end{lemma}
\begin{proof}
Since the hypothesis $\pid (p \veedot q)$ is equivalent to $\pic (p \lor \cal{F}\,q)$, we apply the classic disjunction elimination rule.
Then we can conclude $\pic p \ra \pic (\cal{F}\,r)$ wih the hypothesis $\pid (p \veedot \nil) \ra  \pid r$, and we can conclude $\pic (\cal{F}\,q) \ra \pic (\cal{F}\,r)$
with the hypothesis $\pid q \ra  \pid r$.
\end{proof}

\smallskip

\begin{lemma}[Concatenation is disjunction]\label{lemma:clause-equiv-disj}
For any two clauses $a\,b$, the equivalence $\pic (\cal{F}(a~\pp~b)) \Leftrightarrow \pic (\cal{F}\,a \lor \cal{F}\,b)$ holds.
\end{lemma}
\begin{proof} By induction on $a$.
  \begin{itemize}
  \item For the base case $a = \nil$ we must show that $\pic\, (\cal{F} (\nil\, \pp \, b)) \Leftrightarrow \pic\, (\cal{F}\,\nil \lor \cal{F}\,b) $. The implication ``$\Rightarrow$'' is trivial because $\nil\,\pp\,b$ rewrites to $b$. The implication ``$\Leftarrow$'' is proved using the standard elimination rule $\lor_e$ for disjunction, which requires proving $\pic\,(\cal{F}\,\nil) \ra \pic\,(\cal{F}\,(\nil\,\pp\,b))$ as well as $\pic\,(\cal{F}\,b) \ra \pic\,(\cal{F}\,(\nil\,\pp\,b))$. Both proofs are immediate since $\cal{F}\,\nil$ rewrites to $\bot$ and $\nil\,\pp\,b$ rewrites to $b$.
  \item For the case $a = h \veedot tl$ we may use the induction hypothesis $\pic\,(\cal{F}\, (tl\, \pp\, b)) \Leftrightarrow \pic\,(\cal{F}\,tl \lor \cal{F}\, b)$. The conclusion is then easy to prove based on the rewriting rules for the operators $\cal{F}$ and $\pp$, together with associativity of $\lor$.
  \end{itemize}
\end{proof}
