%*****************************************
\chapter{Reconstructing Linear Arithmetic proofs}\label{ch:reconstruction-la}
%*****************************************


\section{Reconstruction of Linear Integer Arithmetic}
\label{sec:lia-reconstruction}

\todo{Review also this section when Rational will be introduce. Maybe LRA will be introduce before LIA if LA is finished and well tested.}

In this section, we address the challenge of reconstructing the rule $\kw{la\_generic}$, as detailed in \cref{sssect:la-in-alethe} when it is used in \textbf{LIA} logic.
This rule corresponds to a proof step in which a set of linear inequalities is shown to be contradictory such as \cref{lst:example-lia-contra}.
The Alethe specification guaranteed that the contradiction has to reduce to a normal form: $0 \bowtie k$ where $k$ is constant with $k > 0$, and $\bowtie \in \{ \geq, > \}$.

\smallskip

\begin{lstlisting}[language=SMT, label={lst:example-lia-contra}]
(step t11 (cl (not (<= f 0)) (<= (+ 1 (* 4 f)) 1))
  :rule la_generic :args (1/1 1/4))
\end{lstlisting}

\smallskip

Unlike most of the other arithmetic rules described in \cref{table:linear-arith-rules}, reconstructing $\kw{la\_generic}$ poses a distinct challenge.
It often requires reasoning about algebraic identities that hold modulo the axioms of algebraic structures such as groups.
These identities are typically derived through elementary combinations of canonical equalities. Other rules are just encoded as regular lemma
following the previous method we described in \cref{ch:reconstruction-ul}.

We reconstruct steps using the $\kw{la\_generic}$ rule through a second-kind proof by reflection.
The goal is to implement an automated procedure that computes the final sum of inequalities, as described in the Alethe algorithm, by combining implicit rewriting steps to normalize and simplify expressions.
Our approach relies on a normalization function along with a proof of its correctness.
In this work, we support two proof-generation strategies. The first uses \lpinline{associative commutative} modifiers to normalize terms directly within the Lambdapi kernel.
This makes the approach efficient but relies on a meta-level correctness argument for normalization.
The second encodes the normalization function in Lambdapi and performs symbolic execution to compute the result. While slower, this method provides a fully internal correctness proof within Lambdapi.
We will denote the first strategy as the \emph{inner normalization} and the second strategy as the \emph{outer normalization}.

\section{General scheme of the reflective reconstruction}

The procedure operates on a group structure $\bb{G}$ that will differ between two strategies. It includes a base type for its elements and constructors to reflect $\Z$, together with the usual axioms defining a
commutative group structure. The goal is to prove the contradiction of an inequality between two terms $g1 \bowtie g2$  of type $\bb{G}$ modulo the group axioms.
Working by reflection means that we build a semi decision procedure, which will take $t1$ and $t2$ of type $\bb{Z}$ as arguments and compare them (i.e. returns a term of type $\kw{Comp}$ ) modulo associative-commutative rewriting in the group structure.

Once we have built the two $\bb{G}$, $g1$ and $g2$ with a reification $\reify{()}$, corresponding to $t1$ and $t2$,
the idea is to check the equality of the normal forms of $g1$ and $g2$ denoted by the function $[\_]$ and to prove
that this implies the same comparison of $t1$ and $t2$ in $\Z$ through a denotation function $\den{()}$. For this purpose, we should ensure the correctness of the following diagram:

\begin{center}
% % https://q.uiver.app/#q=WzAsOCxbMSwyLCJcXGJ1bGxldCJdLFsxLDAsIlxcYnVsbGV0Il0sWzMsMiwiXFxidWxsZXQiXSxbMywwLCJcXGJ1bGxldCJdLFswLDIsInRfMSA9X1xcbWF0aGJie1p9IHRfMiJdLFswLDAsIlxcRG93bmFycm93KFxcVXBhcnJvdyh0XzEpKSA9X1xcbWF0aGJie1p9IFxcRG93bmFycm93KFxcVXBhcnJvdyh0XzIpKSJdLFs0LDAsIlxcRG93bmFycm93KFtnXzFdKSA9X1xcbWF0aGJie1p9IFxcRG93bmFycm93KFtnXzJdKSJdLFs0LDIsImdfMSA9X1xcbWF0aGJie1p9IGdfMiJdLFswLDEsIlxcRG93bmFycm93KFxcVXBhcnJvdyhcXF8pKSJdLFswLDIsIlxcaWZmIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZG90dGVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwzLCJbXFxfXSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFszLDIsIlxcRG93bmFycm93KFxcXykiXSxbMSwyLCIiLDAseyJzdHlsZSI6eyJuYW1lIjoiY29ybmVyIn19XV0=
\(\begin{tikzcd}[ampersand replacement=\&,column sep=small]
	{\Uparrow(t_1) \bowtie_\bb{G} (\Uparrow(t_2)} \& \bb{G} \&\& \bb{G} \& {[g_1] \bowtie_\bb{G} [g_2]} \\
	\\
	{t_1 \bowtie_\Z t_2} \& \Z \&\& \Z \& {(\den{[g_1]}) \bowtie_\Z (\den{[g_2]}}
	\arrow["{[\_]}", dashed, from=1-2, to=1-4]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-2, to=3-4]
	\arrow["{\Downarrow(\_)}", from=1-4, to=3-4]
	\arrow["{\Uparrow(\_)}", from=3-2, to=1-2]
	\arrow["\iff"{description}, dotted, no head, from=3-2, to=3-4]
\end{tikzcd}\)
with $\bowtie \in \{ \geq, > \}$.
\end{center}

\section{Reflection with inner normalization}

We start by presenting the first strategy based on a reflection with inner normalization.

\subsection{Representation of integers}
\label{ssec:representation}

\begin{definition}[Type $\bb{G}$]\label{def:G-inner}
The procedure is based on an algebraic group structure, denoted as  $\bb{G}$, which represents linear polynomials.
The base type for its elements is $\bb{G}: \type$. The unary operator $\tt{cst}$ injects constants from $\Z$ into $\bb{G}$.
\begin{align*}
& \bb{G}: \type \\
&|~\add{}{}: \bb{G} \ra \bb{G} \ra \bb{G} \\
&|~\tt{var}: \Z \ra \Z \ra \bb{G} \\
&|~\tt{mul}: \Z \ra \bb{G} \ra \bb{G} \\
&|~\tt{opp}: \bb{G} \ra \bb{G} \\
&|~\tt{cst}: \Z \ra \bb{G} \\
&\tt{grp}: \set \\
&\el~\tt{grp} \re \bb{G}
\end{align*}
The term $\tt{var}~c~x$ is intended for representing expressions $c \times x$ that appear as constituents of linear inequalities, where $c$ is an integer coefficient and $x$ a $\Z$ term, in particular a variable.
The constructor $\tt{mul}$  represents the multiplication of an element of $\bb{G}$ by a constant. The constructor $\tt{opp}$ corresponds to unary minus.
Lastly, the constructor $\add{}{}$ represents the addition between two elements of $\bb{G}$ and it has the \lpinline{associative commutative} modifiers.
\end{definition}

\begin{definition}[Reification and denotation]
Reification ($\reify{}$) and denotation ($\den{}$) functions for $\bb{G} \rightleftarrows \bb{Z}$.
\begin{align*}
& \reify{} : \Z \ra \bb{G} & & \den{}: \bb{G} \ra \Z \\
& \reify{\ZO} \re \cst{\ZO} & & \den{\cst{c}} \re c \\
& \mathop{\reify{\ZPos}} c \re \cst{(\ZPos c)} & & \den{\opp{x}} \mathrel{\re}  \mathop{\sim (\den{x})} \\
& \mathop{\reify{\ZNeg}} c \re \cst{(\ZNeg c)} & & \den{\mul{c}{x}} \re  c \times (\den{x}) \\
& \reify{(x + y)} \re \add{(\reify{x})}{(\reify{y})} & & \den{\add{x}{y}} \re (\den{x}) + (\den{y}) \\
& \reify{(\sim x)} \re \opp{(\reify{x})} & & \den{\var{c}{x}} \re  c \times x \\
& \mathop{\reify{((\mathop{\ZPos} c) * x})} \re \mul{(\mathop{\ZPos} c)}{(\reify{x})} & & \\
& \mathop{\reify{((\mathop{\ZNeg} c) * x)}} \re \mul{(\mathop{\ZNeg} c)}{(\reify{x})} & & \\
& \mathop{\reify{(x * (\mathop{\ZPos} c))}} \re \mul{(\mathop{\ZPos} c)}{(\reify{x})} & & \\
& \mathop{\reify{(x * (\mathop{\ZNeg} c))}} \re \mul{(\mathop{\ZNeg} c)}{(\reify{x})} & & \\
& \mathop{\reify{x}} \re \var{1}{x} & &
\end{align*}
\end{definition}

\subsection{Associative Commutative Inner Normalization}
\label{ssec:normalization}

The transformation to canonical form implemented in Lambdapi ensures that sum expressions of the form $\var{c_1}{x_1} \oplus \cst{k_1} \oplus \var{c_2}{x_2} \oplus \dots \oplus \cst{k_m} \oplus \dots \oplus \var{c_n}{x_n}$
will be normalized such that any pair of terms $\var{p}{x}$ and $\var{q}{x}$ involving the same variable $x$ are placed next to each other,
and all $\cst{k_i}$ will be placed at the left before the first variable $\var{c_j}{x_j}$.

\begin{example}
Consider the term below not in normal form:
\begin{small}
\[ \var{c_1}{x} \oplus \cst{k_1} \oplus \var{c_2}{y} \oplus \cst{k_m} \oplus \var{c_3}{x} \oplus \var{c_4}{y} \]
\end{small}

We would like to have this normal form to reduce after the term:
\begin{small}
\[ \cst{k_1} \oplus \cst{k_2} \oplus \var{c_1}{x}  \oplus \var{c_3}{x} \oplus \var{c_2}{y} \oplus \var{c_4}{y} \]
\end{small}
\end{example}

\begin{definition}[Rewriting rules for $\bb{G}$]\label{def:grp-arith-ops}
Rewriting rules for reducing $\bb{G}$ expressions:
\begin{align}
&\add{\var{c_1}{x}}{\var{c_2}{x}} \re \var{(c_1 + c_2)}{x} \\
&\add{\var{c_1}{x}}{(\add{\var{c_2}{x}}{y})} \re \add{\var{(c_1 + c_2)}{x}}{y} \\
&\add{\cst{c_1}}{\cst{c_2}} \re \cst{c_1 + c_2} \\
&\add{\cst{c_1}}{(\add{\cst{c_2}}{y})} \re \add{\cst{c_1 + c_2}}{y} \\
&\add{\cst{0}}{x} \re x \\
&\add{x}{\cst{0}} \re x \\
&\opp{\var{c}{x}} \re \var{(-c)}{x} \\
&\opp{\cst{c}} \re \cst{(-c)} \\
&\opp{(\opp{x})} \re x \\
&\opp{(\add{x}{y})} \re \add{(\opp{x})}{(\opp{y})} \\
&\opp{(\mul{k}{x})} \re \mul{(-k)}{x} \\
&\mul{\kw{Z0}}{\var{\_}{\_}} \re \cst{0} \\
&\mul{k}{\var{c}{x}} \re \var{(k * c)}{x} \\
&\mul{k}{(\opp{x})} \re \mul{(-k)}{x} \\
&\mul{k}{(\add{x}{y})} \re \add{(\mul{k}{x})}{(\mul{k}{y})} \\
&\mul{k}{\cst{c}} \re \cst{(k * c)} \\
&\mul{c_1}{(\mul{c_2}{x})} \re \mul{(c_1 * c_2)}{x}
\end{align}
\end{definition}

\begin{remark}
The resulting normal forms do not contain the constructors $\tt{mul}$ and $\tt{opp}$, as the associated rewrite rules eliminate them in favor of $\tt{var}, \tt{add}$ and $\tt{cst}$.
\end{remark}

\begin{definition}%[AC-canonical form]
The $\leq$ builtin total order on $\bb{G}$-terms is defined as follows:
Terms are ordered such that $\tt{cst}(c_1) \leq \tt{cst}(c_2) < \var{p}{x}$ for any constants $c_1, c_2$ and any variable term $\var{p}{x}$, with $c_1 \leq c_2$.
For variable terms, $\var{p}{x} \leq \var{q}{y}$ if either $x < y$, or $x = y$ and $p \leq q$.
Let $\twoheadrightarrow^{AC}$ be the relation mapping every term t to its unique AC-canonical form denoted $[t]$.
\end{definition}

Two terms $t$ and $u$ are AC-equivalent (written $t \simeq_{AC} u$) iff their AC-canonical forms are equal.

\begin{definition}%[Rewriting modulo AC-canonization]
The relation $\ACcanon$ is defined as $\re_\Sigma\,\twoheadrightarrow^{AC}$, where $\Sigma$ contains the rewrite rules of \cref{def:arith-ops,def:grp-arith-ops}.
\end{definition}

An $\ACcanon$ step is a standard $\re_\Sigma$ step with syntactic matching followed by AC-canonicalization. We now prove that the relation $\ACcanon$ terminates and is confluent.

\begin{lemma}
	The relation $\mathop{\rwModAC} \mathrel{=} \mathop{\simeq_{AC} \, \re_\Sigma \, \simeq_{AC}}$ of matching modulo AC, which contains $\ACcanon$, terminates.
\end{lemma}
\begin{proof}
AProVE \cite{aprove} proves the termination of $\rwModAC$.
\end{proof}


\begin{lemma}
	$\ACcanon$ is locally confluent on AC-canonical terms.
\end{lemma}
\begin{proof}
We show that every critical pair is joinable using $\ACcanon$ and confluence of $\ra_\Z$ and $\ra_\bb{P}$ from \cref{lemma:confluenceZP}.
We use the notation $\MRAC$ to denote a multistep rewriting with AC-canonical form.

% t ≔ opp (add (var $k $x) (var $c $x))
% t ↪[] add (opp (var $k $x)) (opp (var $c $x)) ↪* var (— $k + — $c) $x
%   with opp (add $x' $y') ↪ add (opp $0') (opp $1')
% t ↪[1] opp (var ($0 + $2) $1) ↪* var (— ($0 + $2)) $1
%   with add (var $k $x) (var $c $x) ↪ var ($0 + $2) $1
\begin{center}
\cp
{
  \opp{(\underline{\var{c_1}{x} \oplus \var{c_2}{x}})}
}
{
  \opp{\var{c_1}{x}} \oplus \opp{\var{c_2}{x}}
}
{
  \opp{\var{(c_1 + c_2)}{x}}
}
{11}{2}
\end{center}

But $\opp{\var{c_1}{x}} \oplus \opp{\var{c_2}{x}} \MRAC \var{(- c_1 + (- c_2))}{x}$
and $\opp{\var{(c_1 + c_2)}{x}} \MRAC \var{- (c_1 + c_2)}{x}$ converge by using the rewrite rule $- (x + y) \re - x + (- y)$
in $\ra_\Z$ and its confluence.

The argument is similar for all the following critical pairs:

% t ≔ opp (add (var $k $x) (add (var $l $x) $y))
% t ↪[] add (opp (var $k $x)) (opp (add (var $l $x) $y)) ↪* add (var (— $k + — $l) $x) (opp $y)
%   with opp (add $x' $y') ↪ add (opp $0') (opp $1')
% t ↪[1] opp (add (var ($0 + $2) $1) $3) ↪* add (var (— ($0 + $2)) $1) (opp $3)
%   with add (var $k $x) (add (var $l $x) $y) ↪ add (var ($0 + $2) $1) $3
\begin{center}
\cp
{
  \opp{\underline{(\var{c_1}{x} \oplus (\var{c_2}{x} \oplus y))}}
}
{
  \opp{\var{c_1}{x}} \oplus \opp{(\var{c_2}{x} \oplus y)}
}
{
  \opp{\var{(c_1 + c_2)}{x} \oplus y)}
}
{11}{3}
\end{center}

\medskip

% We note that $\opp{\var{c_1}{x}} \oplus \opp{(\var{c_2}{x} \oplus y)} \MRAC \add{\var{(- c_1 + (- c_2))}{x}}{(\opp{y})}$
% and $\opp{\var{(c_1 + c_2)}{x} \oplus y} \MRAC \add{\var{(- (c_1 + c_2))}{x}}{(\opp{y})}$
% both reduce to the same term, as guaranteed by the confluence of $\ra_\Z$.

% t ≔ opp (add (cst $k) (cst $l))
% t ↪[] add (opp (cst $k)) (opp (cst $l)) ↪* cst (— $k + — $l)
%   with opp (add $x' $y') ↪ add (opp $0') (opp $1')
% t ↪[1] opp (cst ($0 + $1)) ↪* cst (— ($0 + $1))
%   with add (cst $k) (cst $l) ↪ cst ($0 + $1)
\begin{center}
\cp{
  \opp{(\underline{\cst{c_1} \oplus \cst{c_2}})}
}
{
  \opp{\cst{c_1}} \oplus \opp{\cst{c_2}}
}
{
  \opp{\cst{(c_1 + c_2)}}
}
{11}{4}
\end{center}
\medskip

% We observe that $\opp{\cst{c_1}} \oplus \opp{\cst{c_2}} \MRAC \cst{(- c_1) + (- c_2)}$
% and $\opp{\cst{(c_1 + c_2)}} \MRAC \cst{- (c_1 + c_2)}$ reduce to the same result due to the confluence of $\ra_\Z$.


% t ≔ opp (add (cst $k) (add (cst $l) $y))
% t ↪[] add (opp (cst $k)) (opp (add (cst $l) $y)) ↪* add (cst (— $k + — $l)) (opp $y)
%   with opp (add $x' $y') ↪ add (opp $0') (opp $1')
% t ↪[1] opp (add (cst ($0 + $1)) $2) ↪* add (cst (— ($0 + $1))) (opp $2)
%   with add (cst $k) (add (cst $l) $y) ↪ add (cst ($0 + $1)) $2
\begin{center}
\cp
{
  \opp{(\underline{\cst{c_1} \oplus (\cst{c_2} \oplus y)})}
}
{
  \opp{\cst{c_1}} \oplus \opp{(\cst{c_2} \oplus y)}
}
{
  \opp{(\cst{c_1 + c_2} \oplus y)}
}
{11}{5}
\end{center}
\medskip

% The expressions $\opp{\cst{c_1}} \oplus \opp{(\cst{c_2} \oplus y)} \MRAC \cst{(- c_1) + (- c_2)} \oplus \opp{y}$
% and $ \opp{(\cst{c_1 + c_2} \oplus y)} \MRAC \add{ \cst{- (c_1 + c_2)} }{\opp{y}}$
% both reduce to a common term, which follows from the confluence property of $\ra_\Z$.

% t ≔ add (var $k' $x) (add (var $k $x) (add (var $l $x) $y))
% t ↪[] add (var ($0' + $k) $x) (add (var $l $x) $y) ↪* add (var (($0' + $k) + $l) $x) $y
%   with add (var $k' $x') (add (var $l' $x') $y') ↪ add (var ($0' + $2') $1') $3'
% t ↪[1] add (var $k' $x) (add (var ($0 + $2) $1) $3) ↪* add (var ($k' + ($0 + $2)) $x) $3
%   with add (var $k $x) (add (var $l $x) $y) ↪ add (var ($0 + $2) $1) $3
\begin{center}
\cp
{
  \var{c_1}{x} \oplus \underline{(\var{c_2}{x} \oplus (\var{c_3}{x} \oplus y))}
}
{
  \var{(c_1 + c_2)}{x} \oplus ((\var{c_3}{x} \oplus y))
}
{
  \var{c_1}{x} \oplus (\var{(c_2 + c_3)}{x} \oplus y))
}{3}{3}
\end{center}
\medskip

% The terms $\var{(c_1 + c_2)}{x} \oplus ((\var{c_3}{x} \oplus y)) \MRAC \add{\var{(c_1 + (c_2 + c_3))}{x}}{y}$
% and $\var{c_1}{x} \oplus (\var{(c_2 + c_3)}{x} \oplus y)) \MRAC \add{\var{((c_1 + c_2) + c_3)}{x}}{y}$
% both reduce to the same result due to the confluence of $\ra_\Z$.

% t ≔ add (cst $k') (add (cst $k) (add (cst $l) $y))
% t ↪[] add (cst ($0' + $k)) (add (cst $l) $y) ↪* add (cst (($0' + $k) + $l)) $y
%   with add (cst $k') (add (cst $l') $y') ↪ add (cst ($0' + $1')) $2'
% t ↪[1] add (cst $k') (add (cst ($0 + $1)) $2) ↪* add (cst ($k' + ($0 + $1))) $2
%   with add (cst $k) (add (cst $l) $y) ↪ add (cst ($0 + $1)) $2
\begin{center}
\cp
{\cst{c_1} \oplus \underline{(\cst{c_2} \oplus (\cst{c_3} \oplus y))}}
{\cst{(c_1 + c_2)} \oplus (\cst{c_3} \oplus y) }
{\cst{c_1} \oplus (\cst{(c_2 + c_3)} \oplus y) }
{5}{5}
\end{center}
\medskip

% We observe that $\cst{c_1 + c_2} \oplus (\cst{c_3} \oplus y) \MRAC \add{\cst{((c_1 + c_2) + c_3)}}{y}$
% and $\cst{c_1} \oplus (\cst{(c_2 + c_3)} \oplus y) \MRAC \add{\cst{(c_1 + (c_2 + c_3)}}{y}$
% both reduce to the same expression due to the confluence property of $\ra_\Z$.

% t ≔ mul $k' (mul $k (mul $l $z))
% t ↪[] mul ($0' * $k) (mul $l $z) ↪* mul (($0' * $k) * $l) $z
%   with mul $k' (mul $l' $z') ↪ mul ($0' * $1') $2'
% t ↪[1] mul $k' (mul ($0 * $1) $2) ↪* mul ($k' * ($0 * $1)) $2
%   with mul $k (mul $l $z) ↪ mul ($0 * $1) $2
\begin{center}
\cp
{ \mul{c_1}{\underline{(\mul{c_2}{(\mul{c_3}{z})})}} }
{ \mul{(c_1)}{ (\mul{(c_2 * c_3)}{z}) } }
{ \mul{(c_1 * c_2)}{(\mul{c_3}{z}})}
{16}{16}
\end{center}
% Finally, we have $\mul{(c_1)}{(\mul{(c_2 * l)}{z})} \MRAC \mul{((c_1 * c_2) * c_3)}{z})$
% and $\mul{(c_1 * c_2)}{(\mul{c_3}{z}}) \MRAC \mul{(c_1 * (c_2 * c_3))}{z})$ that converge by the confluence of $\ra_\Z$.

\end{proof}

We compare two $\Z$-terms $t_1$ and $t_2$ wrt $\ACcanon$ by reifying them into their corresponding $\bb{G}$-terms, denoted $[g_1]$ and $[g_2]$, using the reification function $\reify{}$,
and normalizing them using $\twoheadrightarrow^{AC}$. Following the reduction rules specified in \cref{def:grp-rw}, we can then compare their corresponding $\Z$-terms by applying the denotation function $\den{}$.
To validate this procedure, it is necessary to establish the correctness of the following diagram, formally expressed by \cref{thm:normalization}.


\begin{theorem}[Correctness of normalization]\label{thm:normalization}
For all $\bb{G}$-terms $t$, we have $(\den{[t]}) = (\den{t})$ where $[t]$ is the AC-canonical form of $t$ with respect to $\longrightarrow^{AC}_\Sigma$.
\end{theorem}
\begin{proof}
This is a \emph{meta-level} proof, proceeding by structural induction on $t$, and the key case is the one where $t = t_1 \oplus t_2$.
We have to show that
\[
  \mathop{\den{[t_1 \oplus t_2]}} = \mathop{(\den{t_1}) + (\den{t_2})}.
\]
By the induction hypothesis, we have
$\mathop{\den{[t_1]}} = \mathop{\den{t_1}}$ and $\mathop{\den{[t_2]}} = \mathop{\den{t_2}}$.
Hence,
\[
  (\den{t_1}) + (\den{t_2})
  = (\den{[t_1]}) + (\den{[t_2]})
  = \mathop{\den{([t_1] \oplus [t_2])}}
\]
It remains to show that
$\mathop{\den{([t_1] \oplus [t_2])}} = \mathop{\den{[t_1 \oplus t_2]}}$.
Now, $[t_1]$, $[t_2]$, and $[t_1 \oplus t_2]$ are terms built solely from \tt{cst}, \tt{var}, and $\oplus$ since the remaining operators have been eliminated by applying the rules in \cref{def:grp-arith-ops}, and the terms on both sides of the equation contain the same multisets of subterms.
The two terms are therefore identified by AC-canonicalization.
\end{proof}

We make use of \cref{lem:conv} to embed $\Z$-terms into $\bb{G}$ to normalize and subsequent comparison.
In addition, we leverage this normalization process to support the \tt{arith-poly-norm} rule.

\begin{lemma}[Conversion]\label{lem:conv}
For all $x: \Z$, we have $x = (\mathop{\den{(\reify{x})}})$.
\end{lemma}
\begin{proof}
By induction on $x$. We consider the three cases: $x = \ZPos(n)$, $x = \ZNeg(n)$, and $x = \ZO$.
In each case, $\reify{(x)}$ yields the corresponding constant $\cst{x}$, and by definition of the denotation function, $x = \mathop{\den{(\cst{x})}}$.
Hence, $x = (\mathop{\den{(\reify{x})}})$ in all cases.
\end{proof}

\lstinputlisting[language=Lambdapi,mathescape=true,label={lst:inner-recon-example},caption={Lambdapi proof of List. \ref{lst:smtexampleproof}}]{Assets/short_lia.lp}

We present in List. \ref{lst:inner-recon-example} the translation of Step \tt{t2} from List. \ref{lst:smtexampleproof} using our Carcara module.
The \lstinline[language=Lambdapi,basicstyle=\ttfamily\footnotesize\upshape]|rewrite Zinv_lt_eq| step at line 3 performs the normalization from Step 1, rewriting $\neg (3 < x)$ as $\neg (\sim 3 > \sim x)$.
The lemmas \lstinline[language=Lambdapi,basicstyle=\ttfamily\footnotesize\upshape]|Z_diff_gt_Z0| and \lstinline[language=Lambdapi,basicstyle=\ttfamily\footnotesize\upshape]|Z_diff_eq_Z0_eq| (lines 4–5) implement Step 2.
Since the goal involves a $>$ inequality, Step 3 applies with the lemma \lstinline[language=Lambdapi,basicstyle=\ttfamily\footnotesize\upshape]|Zgt_le_succ_r_eq| (line 6).
The coefficients $[\frac{1}{1}, -\frac{1}{1}]$ from Step 4 are trivially cast to $\bb{Z}$ and applied in lines 7–8.
To express all inequalities uniformly, remaining equalities are rewritten as $\geq$ using \tt{Z\_eq\_implies\_ge} (line 12).
Finally, Step 6 derives the contradiction by summing inequalities from lines 13 to 17.

\section{Reflection with outer normalization}
\label{sec:outer-normalization}

We now describe the second strategy, which implements the normalization function entirely within Lambdapi.
This approach benefits from an entirely internal correctness proof, but it typically results in slower performance compared to the first strategy.
As in the first approach, an inductive type $\bb{G}$ reflects the syntactic representation of arithmetic expressions over $\Z$.

\subsection{Reflecting integers}

\renewcommand\reify[2]{ (\Uparrow #1~#2)  }
\newcommand\Cst[1]{\kw{cst}~#1}
\newcommand\Add[2]{\kw{add}~#1~#2}

\begin{notation}
We write $a[i]$ for $(\kw{nth}~0~i~a)$, i.e., the $i$-th element of the list $a$, with $0$ as default value to make the function total.
\end{notation}

% \begin{figure}[h]
\begin{definition}\label{outer-g-def}
The algebraic group $\bb{G}$ reflecting $\bb{Z}$ atoms:
\begin{align*}
& \bb{G}: \type \\
&|~\kw{var}: \N \ra \Z \ra \bb{G} \\
&|~\kw{cst}: \Z \ra \bb{G} \\[1em]
&\kw{grp}: \set \\
&\el~\kw{grp} \re \bb{G}
\end{align*}
\end{definition}

The main differences with \cref{def:G-inner} are as follows. 
First, the constructor $\kw{var}$ indexes uninterpreted terms by $\N$ rather than encapsulating them directly. 
Second, the operator $\add{}{}$ is omitted, since finite sums are represented by lists ($\List{grp}$) in order to obtain a flattened structure. 
Third, the operator $\kw{mul}$ is defined externally, so as to simplify subsequent definitions and proofs.

\begin{definition}[multiplication of coefficient]\label{outer-mul-def}
\begin{align*}
&\kw{mul} : \Z \ra \List{grp} \ra \List{grp} \\
&\kw{mul}~\_~\Box \re \Box \\
&\kw{mul}~k~(\Cst{c} \cons tl) \re \kw{mul}~(k * c)~tl \\
&\kw{mul}~k~(\var{i}{c} \cons tl) \re \var{i}{(k*c)} \cons \kw{mul}~k~tl
\end{align*}
\end{definition}

\begin{definition}[Reification function]
The \tt{reify} function:
\[
  \Uparrow : \List{int} \ra \Z \ra \el (\tlist{grp} \times \tlist{int})
\]
performs reification of arithmetic expressions from $\bb{Z}$ into the abstract type $\bb{G}$,
producing a pair consisting of a reified term of type $\bb{G}$, and a list of variable values $\tlist{int}$ called the \emph{context map} that represents uninterpreted terms in domain of $\bb{G}$ such as variable.
It is defined recursively over the structure of $\bb{Z}$ expressions:
%
\begin{align*}
&\reify{\ell}{(x + y)} \re \mathrel{let} (g_1, \ell_1) = \reify{\ell}{x}, (g_2, \ell_2) = \reify{\ell_1}{y} \\
& \qquad \mathrel{in} (g_1 \concat g_2, \ell_2) \\
&\reify{\ell}{(-x)} \re \mathrel{let} (g, \ell') = \reify{\ell}{x} \mathrel{in} (\opp(g), \ell') \\
&\reify{\ell}{(x - y)} \re \reify{\ell}{(x + (-y))} \\
&\reify{\ell}{0} \re (\Cst~0 \concat \Box, l) \\
&\reify{\ell}{(\ZPos~c)} \re (\Cst(\ZPos~c) \concat \Box, l) \\
&\reify{\ell}{(\ZNeg~c)} \re (\Cst(\ZNeg~c) \concat \Box, l) \\
&\reify{\ell}{(0 * x)} \re (\Cst~0 \concat \Box, l) \\
&\reify{\ell}{((\ZPos~c) * x)} \re \mathrel{let} (g, \ell') = \reify{\ell}{x} \mathrel{in} \\
& \qquad (\mul((\ZPos~c), g), \ell') \\
&\reify{\ell}{((\ZNeg~c) * x)} \re \mathrel{let} (g, \ell') = \reify{\ell}{x} \mathrel{in} \\
& \qquad (\mul((\ZNeg~c), g), \ell') \\
&\reify{\ell}{(x * (\ZPos~c))} \re \mathrel{let} (g, \ell') = \reify{\ell}{x} \mathrel{in} \\
& \qquad (\mul((\ZPos~c), g), \ell') \\
&\reify{\ell}{(x * (\ZNeg~c))} \re \mathrel{let} (g, \ell') = \reify{\ell}{x} \mathrel{in} \\
& \qquad (\mul((\ZNeg~c), g), \ell') \\
&\reify{\ell}{x} \re
  \begin{cases}
    (\Var{i}{1} \concat \Box, \ell) & \text{if } x \text{ is } \ell[i] \\
    (\Var{\kw{size}(\ell)}{1} \concat \Box, \ell \concat [x]) & \text{otherwise}
  \end{cases}
\end{align*}
\end{definition}

\begin{definition}[Denotation function]
The function: 
\[
  \den{}: \el (\tlist{grp} \times \bb{L}~\kw{int}) \ra \Z 
\]
defines the semantic interpretation of reified arithmetic expressions of type $\bb{G}$.
\begin{align*}
&\den{\Box} \re 0 \\
&\den{(h \cons tl, \ell)} \re \den_\bb{G}{(h, \ell)} \,+ \den{(tl, \ell)} \\
& \text{with} \\
&\den_\bb{G}: \el (\kw{grp} \times \bb{L}~\kw{int}) \ra \Z\\
&\den_\bb{G}{(\Cst(k), \ell)} \re k \\
&\den_\bb{G}{(\Var{i}{k} \concat \Box, \ell)} \re \ell[i] * k \\
\end{align*}
%
\end{definition}


\begin{example}
Consider the arithmetic expression $x + y + x + 1$, where $x$ and $y$ are $\Z$ variables.
When reifying this expression, we start with an empty context $\Box$ and apply the $\reify{}$ function recursively.
\begin{equation*}
\reify{\Box}{(x + y + x + 1)} \re^*
(
  \add{
    \mathsf{Var}~0~1}
    {
      \add{\mathsf{Var}~1~1}
      \add{\mathsf{Var}~0~1}{\cst{1}}
    }
  ),\
  [x, y]
)
\end{equation*}

The final context map $\ell = [x, y]$, so that $x$ has index $0$ and $y$ has index $1$.

\end{example}

\subsection{Outer normalisation procedure}

In this definition of merge sort algorithm, we reuse the split function defined in \cref{ssec:contraction-recon}.

\begin{definition}[Merge]
The function $\kw{merge}$ combines two lists of group elements:
\[
\kw{merge} : \tlist{\kw{grp}} \times \tlist{\kw{grp}} \;\ra\; \tlist{\kw{grp}}.
\]
It proceeds by structural recursion:
\begin{align*}
&\kw{merge}~\Box~\Box \re \Box \\
&\kw{merge}~\Box~\ell_2 \re \ell_2 \\
&\kw{merge}~\ell_1~\Box \re \ell_1 \\
&\kw{merge}~(\Cst(c_1)\cons \ell_1')~(\Cst(c_2)\cons \ell_2') \re\\
&\qquad \Cst(c_1+c_2) \cons \kw{merge}~(\ell_1', \ell_2') \\
&\kw{merge}~(\Cst(c)\cons \ell_1')~(\var{i}{k}\cons \ell_2') \re\\
&\qquad \Cst(c)\cons \kw{merge}~(\ell_1', \var{i}{k}\cons \ell_2') \\
&\kw{merge}~(\var{i}{k}\cons \ell_1')~(\Cst(c)\cons \ell_2') \re\\
&\qquad \Cst(c)\cons \kw{merge}~(\var{i}{k}\cons \ell_1', \ell_2') \\
&\kw{merge}~(\var{i}{k_1}\cons \ell_1', \var{j}{k_2}\cons \ell_2') \re\\
&\qquad \begin{cases}
\var{i}{(k_1+k_2)}\cons \kw{merge}~(\ell_1', \ell_2') & \text{if } i=j,\\
\var{i}{k_1}\cons \kw{merge}~(\ell_1', \var{j}{k_2}\cons \ell_2') & \text{if } i<j,\\
\var{j}{k_2}\cons \kw{merge}~(\var{i}{k_1}\cons \ell_1', \ell_2') & \text{if } i>j.
\end{cases}
\end{align*}
\end{definition}


\begin{definition}[Mergesort]
The sorting function $\kw{mergesort}$ is defined by recursion:
\begin{align*}
&\kw{mergesort}~\Box \re \Box, \\
&\kw{mergesort}~(x\cons \Box) \re x\cons \Box, \\
&\kw{mergesort}~(x\cons y \cons \ell) \re \\
& \kw{let} (l_1, l_2) \coloneq \kw{split}~\ell~\kw{in} \\
& \qquad  \kw{merge}\big(\kw{mergesort}~l_1, \kw{mergesort}~l_2\big).
\end{align*}
\end{definition}

% \begin{definition}[Maximum Variable]
% The function $\kw{varmax}$ extracts the maximal variable index of a list:
% \begin{align*}
% &\kw{varmax}~\Box \re 0, \\
% &\kw{varmax}~(\Cst{c} \cons \ell) \re \kw{varmax}(\ell), \\
% &\kw{varmax}~(\Var{i}{k} \cons \ell) \re \max(i,\kw{varmax}(\ell)).
% \end{align*}
% \end{definition}

Normalization will consist of converting a $\tlist{grp}$ expression into a canonical form through a composition of functions:

\begin{definition}[normalisation function]\label{def:norm-outer-grp}
Given $x: \tlist{grp}$,
\begin{equation*}
\mathop{\mathtt{norm}} x \is \mathop{\mathtt{remove0}}~(\mathop{\mathtt{mergesort}} x)
\end{equation*}
\end{definition}

\subsection{Correctness of Reified Normalization}

Several helper lemmas establish the soundness of the normalization pipeline, by verifying that each transformation step preserves the semantic interpretation of the term.
In the following, we omit the proof modality symbol $\prf$ to simplify the notation.

We first establish the correctness of the auxiliary operations that will be used in the
normalization procedure. These lemmas ensure that splitting, merging, and removing
trivial elements preserve the denotational semantics.

\begin{lemma}[Concatenation preserves denotation]\label{lem:concat-den}
For all lists $x,y$ of \kw{grp} and all environments $\ell$, we have
\[
\Downarrow(x \concat y,\; \ell) \;=\; \Downarrow(x,\ell) + \Downarrow(y,\ell).
\]
\begin{proof}
Direct by induction on the structure of $x$.
\end{proof}
\end{lemma}

\begin{lemma}[Split correctness]\label{lem:split-correct}
For all $\ell$ and $gs$, given $\kw{split}~gs = (gs_1, gs_2)$, we have
\[
\Downarrow((gs_1 \concat gs_2, \ell) = (\Downarrow~gs~\ell).
\]
\emph{Proof.} By two-step induction on the structure of $gs$.  
\begin{itemize}
\item (Case $gs = \Box$ or singletons), are immediate by definition of $\kw{split}$.  
\item (Case $gs = a\cons b \cons tl$), it is immediate by the induction hypothesis and \cref{lem:concat-den}.  
\end{itemize}
\end{lemma}

The merge function combines two already-sorted lists of $\bb{G}$ elements. The following
lemma states that it behaves extensionally like addition of the corresponding denotations.

\begin{lemma}[Merge correctness]\label{lem:merge-correct}
For all $\ell, g_1, g_2$, we have
\[
\Downarrow(\kw{merge}~g_1~g_2, \ell) \;=\; \Downarrow(g_1, \ell) + \Downarrow(g_2,\ell).
\]
\begin{proof}
By induction on $g_1$.  
\begin{itemize}
\item If $g_1=\Box$, the result follows trivially.  
\item If $g_1$ starts with a constant, use the recursive rule and induction hypothesis.  
\item If $g_1$ begins with a variable of the form $\var{i}{k_i}$, we proceed by case analysis on the structure of $g_2$. 
In the situation where both $g_1$ and $g_2$ begin with variables, say $\var{i}{k_i}$ and $\var{j}{k_j}$ respectively, 
we distinguish cases according to the comparison between the indices $i$ and $j$, and establish the desired equality 
in each branch.
\end{itemize}
\end{proof}
\end{lemma}

To show that mergesort terminates because we defined it as a general recursive function, and is well-behaved, we need to control the size of the sublists obtained by splitting.
The following lemma provides the necessary bound.

\begin{lemma}[Size bound for split]\label{lem:size-split2}
For all lists $\ell$, with $\kw{split}~\ell = (\ell_1, \ell_2)$, we have:
\[
  (\kw{size}~\ell_1) \text{ and } (\kw{size}~\ell_2) \leq \kw{size}(\ell)
\]
\begin{proof}
By induction on $\ell$, using the definition of $\kw{split}$ and the monotonicity of $\kw{size}$.
\end{proof}
\end{lemma}

We can now combine the above invariants to show that mergesort preserves
denotations. The auxiliary version carries an explicit size bound for induction.

\begin{lemma}[Correctness of mergesort]\label{lem:mergesort-correct-aux}
For all $n, \ell, g$, if $\kw{size}(g)\leq n$, then
\[
\Downarrow(\kw{mergesort}~g, \ell) \;=\; \Downarrow(g,\ell).
\]
\begin{proof}
By induction on $n$.  
\begin{itemize}
\item[] (Case $n = 0$), we then have $\kw{size}(g)=0$, then $g=\Box$ and thus $\kw{mergesort}~g = \Box$,  so $\Downarrow(\kw{mergesort}~\Box,\ell) = \Downarrow(\Box,\ell)$ holds directly.
\item[] (Case $n > 0$), with the definition of $\kw{mergesort}$ and $\kw{split}$, apply the induction hypothesis to both sublists with the bounds given by \cref{lem:size-split2}, and combine using \cref{lem:merge-correct} and \cref{lem:split-correct}.  
\end{itemize}
\end{proof}
\end{lemma}

Next, we show that eliminating trivial constants and variables with zero coefficient
does not change the denotation.

\begin{lemma}[Removal of zeros]\label{lem:remove0-correct}
For all context $\ell$ and sum $gs$, we have
\[
\Downarrow(\kw{remove0}~gs, \ell) \;=\; \Downarrow(gs,\ell).
\]
\begin{proof}
We proceed by induction on the list $gs$.  
In the inductive step where $gs = x \cons tl$, we perform a case analysis on the head element of $gs$:  
\begin{itemize}
\item[] (Case $x = \Cst{c}$), if $c=0$, the element is removed and the result follows by the induction hypothesis. 
If $c \neq 0$, the head is preserved and the induction hypothesis applies to the tail.  
\item[] (Case $x = \Var{i}{k}$), if $k=0$, the element is removed and the result follows by the induction hypothesis.  
If $k \neq 0$, the head is preserved and the induction hypothesis applies to the tail.  
\end{itemize}
In all cases, the denotation is preserved, hence the lemma holds.
\end{proof}
\end{lemma}

Finally, we can combine mergesort and zero-removal into a single normalization
procedure. The following theorem states that normalization preserves denotation.

\begin{theorem}[Correctness of normalization]\label{thm:norm-correct}
For all lists $x$ and $\ell$,
\[
  \Downarrow(\kw{norm}~x, \ell) \,=\, \Downarrow(x,\ell),
\]
\begin{proof}
Combine \cref{lem:remove0-correct} and \cref{lem:mergesort-correct-aux} with a structural induction on $x$.
\end{proof}
\end{theorem}


\begin{example}[Application of outer normalisation]\label{ex:outer-recon-example}
The normalisation of inequalities of steps 1-4 from $\kw{la\_generic}$ algorithm is done simmilarly than \cref{lst:inner-recon-example}.

We conclude this section by establishing the correctness of the reification procedure and an example of reconstruction of \kw{lia\_generic}.
Reification is designed so that evaluating the syntactic representation it produces
recovers the original integer expression.

\begin{theorem}[Correctness of reification]\label{thm:reify-correct}
For all integers $x$ and all environments $\ell$, if
\[
\reify(x) \;=\; (g, \ell') \text{ then } \Downarrow(g, \ell') \;=\; x.
\]
\begin{proof} The proof is direct by induction on $x$ where the cases will be $\ZPos, \ZNeg, \ZO$. \end{proof}
\end{theorem}


\lstinputlisting[language=Lambdapi,mathescape=true,caption={LIA reconstruction example},label={lst:ex-lia-recon}]{Assets/outer_lia.lp}

To conclude the proof using reflection, both $l$ and $r$ are reified using the $\reify{}$ function at line 20-21, yielding a pair consisting of a syntactic term and a list of variable values.
The correctness of this reification step is ensured by the \cref{thm:reify-correct} (\texttt{reify\_correct}).
The lemma \texttt{eta\_prod} expresses the $\eta$ equivalence principle for dependent pairs. It states that any pair $x : a \times b$ is equal to the pair formed by projecting its first and second components.
This principle allows one to destruct a pair syntactically into its components while preserving definitional equality.
In the context of reification, where a reified expression is represented as a pair $(t, \ell)$ of a $\bb{G}$-term and a context map, \texttt{eta\_prod} is used to explicitly access the components of the result of $\reify{x}$.
Hence we can apply the \cref{thm:norm-correct} (\texttt{norm\_correct}) at line 26.
The final inequality is then reduced to a comparison between the normalized syntactic forms of $l$ and $r$, using the theorem \texttt{norm\_correct}, which guarantees that normalization preserves semantic equivalence.
This enables the proof to conclude by purely syntactic comparison of the normalized forms, reducing $\den{[\reify{l}]} \geq \den{[\reify{r}]}$ to a contradiction.
\end{example}

\section{Reconstruction of Linear Real Arithmetic}
\label{sec:bv-reconstruction}

The reflective reconstruction for Linear Real Arithmetic (\textbf{LRA}) follows verbatim the integer case of the previous section (\cref{sec:outer-normalization}).
We only change the ground domain from $\Z$ to $\Q$ defined at (\cref{ssec:encoding-la}), and adapt the typing of lists and constants accordingly.
All definitions(\emph{reify}, denotation $\Downarrow$, $\kw{merge}$, $\kw{mergesort}$, $\kw{remove0}$, and
$\kw{norm}$) and all proofs/lemmas carry over \emph{mutatis mutandis}, relying on the same
algebraic laws (associativity, commutativity, and distributivity) which hold in the group
$\Q$ just as they do in the group $\Z$.

\begin{definition}[Real reflection signature]
We replace the integer reflection carrier by its rational counterpart:
\begin{align*}
& \bb{G}_\bb{R}: \type \\
&|~\kw{var}: \N \ra \Q \ra \bb{G}_\bb{R} \\
&|~\kw{cst}: \Q \ra \bb{G}_\bb{R} \\
&\kw{rgrp}: \set\\
&\el~\kw{rgrp} \re \bb{G}_\bb{R}
\end{align*}
We continue to write $\ell[i]$ for $(\kw{nth}~\frac{0}{1}~i~\ell)$, now with $\ell : \bb{L}~\kw{rat}$ and
default $\frac{0}{1} \in \Q$ to make indexing total.
\end{definition}

\paragraph{Reification and denotation.}
The function $\Uparrow_\Q : \bb{L}~\kw{rat} \ra \Q \ra \el(\tlist{grp} \times \tlist{rat})$
is obtained from the integer version by replacing integer constants and coefficients
with rationals $0 \rightsquigarrow \frac{0}{1}$. The denotation $\Downarrow_\Q : \el(\tlist{grp} \times \bb{L}~\kw{rat}) \ra \Q$
is unchanged apart from types: $\Cst(q)$ evaluates to $q \in \Q$ and
$\Var{i}{q}$ evaluates to $\ell[i] *_\Q q$ for $\ell :\bb{L}~\kw{rat}$.

\paragraph{Normalization pipeline.}
The operators $\kw{mul} : \Q \ra \List{grp} \ra \List{grp}$,
$\kw{merge}$, $\kw{mergesort}$, and $\kw{remove0}$ are identical to the integer case,
with coefficients and constants in $\Q$ and the environment of type $\bb{L}~\kw{rat}$.
The normalization function remains
\[
\kw{norm}~x \;\is\; \kw{remove0}\big(\kw{mergesort}~x\big).
\]

\paragraph{Correctness results.}
All statements and proofs from \cref{sec:outer-normalization} transfer:
\begin{itemize}
\item $\Downarrow_\Q(\kw{merge}~g_1~g_2,\ell)=\Downarrow_\Q(g_1,\ell) \;+_\Q \Downarrow_\Q(g_2,\ell)$,
\item $\Downarrow_\Q(\kw{mergesort}~g,\ell)=\Downarrow_\Q(g,\ell)$,
\item $\Downarrow_\Q(\kw{remove0}~g,\ell)=\Downarrow_\Q(g,\ell)$,
\item $\Downarrow_\Q(\kw{norm}~x,\ell)=\Downarrow_\Q(x,\ell)$,
\item and \emph{reification correctness}:
      if $\Uparrow(\ell,x)=(g,\ell')$ then $\Downarrow_\Q(g,\ell')=x$.
\end{itemize}
No new lemmas are required: each proof is the same by type instantiation
$\Z \rightsquigarrow \Q$ and $\bb{L}~\kw{int} \rightsquigarrow \bb{L}~\kw{rat}$.

