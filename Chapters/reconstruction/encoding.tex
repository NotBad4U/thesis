
%*****************************************
\chapter{Encoding the logic of SMT in Lambdapi} \label{ch:encoding}
%*****************************************

We describe our embedding of the logic of SMT and Alethe into Lambdapi.
Our work applies to input problems expressed in the logics \texttt{UF}, \texttt{LIA} and \texttt{BV} or their sub-logics.
We begin by detailing the encoding of the SMT-LIB sorts used in these logics, which is necessary for reconstructing their corresponding Alethe proofs.
We then present our method for translating these proofs.

\section{A Prelude Encoding for Alethe}
\label{sec:encoding-prelude}

\begin{definition}[Prelude Encoding]
\label{def:defuniv}
The signature $\Sigma$ of our encoding contains the following definitions and rewrite rules that we use to encode Alethe proofs:
\begin{align*}
&\set\index{\set}: \type & &\prop\index{\prop}: \type \\
&\index{\el{}} \el{}: \set \rightarrow \type  & &\index{\prf}\prf{} : \prop \rightarrow \type \\
&\mathop{\leadsto}\index{$\leadsto$}: \set \rightarrow \set \rightarrow \set \quad \text{(infix)} & &o: \set \\
&\el\,(x \leadsto y) \hookrightarrow \el\,x \rightarrow \el\,y & &\el\,o\index{o}  \hookrightarrow \prop
\end{align*}
\end{definition}

The notions of term, proposition, and proof are not primitive in \lpm.
We ﬁrst deﬁne a notion analogous to the predicate logic notion of term, to express the objects the theory speaks about, such as the natural number.
The constants \set{} and \prop{} in \cref{def:defuniv} are type universes ``à la Tarski'' \cite[\S Universes]{intuitype} in \lpm.
The type \set{} represents the universe of \textit{small types}, i.e.\ a subclass of types for which we can define equality.
SMT sorts are represented in \lpm{} as elements of type \set{}. Since elements of type \set{} are not types themselves, 
we also introduce a function $\el: \set \rightarrow \type$ that embeds the terms of type \set{} into terms of type \type.
Therefore, our function \el{} interprets SMT sorts as \type.
Thus, we represent the terms of sort \lstinline[language=SMT,basicstyle=\ttfamily\normalsize]|Bool| of SMT by elements of type $\el{}\,o$.
The constructor $\leadsto$ (written infix) is used to encode SMT functions and predicates.

Jus as \lpm{} does not contain a primitive notion for expressing the objects of the theory, it does not contain a primitive notion of proposition.
The constant \prop{} represents the universe of propositions. Predicate symbols are represented as constants of type $\set{} \ra \dots \ra \prop$ .
Similar to \set{}, elements of type \prop{} are not types themselves; they are mapped to types by the function $\prf{}: \prop \rightarrow \type$.
Drawing an analogy with the Curry-de-Brujin-Howard isomorphism \cite{curryhoward}, this function embeds propositions into types by mapping each proposition $A$ to the type $\prf\,A$, which represents its proofs.
However, the analogy is only partial in two important ways. First, the propositions themselves are not the types of their proofs: if $t$ is a proof of $A$, then it does not have the type $A$,
but the type $\prf\,A$. Second, the embedding is not surjective—meaning not all types correspond to proofs. For instance, neither \set{} nor \prop{} are themselves types of proofs. 

Consequently, a \emph{step} in an Alethe proof trace is represented as an inhabitants of type $\prf{}\,p$, for a suitable proposition $p$.

\section{Constructive connectives, quantifiers and classical facts}
\label{ssec:encoding-prop}

Given that SMT solvers operate under classical logic, we employ the constructive connectives and quantifiers,
while explicitly introducing the classical principles of the Law of the Excluded Middle and propositional extensionality.

\begin{definition}[Constructive connectives, quantifiers]
\begin{align}
& \top : \prop \\
& \bot : \prop \\
& \land : \prop \ra \prop \ra \prop \qquad \text{(written inﬁx)} \\
& \lor : \prop \ra \prop \ra \prop \qquad \text{(written inﬁx)} \\
& \Rightarrow : \prop \ra \prop \ra \prop \qquad \text{(written inﬁx)} \\
&  \prf (a \Rightarrow\,b) \re \prf a \ra \prf b \label{eq:imp}\\
& \neg a \is a \Rightarrow \bot \\
% & \mathop{\mathrm{xor}}~a~b \is (\neg a \land b) \lor (a \land \neg b) \\
& \forall : \Pi {[a: \set]}, (\el\, a \ra \prop) \ra \prop \label{eq:forall}\\
& \prf{}(\forall\,p) \re \Pi x, \prf{(p~x)}\\
& \exists : \Pi {[a: \set]}, (\el\, a \ra \prop) \ra \prop \\
& {=} : \Pi [a : \set], \el\, a \ra \el\, a \ra \prop \qquad \text{(written inﬁx)} \\
& \epsilon: \Pi {[a: \set]}, (\el\,a \ra \prop) \ra \el\,a \\
% & \epsilon_i: \Pi {[a: \set]}, \Pi (x : \el\,a), \Pi (P : \el\,a \ra \prop) \\
% & \quad \ra \prf P\,x \ra \prf P\,(\epsilon\,P) \\
% & \epsilon_{d}: \Pi {[a: \set]}, \Pi (P\,Q : \el\,a \ra \prop) \\
% & \quad \ra \Pi x : \el\,a, \prf (P\,x = Q\,x) \ra (\epsilon \, P = \epsilon \, Q)
\end{align}
\end{definition}

According to the Curry-de Bruijn-Howard correspondence, a proof of $A \Rightarrow B$ should have the type $\prf (A \Rightarrow B)$.
However, such a proof actually has type $\prf\,A \ra \prf\,B$. This means that the types $\prf (A \Rightarrow B)$ and $\prf\,A \ra \prf\,B$ must be identiﬁed.
To achieve this, we introduce the rewriting rule \cref{eq:imp}, allowing $\prf (A \Rightarrow B)$ to be rewritten as $\prf\,A \ra \prf\,B$.

We cannot assign the type $\Pi : \type, (X \ra \prop) \ra \prop$ to the universal quantifier, because in \lpm{} there is no mechanism for quantifying over variables of type \type.
Instead, we assign the type $\Pi\,x:\set{},(\el\,x \ra \prop) \ra \prop$ to the generic universal quantiﬁer $(\forall)$ \cref{eq:forall}.
Thus, we will be able to quantify over SMT sorts that will be encoded as inhabit of type \set. Furthermore, the previously defined term $o: Set$, together with the rewrite rule $\el\,o\index{o}  \hookrightarrow \prop$
, enables quantification over propositions, rendering the universal quantifier impredicative.

Equality (=) over small types is parameterized over types
$\el\,a$ for the type parameter $[a : \set{}]$ (the square brackets indicate that this parameter need not be given explicitly).
We also define the choice operator $\epsilon$ (\cite[\S 2.1]{alethespec}) as illustrated above.
The intended interpretation for the $\epsilon$ operator is that $(\epsilon\,x,\, P~x)$ denotes some $x$ satisfying the predicate $P$, if there is one.
The characteristic proof rules for the $\epsilon$ operator are represented by
the constants $\epsilon_i$ for proving a predicate $P\,(\epsilon\,P)$ by exhibiting a witness $x$ such that $P\,x$ is provable,
and $\epsilon_d$ that asserts that the epsilon operator assigns the same witness to equivalent predicates $P$ and $Q$.
SMT logic enjoys the property of propositional completeness (also referred to as \emph{propositional degeneracy}) asserting that:
 \[
  \forall p,(p = \top) \lor (p = \bot) 
\]
Moreover, propositionally equivalent formulas are equal. We thus introduce the axioms in \cref{def:classical-facts}.

\begin{definition}[Classical facts]
\begin{align*}
\texttt{em}:\ & \Pi [p: \prop], \prf (p \lor \neg p) \\
\texttt{prop\_ext}:\ & \Pi [p\,q: \prop], \prf (p \Leftrightarrow q ) \rightarrow \prf (p = q)
\end{align*}
\label{def:classical-facts}
\end{definition}

\section{Representing Linear Integer Arithmetic (\textbf{LIA})}
\label{ssec:encoding-lia}

\begin{figure}
\centering
\begin{align*}\label{eq:eq1}
&\N: \type & &\bb{P}: \type & &\Z: \type \\
&|~0: \N  & &|~\tt{H} : \bb{P} & &|~\ZO: \Z \\
&|~\tt{+1}:\N \ra \N & &|~\tt{O}: \bb{P} \ra \bb{P} & &|~\ZPos: \bb{P} \ra \Z \\
& & &|~\tt{I}: \bb{P} \ra \bb{P} & &|~\ZNeg: \bb{P} \ra \Z \\
&\tt{nat}: \set & &\tt{pos}: \set & &\tt{int}: \set \\
&\el~\tt{nat} \re \N & &\el~\tt{pos} \re \bb{P} & &\el~\tt{int} \re \Z 
\end{align*}
\caption{Inductive type definitions for binary positive number, natural and integers}
\label{fig:sorts-constructors}
\end{figure}

\begin{figure}
\begin{framed}
{\footnotesize
\centering
% --- Integer Addition ---
\begin{align*}
&+: \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO + y \re y \\
& x + \ZO \re x \\
& (\tt{Zpos x}) + (\tt{Zpos y}) \re (\ZPos~(\tt{add}~x~y))  \\
& (\tt{Zpos x}) + (\tt{Zneg y}) \re (\tt{sub}~x~y)  \\
& (\tt{Zneg x}) + (\tt{Zpos y}) \re (\tt{sub}~y~x)  \\
& (\tt{Zneg x}) + (\tt{Zneg y}) \re \ZNeg~(\tt{add}~x~y)
\end{align*}
\noindent

% --- Positive Binary Arithmetic ---
\[
\begin{array}[t]{ll}
\begin{aligned}
&\tt{add} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{add}~(\tt{I}~x)~(\tt{I}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{add}~(\tt{I}~x)~(\tt{O}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{add}~(\tt{O}~x)~(\tt{I}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{add}~(\tt{O}~x)~(\tt{O}~q) \re \tt{O}~(\tt{add}~x~q) \\
& \tt{add}~x~\tt{H} \re \tt{succ}~x \\
& \tt{add}~\tt{H}~y \re \tt{succ}~y \\
\end{aligned}
&
\begin{aligned}
&\tt{mul} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{mul}~\tt{H}~y \re y \\
& \tt{mul}~y~\tt{H} \re y \\
& \tt{mul}~(\tt{O}~x)~y \re \tt{O}~(\tt{mul}~x~y) \\
& \tt{mul}~(\tt{I}~x)~y \re \\
& \quad \tt{add}~y~(\tt{O}~(\tt{mul}~x~y)) \\
\end{aligned}
\end{array}
\]
\noindent

\begin{align*}
&\tt{addc} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{addc}~(\tt{I}~x)~(\tt{I}~q) \re \tt{I}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{I}~x)~(\tt{O}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{O}~x)~(\tt{I}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{O}~x)~(\tt{O}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{addc}~x~\tt{H} \re \tt{add}~x~(\tt{O}~\tt{H}) \\
& \tt{addc}~\tt{H}~y \re \tt{add}~(\tt{O}~\tt{H})~y \\
\end{align*}
\noindent

% --- Multiplication ---
\begin{align*}
&\tt{*} : \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO *~\_ \re \ZO \\
& \_ *~\ZO \re \ZO \\
& \ZPos x *~\ZPos y \re \ZPos (\tt{mul}~x~y) \\
& \ZPos x *~\ZNeg    y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZPos y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZNeg    y \re \ZPos (\tt{mul}~x~y) \\
\end{align*}
}%
\caption{Arithmetic operations over binary positive numbers $\bb{P}$ and integers $\Z$}
\label{fig:arith-ops}
\end{framed}
\end{figure}

The definition we use of natural numbers and integers in Lambdapi in \cref{fig:sorts-constructors} follows a common encoding found in many other theories, including the one adopted in the Rocq standard library \cite{Rocq-refman}.
Natural numbers are defined inductively with the two constructors $0$ and the the successor function $+1$ written postfix.
The type $\bb{P}$  is an inductive type representing strictly positive integers in binary form.
Starting from 1 (represented by the constructor \tt{H}), one can add a new least significant digit via the constructor \tt{O} (digit 0) or the constructor \tt{I} (digit 1).
For example, we represent 5 (101b) as $\tt{I} (\tt{O} (\tt{H}))$. The type $\Z$ represents integers in binary form.
An integer is either zero (with constructor $\ZO$) or a strictly positive number $\ZPos$ (coded as a $\bb{P}$) or a strictly negative number $\ZNeg$.
We make use of Lambdapi's \lstinline[language=Lambdapi,basicstyle=\ttfamily\normalsize]|builtin| mechanism to enable decimal notation for numeric values, for instance, writing $2$ for $\ZPos (\mathop{\tt{O}} \tt{H})$.
to convert natural representations of values into elements of $\Z$.
To enable quantification over elements of these types, we introduce constants such as $\tt{int}:\set$ that represent codes for these types along with a rule for rewriting codes to their corresponding types, for example $\el~\tt{int} \re \Z$.
Arithmetic operations over these types are defined in \cref{fig:arith-ops}. This includes addition over $\Z$, denoted $(+)$, and over $\bb{P}$, denoted \texttt{add}.
These operations are implemented using rewrite rules, which necessitates proofs of both confluence and termination.
We use this encoding of integer operations for extending the embedding of Alethe proofs in Lambdapi described in \cite{ColtellacciMD24}.
In particular, the SMT sort $\textbf{Int}$ is mapped to $\el~\texttt{int}$, and the arithmetic operations of SMT to their counterparts in the Lambdapi encoding.


\begin{figure}
\begin{framed}
{\footnotesize
\centering
% --- Comparison and Integer comparison ---
\[
\begin{array}[t]{l@{\hspace{4em}}l}
\begin{aligned}
&\tt{Comp}: \type{} \\
&|~\tt{Eq}: \tt{Comp} \\
&|~\tt{Lt}: \tt{Comp} \\
&|~\tt{Gt}: \tt{Comp} \\
&\tt{comp}: \set \\
&\el{}~\tt{comp} \re \tt{Comp}
\end{aligned}
&
\begin{aligned}
&\doteq : \Z \ra \Z \ra \tt{Comp} \\
& \ZO \doteq \ZO \re \tt{Eq} \\
& \ZO \doteq \ZPos~\_ \re \tt{Lt} \\
& \ZO \doteq \ZNeg~\_ \re \tt{Gt} \\
& \ZPos~\_ \doteq \ZO \re \tt{Gt} \\
& \ZPos~p \doteq \ZPos~q \re \tt{cmp}~p~q \\
& \ZPos~\_ \doteq \ZNeg~\_ \re \tt{Gt} \\
& \ZNeg~\_ \doteq \ZO \re \tt{Lt} \\
& \ZNeg~\_ \doteq \ZPos~\_ \re \tt{Lt} \\
& \ZNeg~p \doteq \ZNeg~q \re \tt{cmp}~q~p
\end{aligned}
\\[3em]
\begin{aligned}
  &\tt{isGt} : \tt{Comp} \ra \B \\
  &\tt{isGt}~\tt{Eq} \re \tt{false} \\
  &\tt{isGt}~\tt{Lt} \re \tt{false} \\
  &\tt{isGt}~\tt{Gt} \re \tt{true}
\end{aligned}
&
\begin{aligned}
  &\tt{istrue} : \B \ra \prop \\
  &\tt{istrue}~\tt{true} \re \top \\
  &\tt{istrue}~\tt{false} \re \bot\\
  &\\
\end{aligned}
\end{array}
\]

\vspace{3em}

\[
\begin{array}{l@{\hspace{4em}}l}
\begin{aligned}
  &\tt{isEq} : \tt{Comp} \ra \B \\
  &\tt{isEq}~\tt{Eq} \re \tt{true} \\
  &\tt{isEq}~\tt{Lt} \re \tt{false} \\
  &\tt{isEq}~\tt{Gt} \re \tt{false}
\end{aligned}
&
\begin{aligned}
  &\tt{isLt} : \tt{Comp} \ra \B \\
  &\tt{isLt}~\tt{Eq} \re \tt{false} \\
  &\tt{isLt}~\tt{Lt} \re \tt{true} \\
  &\tt{isLt}~\tt{Gt} \re \tt{false}
\end{aligned}
\\[3em]
\begin{aligned}
  &\tt{isGt} : \tt{Comp} \ra \B \\
  &\tt{isGt}~\tt{Eq} \re \tt{false} \\
  &\tt{isGt}~\tt{Lt} \re \tt{false} \\
  &\tt{isGt}~\tt{Gt} \re \tt{true}
\end{aligned}
&
\begin{aligned}
  &\tt{istrue} : \B \ra \prop \\
  &\tt{istrue}~\tt{true} \re \top \\
  &\tt{istrue}~\tt{false} \re \bot\\
  &\\
\end{aligned}
\end{array}
\]
% --- Inequalities relations ---
\noindent
\begin{align*}
&\leq: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, \neg (\tt{istrue}(\tt{isGt}(x \doteq y))) \\
&<: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, (\tt{istrue}(\tt{isLt}(x \doteq y))) \\
&\geq: \Z \ra \Z \ra \prop \coloneq \lambda x,\lambda y, \neg (x < y) \\
&>: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, \neg (x \leq y)
\end{align*}
}%
\end{framed}
\caption{Definitions for inequalities over $\Z$.}
\label{fig:arith-inequalities-def}
\end{figure}

In \cref{fig:arith-inequalities-def}, we also introduce inductive types \tt{Comp} \index{\tt{Comp}} and $\B$ representing comparison operators and Booleans.
We will refer to the rewrites rules of \cref{fig:arith-ops} and \cref{fig:arith-inequalities-def} as $\ra_\Z$ and $\ra_\bb{P}$ in the following sections.
The function $\doteq : \Z \to \Z \to \texttt{Comp}$ compares two integers, relying on the auxiliary function $\texttt{cmp} : \bb{P} \to \bb{P} \to \texttt{Comp}$ to perform comparisons between strictly positive binary numbers.
Based on this comparison mechanism, we define inequality operators over $\Z$ as binary predicates, by reducing them to the decidable comparison $\doteq$. They reduce to $\top$, $\bot$ (or negated) by applying rules of $\ra_\Z$ and $\ra_\bb{P}$.
For example, $1 < 2 \hookrightarrow \tt{istrue}(\tt{isLt}(1 \doteq 2)) \hookrightarrow \tt{istrue}(\tt{isLt}(\tt{Lt})) \hookrightarrow \tt{istrue}(\tt{true}) \hookrightarrow \top$, with $1 = \mathop{\ZPos} \tt{H}$ and $2 = \mathop{\ZPos} (\mathop{\tt{O}} \tt{H})$.

\begin{lemma}[Confluence of $\ra_\bb{Z}$ and $\ra_\bb{P}$]
\begin{proof}
CSI \cite{CSI} automatically proves the confluence of $\ra_\bb{Z}$ and $\ra_\bb{P}$ by giving the polynomial interpretation:
\begin{align*}
[\tt{succ}(x)] = 4*x & &[\tt{add}(x, y)] = 4 * x + 4 * y + 2  & &[ {\tt{H}} ] = 4 \\
\end{align*}
\end{proof}
\label{lemma:confluenceZP}
\end{lemma}


\section{Representing Linear Arithmetic (\textbf{LA})}
\label{ssec:encoding-la}


% Rational numbers are formalized using a datatype called rat. This datatype is designed to represent rational numbers as fractions in their reduced form, ensuring mathematical precision and efficiency in proofs.
% The rat type is defined using a single constructor, Rat, which takes two arguments: an integer numerator and a positive integer denominator.
% The key aspect of this construction is the enforcement of the invariant that the denominator must always be positive and coprime with the numerator.
% This invariant guarantees that each rational number is represented uniquely, which simplifies comparisons and arithmetic operations.

% We define the rat type in Lambdapi is as follows:

SMT solver define the sort \smtinline{Real}, but in practice the reconstruction of Alethe proof with the logic \textbf{LA} only require the rational number (\Q) for most of the case.
In \cref{def:rat}, we follows the encoding of rational from Rocq \cite{Rocq-refman} \textsc{MathComp} library \cite{mathcomp}.
Rational numbers are represented as an inductive type with a single constructor $\kw{Rat}$, containing a pair of integers and a proof that they are coprime and that the second one is positive.
This invariant guarantees that each rational number is represented uniquely, which simplifies comparisons and arithmetic operations.

\begin{definition}[Rational]\label{def:rat}
We first define the boolean predicate of being \kw{coprime}. Two integers a and b are coprime if the only positive integer that is a divisor of both of them is $1$.
\begin{equation*}
\kw{coprime} (a~b: \el\,\kw{int}): \B \is  \kw{isEq}~(\kw{Zgcd}~|a|~|b| \doteq 1)
\end{equation*}
The function $\kw{Zgcd}$ returns the Greatest Common Divisor $(\mathop{GCD})$ between two terms of type $\Z$, and $|\_|$ is the absolute value function.
We then defines the inductive type:
\begin{align*}
& \Q: \type \\
& |~\kw{Rat}: \Pi\,[a~b: \el\,\kw{int}],\\
& \quad \prf\, (\kw{istrue} (\kw{isLt} (0 \doteq b) \mathbin{and} \kw{coprime}\,a\,b)) \ra \Q \\[1em]
&\kw{rat}: \set{} \\
&\el~\kw{rat} \re \Q
\end{align*}
\end{definition}

In the Following, we will use the notation $\frac{n}{d}$ to denotes a fractional pair of integers.


\begin{example}
We can define $\frac{0}{1}$ as $(\kw{Rat}~0~1~\top_i)$ since:
\[
\prf\, \kw{istrue} (\kw{isLt} (0 \doteq 1) \mathbin{and} \kw{coprime}\,0\,1) \equivL \prf \top 
\]
with $\top_i : \prf\,\top$.
\end{example}

This \emph{canonical representation} ensures uniqueness of representation (no two different pairs represent the same rational) and yields a decidable equality.
Next, we will define a constructor function that will compute reduced fraction from a pair of integers.
We first define the product type in \cref{def-product}, with the constant $\times: \set \ra \set \ra \set$.

\begin{definition}[Product type]\label{def-product}
\begin{align*}
&\textbf{Non dependent product type:} \\
&\quad \times : \text{Set} \to \text{Set} \to \text{Set} \quad \textit{(written infix)} \\
&\textbf{Pairing symbol:} \\
&(\mathbin{‚}) [a~b] : \el a \ra \el b \ra \el (a \times b)\\[1em]
&\textbf{Projections (written postfix):}  \\
&\quad {}_1 : \el\, (a \times b) \ra \el\, a \quad \text{with rewrite rule } (x \mathbin{‚} \_)_1 \re x \\
&\quad {}_2 : \el\, (a \times b) \ra \el\, b \quad \text{with rewrite rule } (\_ \mathbin{‚} y)_2 \re y
\end{align*}
\end{definition}

The pairing constructor is denoted by $(‚)$ (a comma-like symbol), which takes two terms $x : \el\,a$ and $y : \el\, b$ and produces a term $x \mathbin{‚} y : \el (a \times b)$.
Two projection symbols ${\_}_1$ and ${\_}_2$ extract the first and second components of a pair, respectively.

The constructor function $\kw{fracq}$, in \cref{def:fracq-def}, normalizes any integer pair to its reduced form and a proof that the invariant holds, so if two inputs represent the same rational number, 
the function $\kw{fracq}$ returns exactly the same $\Q$ value (with identical numerator/denominator and proof) e.g. $\kw{fracq} (2,4) \equivL \kw{fracq} (3,6)$.

\question{ac}{Should I go so much into details or just mention fracq without giving its def?}
\begin{definition}[fracq constructor]\label{def:fracq-def}
\begin{align*}
& \kw{fracq} : \Z \ra \Z \ra \Q \\
& \kw{fracq}~\_~Z0 \re \kw{Rat}~0~1~(\kw{fracq\_subproof}~1~0) \\
& \kw{fracq}~n~d \re \mathop{let} r \is \kw{fracq\_subdef}~(n, d)~\mathbin{in}\\
& \qquad \qquad \kw{Rat}~r_1~r_2~(\kw{fracq\_subproof}~n~d) \\
\end{align*}
The implementation involves several helper functions and lemmas:
\begin{align*}
&\kw{fracq\_subproof} (x~y : \el~int): \\
& \quad \mathop{let} p \is (\kw{fracq\_subdef}~x~y)~ \mathbin{in}\\
& \qquad \prf (\kw{istrue} (\kw{isLt} (0 \doteq p\,{}_2) \mathbin{and} \kw{coprime}\,p\,{}_1\,p\,{}_2)) \\
&\text{and}\\
& \kw{fracq\_subdef} (x : \el (\kw{int} \times \kw{int})): \el (\kw{int} \times \kw{int}) \\
& \kw{fracq\_subdef}~(x, y) \re\\
& \quad \kw{if}~(\kw{isLt} (0 \doteq y) \mathbin{and} \kw{coprime}\,x\,y)\\
& \quad \mathop{then}~(x,y) \\
& \quad \mathop{else}~\mathop{if}~(y \neq 0)~\mathop{then} \\
& \qquad \mathop{let}~g \is \kw{Zgcd}(x,y)~ \mathbin{in}  \\
& \qquad\qquad (-1^{(IsLt0(x) + IsLt0(y)))} * \mathop{div}~|x|~g‚ \mathop{div}~|y|~g) \\
& \qquad \mathop{else}~(0,1) \\
\end{align*}
Where
\begin{itemize}
\item $\kw{fracq\_subproof}$ :  A lemma proving that the result of:\\
  $\kw{fracq\_subdef}$ satisfies the required invariant,
\item $\kw{fracq\_subdef}$ : A helper function that computes the fractional part of a pair of integers.
It returns a positive denominator, and a sign encoded in the numerator. If the numerator is zero, the pair is replaced by $(0, 1)$.
Following the approach of \textsc{MathComp}, we imposes a computational normalization convention: whenever an invalid pair $(n, 0)$ is encountered, it is systematically mapped to a default rational $\frac{0}{1}$.
This ensures the normalization operation is total, deterministic, and easily computable without special case-handling downstream.

\item $\kw{IsLt0}: \Z \ra \Z$, a function that return $1$ if the argument is lower than $0$, and $0$ otherwise.
\end{itemize}
\end{definition}

Finally, we can then define the regular arithmetic operator over $\Q$ by using the $\kw{fracq}$ function.
For example, we define the addition $+_\Q$ symbol as follows:

\begin{align*}
&+_\Q : \Q \ra \Q \ra \Q \quad (\textit{written infix})\\ 
&(\kw{Rat}~n_1~d_1~\_) +_\Q (\kw{Rat}~n_2~d_2~\_) \re\\
&\qquad \kw{fracq}~(n_1 *_\Z d_2 +_\Z n_2 *_\Z d_1) (d_1 *_\Z d_2) \\
\end{align*}


\section{Encoding bitvectors (\textbf{BV})}
\label{ssec:encoding-bv}

\begin{figure}
\begin{framed}
%************ Dependent pair **********************
% [a: Set] (p: τ a → Prop) inductive Σ : TYPE ≔
%     exist (x: τ a) : π (p x) → Σ p;
% symbol Sigma [a: Set]: (τ a → Prop) → Set;
% rule τ (Sigma $p)  ↪ Σ $p;
%*************************************************
\begin{align*}
&\Sigma : \forall a : \set{}, (\el{}~a \ra \prop): \type \\
&|~exist : \Pi (a : \set{}), \prf (p~x) \ra \Sigma~p \\
&\\
& Sigma~[a: \set{}]: (\el{}~a \ra \prop) \ra \set{} \\
& \el{}~Sigma~p \re \Sigma~p \\
&\\
& \textcolor{red}{s_1}~[a: \set{}] [p:(\el{}~a \ra \prop)] (e: \Sigma~a~p): \el{}~a \\
& (exist~x~\_)~\textcolor{red}{s_1} \re x\\
& s_2~[a: \set{}] [p:(\el{}~a \ra \prop)] (e: \Sigma~a~p): \prf{}(p~(e~\textcolor{red}{s_1})) \\
& (exist~x~p)~s_2 \re p\\
\end{align*}

%************ bitvector ***************************
% injective symbol Fin (n: ℕ) ≔ Σ (λ x, istrue (x < n));
% injective symbol FinMk (n: ℕ) (m: ℕ) (isLT : π (m < n)): Fin n
%  ≔ @exist nat (λ x, istrue (x < n)) m isLT;
% symbol fin: ℕ →  Set;
% rule τ (fin $n) ↪ Fin $n;

% injective symbol BitVec n ≔ Fin (2 ^ n);
% symbol mkBv n v p : BitVec n  ≔ FinMk (2 ^ n) v p;
%*************************************************
\begin{align*}
& Fin~(n: \N) \coloneq \Sigma~(\lambda\,x, istrue(x < n)) \\
& FinMk~(n: \N) (m: \N) (islt: \prf (m < n)) : Fin~n \\
&\quad\is exist~(\lambda\,x, istrue(x <n))~m~islt\\
&\mathop{val}~[n]: \mathop{Fin} n \ra \N \is \lambda e, e~s\_1 \\
&\mathop{isLt}~[n] (f: \mathop{Fin} n): \prf (f~s_1 < n) \is f~s_2\\
&\\
& \hat{}: \N \ra \N \ra \N \qquad \text{(written inﬁx)}\\
& 0 ~\hat{}~ 1 \re 1 \N\\
& n ~\hat{}~ (m + 1) \re n * (n ~\hat{}~ m)\\
&\\
&BitVec~n \is Fin~(2~\hat{}~n) \\ 
& mkBv: \Pi(n: \N)(p: \prf~(istrue(n < 2~\hat{}~n))): BitVec~n\\
&\quad\is FinMk~(2~\hat{}~n)~n~p\\
&\\
&\mathop{to\_nat}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathbb{N} \\
&\,\mathop{to\_nat}\;n\;(\mathop{exist}(v,\_))\re v
\end{align*}
\end{framed}
\caption{Encoding bitvectors}
\label{fig:bitvector-def}
\end{figure}

We interpret the sort of bitvectors $\mathop{BitVec}(w: \N)$ \index{$\mathop{BitVec}$} from the SMT logic \textbf{BV} as a number less than $2^w$  because we use the type $\mathop{Fin}$ as the internal representation of a bitvector as depicted in \cref{fig:bitvector-def}.
In particular, a $\mathop{Fin} n$ is the type of natural numbers $i$ with the constraint that $i < n$. It is the canonical type with $n$ elements. In \cref{fig:bitvector-def}, we provide the definitions of $\mathop{Fin}$
which is a dependent pair type i.e. Sigma type ($\Sigma$), the definition of $\mathop{Fin} n$ and $\mathop{Bitvector} n$.

Alternative representations could include a vector of \B{},
formally $\mathop{BitVec}(w: \mathbb{N}) := \Sigma(\mathop{List\,\B})(\lambda(l: \mathop{List\,\B}),\mathop{length}l = w)$,
or a binary natural number encoding: $\mathop{BitVec}(w: \mathbb{N}) := \Sigma\,(\mathop{Bin\N})(\lambda (n:\mathop{Bin\N}), \mathop{size}\,n = w)$, where $\mathop{Bin\N}$
is an inductive type representing binary natural numbers greater than zero, built on top of $\mathbb{N}$.
However, like $\mathop{Fin}$, these structures are not currently available in Lambdapi's standard library.

We chose the $\mathop{Fin}$ representation over other possible encodings due to its relative efficiency.
If, in the future, Lambdapi's kernel adds support for efficient representations of natural numbers e.g.,
via overriding them with arbitrary-precision arithmetic libraries like GMP\footnote{\url{https://gmplib.org/}} bitvectors encoded with $\mathop{Fin}$ would likewise benefit from such optimizations.

We therefore chose to implement $\mathop{Fin}\,n$, as we believe it provides the most suitable and future-proof foundation for representing the $\mathop{BitVec}$ type,
particularly in light of potential enhancements to the kernel.


We recall that the constructor for bitvector in Alethe: $$\mathtt{bbT}\ \enum[n-1]{x}[][0]$$ with $x_i\in\{\bot,\top\}$, for $0\leq i< n$,
is the Boolean equivalent of the $i$-th bit of $x$ (from least to most significant). Thus $\enum[n-1]{x}[][0]$ is the Boolean bit-level interpretation corresponding to the bit-vector. 

\begin{example}[Bitvector construction]
The binary number $\#b0010$ is equivalent to:

\begin{lstlisting}[language=SMT]
(@bbT false true false false)
\end{lstlisting}
\end{example}

Because we encode \smtinline{Bool} terms as $\prop$, a list $\enum[n-1]{x}[][0]$ with $x_i \in {\bot, \top}$ is represented as a list of $\prop$ rather than elements of type $\mathbb{B}$.
To ensure that such a list is well-formed, we require a predicate that guarantees $x_i \in {\bot, \top}$ for each element.

\begin{lemma}[@bbT well-formed]
For any Boolean list $l : \mathbb{L}\,o$, if every element of $l$ is either $\top$ or $\bot$, then there exists a corresponding bitvector of $\mathop{size} l$ constructed by $\mathop{@bbT}$.
\label{lem:bbt}
\end{lemma}

We first define the function $\mathop{list2Nat}$, which computes the natural number corresponding to $\enum[n-1]{x}[][0]$
with $x_i \in {\bot, \top}$, and the function $\mathop{All}$, which defines a predicate requiring all elements of the list to satisfy a given property.
Briefly, the constructor $\Box$ of type $(\bb{L}\,a)$ represent the empty list of element of type $a$ that belongs to \set, and the constructor $x\,::\,xs$ add an element $(x: \el{} a)$ to a list $xs: \bb{L}a$.

\begin{definition}[bbT helper functions]
\begin{align*}
&\mathop{list2Nat}(\top \,::\, xs) \ra 2 * (\mathop{list2Nat}\,xs) + 1 \\
&\mathop{list2Nat}(\bot \,::\, xs) \ra 2 * (\mathop{list2Nat}\,xs) \\
&\mathop{list2Nat}(\Box) \ra 0
\end{align*}

\begin{align*}
&\mathop{All}\;p\;\Box \;\rightarrow\; \top \\
&\mathop{All}\;p\;(x \,\::\, l) \;\rightarrow\; (p\;x) \land \mathop{All}\;p\;l
\end{align*}
\end{definition}

Therefore, we can represent \cref{lem:bbt} as the constant given in \cref{def:eqbbt}.
To construct a bitvector from a list of \smtinline{Bool}, we must provide a proof that the list is well-formed.

\begin{definition}[Bitvector auxiliary constructor]
\begin{align*}
&\mathop{bbT}\,(l : \bb{L}\,o) : \prf (\mathop{All}\,(\lambda x.\; x = \top \lor x = \bot)\,l)\\
&\quad \ra \mathop{BitVec}(\mathop{size}\,l)
\end{align*}
\label{def:eqbbt}
\end{definition}


\subsection{Arithmetic}

The SMT-LIB language offers arithmetic operations on bitvectors, such as $\mathop{bvadd}$ and $\mathop{bvadd}$. 
Some of these operations are signed, while others are unsigned. In the implementation, bitvectors are represented as a wrapper around a Fin type with an appropriate bound.
Since $\mathop{Fin}$ itself wraps a natural number (\N), bitvector operations rely on corresponding functions and proofs defined over \N.

\begin{definition}[Bitvector arithmetic]
\begin{align*}
&\mathop{bvsub}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{sub}(2^n, x, y) \\
&\mathop{bvmul}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{mul}(2^n, x, y) \\
&\mathop{bvshiftl}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{shiftl}(2^n, x, y) \\
&\mathop{bvshiftr}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{shiftr}(2^n, x, y) \\
&\mathop{bvand}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{and}(2^n, x, y) \\
&\mathop{bvor}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{or}(2^n, x, y)
\end{align*}
\end{definition}


\subsection{Bitwise Operators}


SMT-LIB define bitwise operators such as $\mathop{bvand}$ or $\mathop{bvlshr}$  (which shifts a bitvector to the right) for manipulating the individual bits of one or more bitvectors. 
 Following a similar strategy, we encoded these operations over \N and wrap the bitvector operations on them. To illustrate this approach, we focus on the $\mathop{bvand}$ operator.
We begin by defining its natural number analogue, $\mathop{land}$ with its correctness \cref{lem:correct-land}.

\begin{definition}[and operator for Nat]
We define a higher-order function \( \mathop{\mathrm{bitwise}} : (\mathbb{B} \ra \mathbb{B} \ra \mathbb{B}) \ra \mathbb{N} \ra \mathbb{N} \ra \mathbb{N} \ra \mathbb{N} \) by the following rewrite rules:
\begin{align*}
&\mathop{\mathrm{bitwise}}\,op\, 0\, a\, b \re 0 \\
&\mathop{\mathrm{bitwise}}\,op\, n{+}1\, a\, b \re \\
&\quad\left( \text{if } (\mathop{op}\,(\mathop{\mathrm{odd}}a)\, (\mathop{\mathrm{odd}}\,b)) 1\,0 \right) \\
&\quad+ 2 * \mathop{\mathrm{bitwise}}\,op\, n\, (\mathop{\mathrm{div2}}\,a)\,(\mathop{\mathrm{div2}}\,b)
\end{align*}
The auxiliaries functions \( \mathop{\mathrm{div2}} : \mathbb{N} \ra \mathbb{N} \) and the boolean \( \mathop{\mathrm{and}_\B} : \B \ra \B \ra \B \) are defined recursively as:
\begin{align*}
&\mathop{\mathrm{div2}}\,0 \re 0 \\
&\mathop{\mathrm{div2}}\,1 \re 0 \\
&\mathop{\mathrm{div2}}\,x{+}2 \re \mathop{\mathrm{div2}}\,x + 1 \\
&\\
&\mathop{\mathrm{and}_\B}(\mathrm{true},\, b) \re b \\
&\mathop{\mathrm{and}_\B}(b,\, \mathrm{true}) \re b \\
&\mathop{\mathrm{and}_\B}(\mathrm{false},\, \_) \re \mathrm{false} \\
&\mathop{\mathrm{and}_\B}(\_,\, \mathrm{false}) \re \mathrm{false}
\end{align*}
Then, we can define the natural number bolean and i.e. (\&\&) as:
\begin{equation*}
\&\&~(a\,b: \N): \N \is \mathop{bitwise}\,(and_\B)\,a\,a\,b \quad \text{(written infix)}
\end{equation*}
\end{definition}


\begin{lemma}[Correctness of Bitwise \&\&]
Let $n, m, i \in \N$. Then the $i$-th bit of the bitwise $\mathbin{\&\&}$ of $n$ and $m$ equals the conjunction of the $i$-th bits of $n$ and $m$, that is:
\[
\mathop{testbit} (n \mathbin{\&\&} m)~i = \mathop{andb}~(\mathop{testbit} n~i) (\mathop{testbit} m~i).
\]
with:
\begin{align*}
&\mathop{\mathrm{testbit}} : \N \ra \N \ra \B \\
&\mathop{\mathrm{testbit}}\,a,\,0 \re \mathop{\mathrm{odd}}\,a \\
&\mathop{\mathrm{testbit}}\,a,\,n{+}1 \re \mathop{\mathrm{testbit}}\,\mathop{\mathrm{div2}}(a),\, n
\end{align*}
\begin{proof}TODO\end{proof}
\label{lem:correct-land}
\end{lemma}

\begin{lemma}[Bitwise $\mathbin{\&\&}$ upper bound]
Let \( x, y, n : \N \), and suppose \( y < 2 \,\hat{}\, n \). Then:
\[
x \mathbin{\&\&} y < 2^n.
\]
\label{and_lt_two_pow}
\begin{proof} TODO \end{proof}
\end{lemma}

Representing Linear ArithmeticFinally, we can define the $\mathop{bvand}$ function.

\begin{definition}[Bitwise \emph{and} for bitvectors]
\begin{align*}
&\mathop{\mathrm{Fin.and}}~[n: \N]: \mathop{Fin} n \ra \mathop{Fin} n \ra \mathop{Fin} n\\
&\quad\is \lambda f1,\, \lambda f2,\, \mathop{\mathrm{FinMk}}~n~((\mathop{val} f1) \mathbin{\&\&} (\mathop{val} f2)) \\
&\quad (\mathop{and\_lt\_two\_pow}~(\mathop{val} f1)~(\mathop{val} f2)~n~(\mathop{isLt} f2)) \\
&\\
&\mathop{\mathrm{bvand}}~[n: \N]: \mathop{BitVec} n \ra \mathop{BitVec} n \ra \mathop{BitVec} n\\
&\quad\is \lambda x, \lambda y, \mathop{Fin.and}~(2~\hat{}~n)~x~y
\end{align*}
with $\mathop{and\_lt\_two\_pow}$ the constant for \cref{and_lt_two_pow}.
\end{definition}

\section{SMT-LIB helper operators distinct and ite}
\label{ssec:encoding-distinct-let-enc}

The SMT-LIB provides the operator \smtinline{(par (A) (distinct A A Bool :pairwise))}  denotes the function that
returns true iff its two arguments are not identical, and \smtinline{(par (A) (ite Bool A A A))} denotes the function that
returns its second argument or its third depending on whether its first argument is true or not.


\begin{definition}[Vectors and Distinctness Predicate encoding]
Let \( a : \mathop{\mathrm{Set}} \). We define the constant \( \mathop{\mathrm{Vec}}(a, n) \) inductively for \( n \in \N \) as:
\begin{align*}
&[a: \set] \mathop{\mathrm{Vec}}: \N \ra \type \\
&|\Box_\bb{V} : \mathop{\mathrm{Vec}}\,a\, 0 \\
&|\mathbin{::}_\bb{V}\,[n:\N]: \el\,a \ra \mathop{\mathrm{Vec}}\,a\,n \ra  \mathop{\mathrm{Vec}}\,a\,(n{+}1) \quad (\text{infix}) \\
\end{align*}

\begin{align*}
&\mathop{\mathrm{vector}}~(a: \set): \set \\
&\el (\mathop{\mathrm{vector}} a) \re \type
\end{align*}

We chose Vector because the \kw{distinct\_elim} rule in Alethe \cite[(Rule 93)]{alethespec} behaves differently depending on the size and the sort of terms.
We define the predicate \( \mathop{\mathrm{distinct}}: \Pi a,\, \Pi n \in \N,\, (\mathop{\mathrm{Vec}}\,a\,n) \ra \prop \) using the following rules:
\begin{align*}
&\mathop{\mathrm{distinct}}~\Box_\bb{V} \re \bot \\
&\mathop{\mathrm{distinct}}~(\_ \mathbin{::}_\bb{V} \Box_\bb{V}) \re \top \\
&\mathop{\mathrm{distinct}}~(x \mathbin{::}_\bb{V} y \mathbin{::}_\bb{V}  \Box_\bb{V}) \re \neg (x = y) \\
&\mathop{\mathrm{distinct}}~(\_ \mathbin{::}_\bb{V} \_ \mathbin{::}_\bb{V} \_ \mathbin{::}_\bb{V} \_)))) \re \bot
\end{align*}
\end{definition}

\begin{example}
\(
    \mathop{\mathrm{distinct}}~(1 \mathbin{::}_\bb{V} 2 \mathbin{::}_\bb{V} 3 \mathbin{::}_\bb{V} \Box_\bb{V}) \re \bot
\)
and
\(
    \mathop{\mathrm{distinct}}~(\top \mathbin{::}_\bb{V} \bot \mathbin{::}_\bb{V} \Box_\bb{V}) \re \neg (\top = \bot).
\)
\end{example}

\begin{definition}[\texttt{ite}]
Let \( a: \set \) be a \set. We define a conditional expression:
\begin{align*}
\mathop{\mathrm{ite}} : \Pi [a: \set],\, \el\,o \ra \el\,a \ra \el\,a \ra \el\,a
\end{align*}

We also define the dependent eliminator:
\begin{align*}
&\mathop{\mathrm{ite\_ind}} : \Pi [a],\, \Pi (c : \el\,o)\, (t\, e : \el\,a)\, (p : \el\,a \ra \mathrm{Prop})\\
&\quad\left( \prf\,c \ra \prf(p~t) \right) \ra \\
&\quad\left( (\prf\,c \ra \prf\,\bot) \ra \prf(p~e) \right) \ra \\
&\quad\prf(p~(\mathop{\mathrm{ite}}~c~t~e)))
\end{align*}
\end{definition}

\section{Encoding clauses}

Alethe distinguishes between clauses that appear in steps, such as \colorbox{green!30}{(cl~$l_1 \dots l_n$)} in \cref{eq:step}, and ordinary disjunction \cite[\S 4]{alethespec}.
The syntax for clauses uses the \textcolor{purple}{\texttt{cl}} operator, while disjunction is represented as the standard SMT-LIB \textcolor{purple}{\texttt{or}}.
Alethe identifies clause as a set of literals. As mentioned in \cref{ch:alethe}, Alethe identifies clauses that differ only in the order of literals. In particular, note that the ``literals'' appearing in clauses may actually be arbitrary formulas in Alethe.
It provides the \kw{or} rule for converting disjunctions into clauses:
\[
\begin{matrix*}[l]
  i. & \triangleright & \varphi_1 \lor \dots \lor \varphi_n  & (\dots) \\
  j. & \triangleright & (\texttt{\textcolor{purple}{cl}}~\varphi_1 \dots \varphi_n)  & (\kw{or}~i)[] \\
\end{matrix*}
\]

\begin{remark}[Lack of Structural Canonical Form in Disjunctive Clauses]
Interpreting a clause as a disjunction, we obtain a concatenated form such as $cl~(l_1~l_2~l_3~l_4)$ will be then translated into $l_1 \lor (l_2 \lor (l_3 \lor l_4))$.
 Therefore, the concatenation of two clauses (what is happening in the conclusion of \texttt{resolution}) need not unify with the translated clause of the step. For example, taking 3 arbitrary steps:

\begin{itemize}
    \setlength{\itemsep}{5pt}
    \setlength{\parskip}{0pt}
    \item[] $A.~\triangleright~(\text{cl}~\textcolor{purple}{x_1}, \textcolor{blue}{x_2, x_3}) \quad (..)[..]$
    \item[] $B.~\triangleright~ (\text{cl}~\textcolor{orange}{y_2}, \textcolor{purple}{\neg x_1}, \quad \textcolor{orange}{y_3}) (..)[..]$
    \item[] $C.~\triangleright~(\text{cl}~\textcolor{blue}{x_2, x_3}, \textcolor{orange}{y_2, y_3}) \quad (\texttt{resolution A B})[(\textcolor{purple}{x_1}~\texttt{true})]$  % Maybe the argument could be removed but it makes an echo with Carcara elaborated proof
\end{itemize}

Interpreting a clause as a disjunction, we obtain a concatenated form such as $((\textcolor{blue}{x_2} \lor \textcolor{blue}{x_3}) \lor (\textcolor{orange}{y_2} \lor \textcolor{orange}{y_3}))$.
This aligns with the classical formulation of the \texttt{resolution} inference rule, expressed as $x \lor Y;\ \neg x \lor Z \vdash Y \lor Z$.
However, in {\lpm} $((\textcolor{blue}{x_2} \lor \textcolor{blue}{x_3}) \lor (\textcolor{orange}{y_2} \lor \textcolor{orange}{y_3})) \nequiv_{\beta\Sigma} (\textcolor{blue}{x_2} \lor (\textcolor{blue}{x_3} \lor (\textcolor{orange}{y_2} \lor \textcolor{orange}{y_3})))
\nequiv_{\beta\Sigma} (((\textcolor{blue}{x_2} \lor \textcolor{blue}{x_3}) \lor \textcolor{orange}{y_2}) \lor \textcolor{orange}{y_3})$ , even though these forms are semantically identical.

Additionally, in step \emph{B}, the pivot \textcolor{purple}{$\neg x_1$} does not occur at the head of the clause, contrary to the expectation of the resolution rule,
which requires the pivot to be in the leading position. As a result, resolving clauses requires reasoning modulo associativity and commutativity.
To address the associativity issue, we propose a canonical representation for clauses.

Accordingly, in \cref{fig:encoding-clause}, we define the type $\kw{Clause}$ to represent an Alethe clause as a list of propositions, thereby ensuring a canonical form.
The constructor $\veedot$ prepends an element to a list, and $\nil$ denotes the empty list. The operator $\pp$ is used to concatenate lists. 
Clauses are logically interpreted as disjunctions via the function $\cal{F}$, defined through rewriting rules. For convenience, we also introduce the predicate $\pid$, which asserts the provability of a clause.
\end{remark}

\begin{figure}
  \begin{align*}
  &\texttt{Clause}: \type \\
  &\nil: \texttt{Clause} \\
  &\veedot: \prop \ra \texttt{Clause}  \ra \texttt{Clause} \\
  & \pp: \texttt{Clause} \ra \texttt{Clause} \ra \texttt{Clause} \\
  & \nil \mathop{\pp} x \re x \\
  & (x \veedot y) \mathop{\pp} z \re x \veedot (y \mathop{\pp} z) \\
  & \cal{F}: \texttt{Clause} \ra \prop \\
  & \cal{F}~\nil \re \bot\\
  & \cal{F}~x \veedot y \re x \lor (\cal{F}~y)\\
  & \pid (c : \texttt{Clause}) \coloneqq \prf (\cal{F}~c)
  \end{align*}
  \caption{The \texttt{Clause} type and operations on clauses.}
  \label{fig:encoding-clause}
\end{figure}

We can now prove the equivalence between clause and disjunction.

\begin{lemma}[Clause elimination]\label{lemma:clause-elim}
For any $p \colon \prop$ and $q,r \colon \texttt{Clause}$, If $\pid (p \veedot q)$ and $(\pid (p \veedot \nil) \ra  \pid r)$ and $(\pid q \ra  \pid r)$ then $\pid r$.
\end{lemma}
\begin{proof}
Since the hypothesis $\pid (p \veedot q)$ is equivalent to $\prf (p \lor \cal{F}\,q)$, we apply the classic disjunction elimination rule.
Then we can conclude $\prf p \ra \prf (\cal{F}\,r)$ wih the hypothesis $\pid (p \veedot \nil) \ra  \pid r$, and we can conclude $\prf (\cal{F}\,q) \ra \prf (\cal{F}\,r)$
with the hypothesis $\pid q \ra  \pid r$.
\end{proof}

\smallskip

\begin{lemma}[Concatenation is disjunction]\label{lemma:clause-equiv-disj}
For any two clauses $a\,b$, the equivalence $\prf (\cal{F}(a~\pp~b)) \Leftrightarrow \prf (\cal{F}\,a \lor \cal{F}\,b)$ holds.
\end{lemma}
\begin{proof} By induction on $a$.
  \begin{itemize}
    \item For the base case $a = \nil$ we must show that
    \[
        \prf\, (\cal{F} (\nil\, \pp \, b)) \Leftrightarrow \prf\, (\cal{F}\,\nil \lor \cal{F}\,b)
    \]
    The implication ``$\Rightarrow$'' is trivial because $\nil\,\pp\,b$ rewrites to $b$. The implication ``$\Leftarrow$'' is proved using the standard elimination rule $\lor_e$ for disjunction, which requires proving $\prf\,(\cal{F}\,\nil) \ra \prf\,(\cal{F}\,(\nil\,\pp\,b))$ as well as $\prf\,(\cal{F}\,b) \ra \prf\,(\cal{F}\,(\nil\,\pp\,b))$. Both proofs are immediate since $\cal{F}\,\nil$ rewrites to $\bot$ and $\nil\,\pp\,b$ rewrites to $b$.
    \item For the case $a = h \veedot tl$ we may use the induction hypothesis $\prf\,(\cal{F}\, (tl\, \pp\, b)) \Leftrightarrow \prf\,(\cal{F}\,tl \lor \cal{F}\, b)$. The conclusion is then easy to prove based on the rewriting rules for the operators $\cal{F}$ and $\pp$, together with associativity of $\lor$.
    \end{itemize}
\end{proof}
