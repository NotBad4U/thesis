
%*****************************************
\chapter{Encoding the logic of SMT in Lambdapi} \label{ch:encoding}
%*****************************************

We describe our embedding of the logic of SMT and Alethe into Lambdapi.
Our work applies to input problems expressed in the logics \texttt{UF}, \texttt{LIA}/\texttt{LA} or their sub-logics.
We begin by detailing the encoding of the SMT-LIB sorts used in these logics, which is necessary for reconstructing their corresponding Alethe proofs.
We then present our method for translating these proofs.

\section{A Prelude Encoding for Alethe}
\label{sec:encoding-prelude}

We base our following definitions on the prelude presented in \cref{sec:prelude-lp}.
We represent user-declared SMT sorts in \lpm{} as elements of type \set{}. We represent the terms of sort \lstinline[language=SMT,basicstyle=\ttfamily\normalsize]|Bool| of SMT by elements of type $\el{}\,o$.
The constructor $\leadsto$ (written infix) is used to encode SMT functions and predicates.
Since Alethe extends the SMT format with the \smtinline{choice} operator (\cite[\S 2.1]{alethespec}), we add it to the prelude. 
% Thus, we will be able to quantify over SMT sorts that will be encoded as inhabit of type \set. 

\begin{definition} \label{def:eps}
We define the choice operator named $\epsilon$.
\begin{align}
& \epsilon \index{$\epsilon$}: \Pi\, {[a: \set]}, (\el\,a \ra \prop) \ra \el\,a \\
& \epsilon_i \index{$\epsilon_i$}: \Pi\, {[a: \set]}, \Pi (x : \el\,a), \Pi (P : \el\,a \ra \prop) \\
& \quad \ra \prf\,(P\,x) \ra \prf\, P\,(\epsilon\,P)  \notag\\
& \epsilon_{d} \index{$\epsilon_d$}: \Pi\, {[a: \set]}, \Pi (P\,Q : \el\,a \ra \prop) \\
& \quad \ra \Pi\, x : \el\,a, \prf\,(P\,x = Q\,x) \ra (\epsilon \, P = \epsilon \, Q)  \notag
\end{align}
The intended interpretation for the $\epsilon$ operator is that $(\epsilon\,x,\, P~x)$ denotes some $x$ satisfying the predicate $P$, if there is one.
The characteristic proof rules for the $\epsilon$ operator are represented by the constants $\epsilon_i$ for proving a predicate $P\,(\epsilon\,P)$ by exhibiting a witness $x$ such that $P\,x$ is provable,
and $\epsilon_d$ that asserts that the epsilon operator assigns the same witness to equivalent predicates $P$ and $Q$.
\end{definition}


Overall, this corresponds to a shallow embedding, where the logical connectives in SMT are directly represented by their counterparts in Lambdapi.
SMT logic enjoys the property of propositional completeness (also referred to as \emph{propositional degeneracy}) asserting that:
 \[
  \forall p,(p = \top) \lor (p = \bot)
\]
Moreover, propositionally equivalent formulas are equal.

In order to interface with SMT solvers—whose reasoning are based on classical logic,
we extend our system with the law of excluded middle and propositional extensionality as an additional axioms.


\begin{definition}[Classical facts]
We introduce the classical axioms:
\begin{align*}
\tt{em} \index{$\tt{em}$}:\ & \Pi\, [p: \prop], \prf\,(p \lor \neg p) \\
\tt{prop\_ext} \index{$\tt{prop\_ext}$}:\ & \Pi\, [p\,q: \prop], \prf\,(p \Leftrightarrow q ) \rightarrow \prf\,(p = q)
\end{align*}
\label{def:classical-facts}
\end{definition}

\section{Representing Linear Integer Arithmetic (\textbf{\uppercase{LIA}})}
\label{ssec:encoding-lia}

\begin{definition}[Encoding integers]\label{def:ints}
The definition we use of natural numbers and integers in Lambdapi follows a common encoding found in many other theories, including the one in the Rocq standard library \cite{Rocq-refman}.

\begin{align*}\label{eq:eq1}
&\N: \type & &\bb{P}\index{$\bb{P}$}: \type & &\Z\index{$\bb{Z}$}: \type \\
&|~0: \N  & &|~\tt{H}\index{$\tt{H}$} : \bb{P} & &|~\ZO\index{$\ZO$}: \Z \\
&|~+\!1:\N \ra \N & &|~\tt{O}\index{$\tt{O}$}: \bb{P} \ra \bb{P} & &|~\ZPos\index{$\ZPos$}: \bb{P} \ra \Z \\
& & &|~\tt{I}\index{$\tt{I}$}: \bb{P} \ra \bb{P} & &|~\ZNeg\index{$\ZNeg$}: \bb{P} \ra \Z \\
&\tt{nat}\index{$\tt{nat}$}: \set & &\tt{pos}\index{$\tt{pos}$}: \set & &\tt{int}\index{$\tt{int}$}: \set \\
&\el~\tt{nat} \re \N & &\el~\tt{pos} \re \bb{P} & &\el~\tt{int} \re \Z
\end{align*}

Natural numbers are defined inductively with the two constructors $0$ and the the successor function $+\!1$ written postfix.
The type $\bb{P}$  is an inductive type representing strictly positive integers in binary form.
Starting from $1$ (represented by the constructor \tt{H}), one can add a new least significant digit via the constructor \tt{O} (digit 0) or the constructor \tt{I} (digit 1).
For example, we represent 5 (101b) as $\tt{I} (\tt{O} (\tt{H}))$. The type $\Z$ represents integers in binary form.
An integer is either zero (with constructor $\ZO$) or a strictly positive number $\ZPos$ (coded as a $\bb{P}$) or a strictly negative number $\ZNeg$.
To enable quantification over elements of these types, we introduce constants such as $\tt{int}:\set$ that represent codes for these types along with a rule for rewriting codes to their corresponding types, for example $\el~\tt{int} \re \Z$.
\end{definition}

We make use of Lambdapi's \lstinline[language=Lambdapi,basicstyle=\ttfamily\normalsize]|builtin| mechanism to enable decimal notation for numeric values, for instance, writing $2$ for $\ZPos (\mathop{\tt{O}} \tt{H})$ to convert natural representations of values into elements of $\Z$.

\begin{definition}[$\Z$ operators]\label{def:arith-ops}
Arithmetic operations over these types are implemented using rewrite rules, which necessitates proofs of both confluence and termination.
We provide only the definitions of $(+)$ and $(*)$ over $\Z$:

\begin{align*}
&+: \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO +\, y \re y \\
& x + \ZO \re x \\
& (\tt{Zpos x}) + (\tt{Zpos y}) \re (\ZPos~(\tt{add}~x~y))  \\
& (\tt{Zpos x}) + (\tt{Zneg y}) \re (\tt{sub}~x~y)  \\
& (\tt{Zneg x}) + (\tt{Zpos y}) \re (\tt{sub}~y~x)  \\
& (\tt{Zneg x}) + (\tt{Zneg y}) \re \ZNeg~(\tt{add}~x~y)\\[1em]
&\tt{*} : \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO *~\_ \re \ZO \\
& \_ *~\ZO \re \ZO \\
& \ZPos x *~\ZPos y \re \ZPos (\tt{mul}~x~y) \\
& \ZPos x *~\ZNeg    y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZPos y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZNeg    y \re \ZPos (\tt{mul}~x~y) \\
\end{align*}
The definition of the auxiliaries functions $\kw{add}, \kw{sub}$ and $\kw{mul}$ can be found in \cref{app:arith-def}.
\end{definition}

\begin{notation}
We will use the notation $+_\Z$ or $*_\Z$ to refer the operators defined in \cref{def:arith-ops} when the context needs to be specified.
\end{notation}

\begin{definition}[Inequality operators for integer]\label{def:arith-inequalities-def}
We introduce inductive types \tt{Comp} \index{$\tt{Comp}$} and $\B$ representing comparison operators and Booleans.
\begin{align*}
&\tt{Comp}: \type{} & &\B: \type{} \\
&|~\tt{Eq}: \tt{Comp} & &|~\tt{true}: \B \\
&|~\tt{Lt}: \tt{Comp} & &|~\tt{false}: \B \\
&|~\tt{Gt}: \tt{Comp} & & \\
&\tt{comp}: \set & &\tt{bool}: \set  \\
&\el{}~\tt{comp}\index{$\tt{comp}$} \re \tt{Comp} & &\el{}~\tt{bool} \re \B
\end{align*}

The type $\B$ is a simple inductive type with two constructors to represent binary value and providing an induction principle, while the type {\prop} represent the universe of propositions without an induction principle.

The function $\doteq$ below compares two integers, relying on the auxiliary function $\texttt{cmp}$ (defined in \cref{def:cmp-pos}) to perform comparisons between strictly positive binary numbers.

% --- Comparison and Integer comparison ---
\[
\begin{array}[t]{l@{\hspace{4em}}l}
\begin{aligned}
&\doteq\index{$\doteq$} : \Z \ra \Z \ra \tt{Comp} \\
& \ZO \doteq \ZO \re \tt{Eq} \\
& \ZO \doteq \ZPos~\_ \re \tt{Lt} \\
& \ZO \doteq \ZNeg~\_ \re \tt{Gt} \\
& \ZPos~\_ \doteq \ZO \re \tt{Gt} \\
& \ZPos~p \doteq \ZPos~q \re \tt{cmp}~p~q \\
& \ZPos~\_ \doteq \ZNeg~\_ \re \tt{Gt} \\
& \ZNeg~\_ \doteq \ZO \re \tt{Lt} \\
& \ZNeg~\_ \doteq \ZPos~\_ \re \tt{Lt} \\
& \ZNeg~p \doteq \ZNeg~q \re \tt{cmp}~q~p
\end{aligned}
\\[3em]
\begin{aligned}
  &\tt{isGt} : \tt{Comp} \ra \B \\
  &\tt{isGt}~\tt{Eq} \re \tt{false} \\
  &\tt{isGt}~\tt{Lt} \re \tt{false} \\
  &\tt{isGt}~\tt{Gt} \re \tt{true}
\end{aligned}
\end{array}
\]

Based on this comparison mechanism, we define inequality operators over $\Z$ as binary predicates, by reducing them to the decidable comparison $\doteq$. They reduce to $\top$, $\bot$ (or negated).

\[
\begin{array}{l@{\hspace{4em}}l}
\begin{aligned}
  &\tt{isEq} : \tt{Comp} \ra \B \\
  &\tt{isEq}~\tt{Eq} \re \tt{true} \\
  &\tt{isEq}~\tt{Lt} \re \tt{false} \\
  &\tt{isEq}~\tt{Gt} \re \tt{false}
\end{aligned}
&
\begin{aligned}
  &\tt{isLt} : \tt{Comp} \ra \B \\
  &\tt{isLt}~\tt{Eq} \re \tt{false} \\
  &\tt{isLt}~\tt{Lt} \re \tt{true} \\
  &\tt{isLt}~\tt{Gt} \re \tt{false}
\end{aligned}
\\[3em]
\begin{aligned}
  &\tt{isGt} : \tt{Comp} \ra \B \\
  &\tt{isGt}~\tt{Eq} \re \tt{false} \\
  &\tt{isGt}~\tt{Lt} \re \tt{false} \\
  &\tt{isGt}~\tt{Gt} \re \tt{true}
\end{aligned}
&
\begin{aligned}
  &\tt{istrue} : \B \ra \prop \\
  &\tt{istrue}~\tt{true} \re \top \\
  &\tt{istrue}~\tt{false} \re \bot\\
  &\\
\end{aligned}
\end{array}
\]
% --- Inequalities relations ---
\noindent
\begin{align*}
&\leq: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, \neg (\tt{istrue}(\tt{isGt}(x \doteq y))) \\
&<: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, (\tt{istrue}(\tt{isLt}(x \doteq y))) \\
&\geq: \Z \ra \Z \ra \prop \coloneq \lambda x,\lambda y, \neg (x < y) \\
&>: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, \neg (x \leq y)
\end{align*}
% }%
\end{definition}

\begin{example}[Inequality reduction]
For example,
\begin{align*}
  1 < 2
  &\ \re\ \tt{istrue}(\tt{isLt}(1 \doteq 2)) \\
  &\ \re\ \tt{istrue}(\tt{isLt}(\tt{Lt})) \\
  &\ \re\ \tt{istrue}(\tt{true}) \\
  &\ \re\ \top,
\end{align*}
with $1 = \ZPos~\tt{H}$ and $2 = \ZPos~(\tt{O}~\tt{H})$.
\end{example}

The SMT sort \smtinline{Int} is mapped to $\el~\texttt{int}$, and the arithmetic operations of SMT to their counterparts in the Lambdapi encoding.

\begin{notation}
We will refer to the rewrite rules of \cref{def:arith-ops} and \cref{def:arith-inequalities-def} as $\ra_\Z$ \index{$\ra_\Z$} and $\ra_\bb{P}$ \index{$\ra_\bb{P}$} in the following sections.
\end{notation}

\begin{lemma}[Confluence of $\ra_\bb{Z}$ and $\ra_\bb{P}$]
\begin{proof}
CSI \cite{CSI} automatically proves the confluence of $\ra_\bb{Z}$ and $\ra_\bb{P}$.
% by giving the polynomial interpretation:
% \begin{align*}
% [\tt{succ}(x)] = 4*x & &[\tt{add}(x, y)] = 4 * x + 4 * y + 2  & &[ {\tt{H}} ] = 4 \\
% \end{align*}
\end{proof}
\label{lemma:confluenceZP}
\end{lemma}

\section{Representing Linear Arithmetic (\uppercase{\textbf{LA})}}
\label{ssec:encoding-la}

SMT solvers define the sort \smtinline{Real}, but in practice the reconstruction of Alethe proof with the logic \uppercase{\textbf{LA}} only requires the rational number (\Q).
SMT solvers involve Real number in non-linear arithmetic logics such as \uppercase{\textbf{NRA}}, since rationals alone are insufficient because solutions may require algebraic numbers (roots of polynomials, e.g., $\sqrt{2}$) or even transcendental numbers (e.g., $\pi, e$).
Our encoding of rationals (\cref{def:rat}) adapts the approach from~\cite{frac-rw}, which employs a balanced ternary numeral system
\footnote{Balanced ternary is a ternary numeral system (i.e. base $3$ with three digits) that uses a balanced signed digit representation of the integers in which the digits have the values $-1$, $0$, and $1$.}
to define integers and rationals.
This representation ensures convergence (modulo AC for addition/multiplication), unique normal forms, and efficient reduction—minimizing the number of steps required to reach normal form.
However, we replace the ternary encoding with our binary integer representation (\cref{sec:encoding-helper-operator}).
Our encoding of rational numbers is still a work in progress.
While core properties, such as normalization and basic arithmetic operations have been formalized, certain lemmas including the associativity of addition and multiplication, are currently accepted and remain to be proven.

\begin{definition}[Rational]\label{def:rat}
We define the type of rational numbers and some operators as follows:
\begin{align*}
& \Q \index{$\Q$}: \type            & &\kw{frac} \index{$\kw{frac}$}: \Z \ra \Z \ra \Q \\
& \kw{rat} \index{$\kw{rat}$}: \set       & &\slash \index{$\slash$}: \Z \ra \Z \ra \Q \quad \text{(infix)} \\
& \el\,\kw{rat} \re \Q & &+_\Q : \Q \ra \Q \ra \Q \quad \text{(infix)}\\
&                      & &*_\Q : \Q \ra \Q \ra \Q \quad \text{(infix)}\\
\end{align*}
The symbol \kw{frac} denotes any fraction, while $\slash$ denotes irreducible fractions.
Since the SMT-LIB standard (\cref{ssec:smt-la}) allows denominators to be zero, we use $\Z$ instead of $\bb{P}$ but normalize such cases via rewrite rules.
\end{definition}

The Mathematical Components library \textsc{MathComp} \cite{mathcomp}  in Rocq \cite{Rocq-refman}, and the mathlib library \cite{mathlib} in Lean \cite{lean4:2021} encode rational numbers as pairs of integers reduced by their greatest common divisor (GCD), accompanied by a proof certifying their coprimality and the positivity of the denominator.
This invariant ensures a canonical representation of each rational number, which simplifies comparisons and arithmetic operations.

In contrast, our approach exploits Lambdapi’s rewrite rules to define normalization rules that automatically yield a canonical form for rational numbers, obviating the need for explicit proofs of the invariant.
Consequently, our construction consists solely of a pair of integers, eliminating the overhead of carrying invariant proof, unlike the MathComp library’s design.

A well-known method for reducing a rational number $\frac{x}{y}$ to its normal form is to divide both $x$ and $y$ by their GCD.
We avoid this due to two complications:
\begin{enumerate}
\item Introducing a division operator (risking division-by-zero errors)
\item Implementing GCD computation separately.
\end{enumerate}
Instead, we introduce $\mathop{rgcd}$  in \cref{def:frac}, which simultaneously computes the GCD and divides the inputs by exploiting J. Stein's algorithm \cite{knuth}, an efficient division-free method adapted to binary representations.

\begin{definition}[irreducible fractions]\label{def:frac}
The auxiliary operator $\mathop{stein}$ implements for positive binary integers ($\bb{P}$) the logic to compute the GCD and divide the first parameter ($x$ in $\mathop{rgcd}~x~y$), while $\mathop{rgcd}$ extends it to $\Z$ by handling signs:
\begin{align*}
&\kw{frac}~x~y \re ((\mathop{sign}~y) * \mathop{rgcd}~x~y) \slash ((\mathop{sign}~y) * \mathop{rgcd}~y~x) \\[1em]
& \mathop{stein}: \bb{P} \ra \bb{P} \ra \bb{P} \\
& \mathop{stein}~H~\_ \;\re\; H \\
& \mathop{stein}~a~H \;\re\; a \\
& \mathop{stein}~(\kw{O}~a)~(\kw{O}~b) 
   \;\re\; \mathop{stein}~a~b \\
& \mathop{stein}~(\kw{O}~a)~(\kw{I}~b) 
   \;\re\; \kw{O}~(\mathop{stein}~a~(\kw{I}~b)) \\
& \mathop{stein}~(\kw{I}~a)~(\kw{O}~b) 
   \;\re\; \mathop{stein}~(\kw{I}~a)~b \\
& \mathop{stein}~(\kw{I}~a)~(\kw{I}~b) \\
&   \;\re\; \begin{cases}
       H & a = b \\
       \mathop{stein}~(\kw{I}~a)~(\kw{sub}~(\kw{I}~b)~(\kw{I}~a)) & a < b \\
       \mathop{stein}~(\kw{I}~a)~(\kw{sub}~(\kw{I}~a)~(\kw{I}~b)) &  a > b
     \end{cases} \\[1em]
& \mathop{rgcd}: \Z \ra \Z \ra \Z \\
& \mathop{rgcd}~\kw{Z0}~\_ \;\re\; \kw{Z0} \\
& \mathop{rgcd}~a~\kw{Z0} \;\re\; \kw{sign}~a \\
& \mathop{rgcd}~(\kw{Zpos}~a)~(\kw{Zpos}~b) 
  \;\re\; \kw{Zpos}~(\mathop{stein}~a~b) \\
& \mathop{rgcd}~(\kw{Zpos}~a)~(\kw{Zneg}~b) 
  \;\re\; \kw{Zpos}~(\mathop{stein}~a~b) \\
& \mathop{rgcd}~(\kw{Zneg}~a)~(\kw{Zpos}~b) 
  \;\re\; \kw{Zneg}~(\mathop{stein}~a~b) \\
& \mathop{rgcd}~(\kw{Zneg}~a)~(\kw{Zneg}~b) 
  \;\re\; \kw{Zneg}~(\mathop{stein}~a~b)
\end{align*}
Here, $\kw{sign}$ returns the sign of the argument in $\{-1, 1\}$.
\end{definition}

\begin{definition}[Normalization rules]
The following rewrite rules normalise fractions written with $\slash$.
To account for division by zero (allowed by SMT solvers), rule \cref{eq:div-0} rewrites such terms to the canonical form $\tfrac{0}{1}$.
Rules \cref{eq:red-0}–\cref{eq:red-0-end} reduce denominators to $1$ whenever the numerator is $0$, while rule \cref{eq:neg-den} and \cref{eq:neg-den2} ensures that the denominator is always positive by moving the negative sign to the numerator.
\begin{align}
& \_ \slash 0 \re 0 \slash 1 \label{eq:div-0}\\
& 0 \slash \ZPos~(\kw{I}~\_) \re 0 \slash 1 \label{eq:red-0}\\
& 0 \slash \ZPos~(\kw{O}~\_) \re 0 \slash 1 \\
& 0 \slash \ZNeg~(\kw{I}~\_) \re 0 \slash 1 \\
& 0 \slash \ZNeg~(\kw{O}~\_) \re 0 \slash 1 \label{eq:red-0-end}\\
& (\ZPos~x) \slash (\ZNeg~y) \re (\ZNeg~x) \slash (\ZPos~y) \label{eq:neg-den}\\
& (\ZNeg~x) \slash (\ZNeg~y) \re (\ZPos~x) \slash (\ZPos~y) \label{eq:neg-den2}
\end{align}
These rules ensure that algebraic operators on rational numbers are total functions, handling all edge cases (e.g., division by zero) by mapping them to the canonical form $\frac{0}{1}$.
\end{definition}

We can then define the rational operators as usual:

\begin{definition}[operator fractions]\label{def:ops-frac}
\begin{align}
&x \slash y +_\Q \index{$+_\Q$} u \slash v \re \kw{frac}~((x * v) + (u * y))~(y * v) \\
&x \slash y *_\Q \index{$*_\Q$} u \slash v \re \kw{frac}~(x * u)~(y * v)
\end{align}
\end{definition}


% \section{Encoding bitvectors (\textbf{\uppercase{BV}})}
% \label{ssec:encoding-bv}

% We interpret the sort of bitvectors \smtinline{ (_ BitVec w)} from the SMT logic \textbf{BV} as a number less than $2^w$. We use the type $\mathop{Fin}$ as the internal representation of a bitvector
% that represents the set of natural numbers less than an arbitrary $w$. We use a dependent pair type (\cref{dep-pair-def}) in Lambdapi necessary to encode \kw{Fin}.

% \begin{definition}[Fin]\label{def:fin-def}
% The type $\mathop{Fin} n$ is the type of natural numbers $i$ with the constraint that $i < n$.
% It is the canonical type with $n$ elements.
% \begin{align*}
% & Fin~(n: \N) \coloneq \Sigma~(\lambda\,x, istrue(x < n)) \\
% & FinMk~(n: \N) (m: \N) (islt: \prf (m < n)) : Fin~n \\
% &\quad\is exist~(\lambda\,x, istrue(x <n))~m~islt\\
% &\mathop{val}~[n]: \mathop{Fin} n \ra \N \is \lambda e, e~s\_1 \\
% &\mathop{isLt}~[n] (f: \mathop{Fin} n): \prf (f~s_1 < n) \is f~s_2\\
% \end{align*}
% \end{definition}

% \begin{definition}[Bitvector]\label{def:bv-def}
% We define bitvectors as natural numbers bounded by powers of two and modular arithmetic representation.
% We first introduce an infix exponentiation function $\_\,\hat{}\,\_$ on $\N$.
% Using this, we define the type $BitVec~n$ as the finite type $Fin~(2~\hat~n)$ (written $Fin~2^n$), representing the set of natural numbers strictly less than $2^n$.
% \begin{align*}
% & \hat{}: \N \ra \N \ra \N \qquad \text{(written inﬁx)}\\
% & 0 ~\hat{}~ 1 \re 1 \N\\
% & n ~\hat{}~ (m + 1) \re n * (n ~\hat{}~ m)\\[1em]
% &BitVec~n \is Fin~(2^n) \\
% & mkBv: \Pi(n~m: \N)(p: \prf~(istrue(n < 2^n))): BitVec~n\\
% &\quad\is FinMk~(2^n)~m~p
% \end{align*}
% Each bitvector of size $n$ is thus a natural number modulo $2^n$, capturing the behavior of (unsigned) integers with $n$ bits.
% The function $mkBv$ then takes a size $n: \N$, an element $m$, and a proof $p$ that $m < 2^n$, and returns a bitvector of type $BitVec~n$.
% Internally, this is constructed using $FinMk$, the constructor for the finite type $Fin~(2^n)$, ensuring that only values within the correct range can inhabit the bitvector type.
% \end{definition}

% Alternative representations could include a vector of \B{},
% formally $\mathop{BitVec}(w: \mathbb{N}) := \Sigma(\mathop{List\,\B})(\lambda(l: \mathop{List\,\B}),\mathop{length}l = w)$,
% or a binary natural number encoding: $\mathop{BitVec}(w: \mathbb{N}) := \Sigma\,(\mathop{Bin\N})(\lambda (n:\mathop{Bin\N}), \mathop{size}\,n = w)$, where $\mathop{Bin\N}$
% is an inductive type representing binary natural numbers greater than zero, built on top of $\mathbb{N}$.
% However, like $\mathop{Fin}$, these structures are not currently available in Lambdapi's standard library.
% We chose the $\mathop{Fin}$ representation over other possible encodings due to its relative efficiency.
% If, in the future, Lambdapi's kernel adds support for efficient representations of natural numbers e.g.,
% via overriding them with arbitrary-precision arithmetic libraries like GMP\footnote{\url{https://gmplib.org/}} bitvectors encoded with $\mathop{Fin}$ would likewise benefit from such optimizations.
% We therefore chose to implement $\mathop{Fin}\,n$, as we believe it provides the most suitable and future-proof foundation for representing the $\mathop{BitVec}$ type,
% particularly in light of potential enhancements to the kernel.


% We recall that the constructor for bitvector in Alethe: $$\mathtt{bbT}\ \enum[n-1]{x}[][0]$$ with $x_i: \B$, for $0\leq i< n$,
% is the Boolean equivalent of the $i$-th bit of $x$ (from least to most significant). Thus $\enum[n-1]{x}[][0]$ is the Boolean bit-level interpretation corresponding to the bit-vector.

% \begin{example}[Bitvector construction]
% The binary number $\#b0010$ is equivalent to:

% \begin{lstlisting}[language=SMT]
% (@bbT false true false false)
% \end{lstlisting}
% \end{example}

% \begin{definition}[bbT Alethe constructor]
% The function \kw{bbT} maps a list of Boolean values ($\bb{L}~\kw{bool}$) to a bitvector whose size is determined by the length of the list.
% \begin{equation*}
% \kw{bbT} : \bb{L}~\kw{bool} \ra BitVec~(\kw{size}~l)
% \end{equation*}
% \end{definition}

% \subsection{Bitvectors arithmetic}

% The SMT-LIB language offers arithmetic operations on bitvectors, such as $\mathop{bvadd}$.
% Some of these operations are signed, while others are unsigned. In the Lambdapi representation, bitvectors are represented as a wrapper around a $Fin$ type with an appropriate bound.
% Since $\mathop{Fin}$ itself wraps a natural number (\N), bitvector operations rely on corresponding functions and proofs defined over \N.
% Arithmetic functions on bitvectors return results modulo the size of the bitvector, ensuring that computations wrap around according to the fixed width.
% In order to illustrate the principle, we provide the definition of $\mathop{bvadd}$ in \cref{def:bv-add-def}.

% \begin{definition}[Bitvector addition]\label{def:bv-add-def}
% \begin{align*}
% &\mathop{bvadd}\,[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
% &\quad\coloneq\; \lambda x, \lambda y, \; \mathop{Fin.add}~2^n~x~y \\
% &\mathop{Fin.add}~: \mathop{Fin}~n \ra \mathop{Fin}~n \ra \mathop{Fin}~n \\
% &\mathop{Fin.add}~: (\mathbin{exist}~x~p_x) (\mathbin{exist}~y~p_y) \\
% &\re \mathop{FinMk}~n~((x + y) \mathbin{mod} n)~(modulo\_lt~(x * y)~x~n~p_x)
% \end{align*}
% The operator $\mathbin{mod}$ implement the modulo function for natural numbers and the lemma $modulo\_lt$
% show that for any $x * y$ and $x$, if $x * y < n$, then $x \mathbin{\%} n < n$.
% \end{definition}


% \subsection{Bitwise Operators}

% SMT-LIB define bitwise operators such as $\mathop{bvand}$ or $\mathop{bvlshr}$  (which shifts a bitvector to the right) for manipulating the individual bits of one or more bitvectors.
% Following a similar strategy, we encoded these operations over $\N$ and wrap the bitvector operations on them. We details our approach in \cref{app:bf-defs}.

\section{SMT-LIB helper operators}
\label{sec:encoding-helper-operator}

SMT-LIB provides the operators:
\begin{itemize}
  \item \smtinline{(par (A) (distinct A A Bool :pairwise))}
  \item \smtinline{(par (A) (ite Bool A A A))}
\end{itemize}
The \smtinline{distinct} denotes the function that returns true if its two arguments are not identical as defined in \cref{tab:distinct-spec}, and \smtinline{ite} denotes the function that
returns its second argument or its third depending on whether its first argument is true or not.

\begin{definition}[Distinctness predicate]
We encode the distinct parameter of SMT by introducing a predicate over dependent vectors \cref{def:dependent-vector},
since both the size of the collection and the type of its elements influence how the predicate is computed.
\begin{equation*}
\kw{distinct}\index{\kw{distinct}}~[a: Set] [n: \N] : \kw{Vec}~a~n \ra \prop
\end{equation*}
\end{definition}

\begin{table}[tb]
\caption{Specification of the \tt{distinct\_elim}rule in Alethe.}
\begin{tabular}{@{}ll@{}}
\multicolumn{2}{@{}l@{}}{\textbf{Rule 93:} R = \tt{distinct\_elim}} \\[0.5em]
\multicolumn{2}{@{}l@{}}{This rule eliminates the \tt{distinct} predicate.} \\
\multicolumn{2}{@{}l@{}}{When arguments are type \textbf{Bool}:} \\[0.5em]

\textit{i.} $\Gamma \vdash \ (\mathsf{distinct}\ \varphi\ \psi) \approx \lnot(\varphi \approx \psi)$ & \tt{R} \\[0.3em]
\textit{i.} $\Gamma \vdash \ (\mathsf{distinct}\ \varphi_1\ \varphi_2\ \varphi_3\ \ldots) \approx \bot$ & \tt{R} \\[0.8em]

\multicolumn{2}{@{}l@{}}{For all other sorts the rule is} \\[0.5em]
\textit{i.} $\Gamma \vdash \ (\mathsf{distinct}\ t_1 \ \ldots \ t_n) \approx \bigwedge_{i=1}^{n} \ \bigwedge_{j=i+1}^{n} \ t_i \neq t_j$ & \texttt{R}
\end{tabular}
\label{tab:distinct-spec}
\end{table}

\begin{definition}[Distinctness eliminator]
To implement the behavior specified in \cref{tab:distinct-spec}, we formalize the elimination of distinct through a series of rewriting rules.
\begin{align*}
&\mathop{\mathrm{distinct}}~ \mathbin{\_}~\Box_\bb{V} \re \bot \\
&\mathop{\mathrm{distinct}}~\mathbin{\_}~ (x \cons_\bb{V} \Box_\bb{V}) \re \top \\
&\mathop{\mathrm{distinct}}~\mathbin{\_}~ (x \cons_\bb{V} y \cons_\bb{V}  \Box_\bb{V}) \re \neg (x = y) \\
&\mathop{\mathrm{distinct}}~o~(x \cons_\bb{V} y \cons_\bb{V} z \cons_\bb{V} tl)))) \re \bot \\
&\mathop{\mathrm{distinct}}~\_~(x \cons_\bb{V} y \cons_\bb{V} tl) \re \neg (x = y) \land \kw{distinct}~tl
\end{align*}

The first two rules capture the base cases: a \(\mathop{\mathrm{distinct}}\) check on an empty vector returns $\bot$, while a vector containing a single element trivially returns $T$.
The third rule handles the case of two elements, reducing to the negation of their equality.
For longer vectors, the fourth rule reflects the immediate elimination to  $\bot$ when parameter are type $\prop$ (\smtinline{Bool}),
while the final rule encodes the recursive elimination for others types than $\prop$. It process by requiring that the head element differs from the second and that the
\(\mathop{\mathrm{distinct}}\) property holds for the remaining tail.
\end{definition}

\begin{example}
\(
    \mathop{\mathrm{distinct}}~(\bot \cons_\bb{V} \top \cons_\bb{V} \top \cons_\bb{V} \Box_\bb{V}) \re \bot
\)
and
\(
    \mathop{\mathrm{distinct}}~(\top \cons_\bb{V} \bot \cons_\bb{V} \Box_\bb{V}) \re \neg (\top = \bot).
\)
\end{example}

\begin{definition}[\texttt{ite}]
We define a conditional expression:
\begin{align*}
\kw{ite}\index{\kw{ite}}: \Pi [a: \set],\, \prop \ra \el\,a \ra \el\,a \ra \el\,a
\end{align*}
This conditional expression has the particularity that its condition is of type $\prop$ and not in \B.
We also define the introduction principle:
\begin{align*}
&\mathop{\mathrm{ite\_ind}} : \Pi [a],\, \Pi (c : \el\,o)\, (t\, e : \el\,a)\, (p : \el\,a \ra \mathrm{Prop})\\
&\quad\left( \prf\,c \ra \prf(p~t) \right) \ra \\
&\quad\left( (\prf\,c \ra \prf\,\bot) \ra \prf(p~e) \right) \ra \\
&\quad\prf(p~(\kw{ite}~c~t~e)))
\end{align*}
\end{definition}

\section{Encoding clauses}

Alethe distinguishes between clauses that appear in steps, such as \colorbox{green!30}{(cl~$l_1 \dots l_n$)} in \cref{eq:step}, and ordinary disjunction \cite[\S 4]{alethespec}.
The syntax for clauses uses the \textcolor{purple}{\texttt{cl}} operator, while disjunction is represented as the standard SMT-LIB \textcolor{purple}{\texttt{or}}.
Alethe identifies a clause as a set of literals. As mentioned in \cref{ch:alethe}, Alethe identifies clauses that differ only in the order of literals. In particular, note that the ``literals'' appearing in clauses may actually be arbitrary formulas in Alethe.
It provides the \kw{or} rule for converting disjunctions into clauses:
\[
\begin{matrix*}[l]
  i. & \triangleright & \varphi_1 \lor \dots \lor \varphi_n  & (\dots) \\
  j. & \triangleright & (\texttt{\textcolor{purple}{cl}}~\varphi_1 \dots \varphi_n)  & (\kw{or}~i)[] \\
\end{matrix*}
\]

\begin{remark}[Lack of Structural Canonical Form in Disjunctive Clauses]
By interpreting a clause as a disjunction, a clause $cl~(l_1~l_2~l_3~l_4)$ will be then translated into $l_1 \lor (l_2 \lor (l_3 \lor l_4))$.
 Therefore, the concatenation of two clauses (what is happening in the conclusion of \texttt{resolution}) need not unify with the translated clause of the step. For example, taking 3 arbitrary steps:

\begin{itemize}
    \setlength{\itemsep}{5pt}
    \setlength{\parskip}{0pt}
    \item[] $A.~\triangleright~(\text{cl}~\textcolor{purple}{x_1}~\textcolor{blue}{x_2~x_3}) \quad (\dots)[\dots]$
    \item[] $B.~\triangleright~ (\text{cl}~\textcolor{purple}{\neg x_1}~\textcolor{orange}{y_2}~\textcolor{orange}{y_3}) \quad  (\dots)[\dots]$
    \item[] $C.~\triangleright~(\text{cl}~\textcolor{blue}{x_2~x_3}~\textcolor{orange}{y_2~y_3}) \quad (\texttt{resolution A B})[(\textcolor{purple}{x_1}~\texttt{true})]$
\end{itemize}

Interpreting a clause as a disjunction, we obtain a concatenated form such as $((\textcolor{blue}{x_2} \lor \textcolor{blue}{x_3}) \lor (\textcolor{orange}{y_2} \lor \textcolor{orange}{y_3}))$.
This aligns with the classical formulation of the \texttt{resolution} inference rule, expressed as $x \lor Y$ and $\ \neg x \lor Z \vdash Y \lor Z$.
However, in {\lpm} we have:
\begin{align*}
((\textcolor{blue}{x_2} \lor \textcolor{blue}{x_3}) \lor (\textcolor{orange}{y_2} \lor \textcolor{orange}{y_3})) & \nequiv_{\beta\Sigma} (\textcolor{blue}{x_2} \lor (\textcolor{blue}{x_3} \lor (\textcolor{orange}{y_2} \lor \textcolor{orange}{y_3}))) \\
& \nequiv_{\beta\Sigma} (((\textcolor{blue}{x_2} \lor \textcolor{blue}{x_3}) \lor \textcolor{orange}{y_2}) \lor \textcolor{orange}{y_3})
\end{align*}
even though these forms are semantically identical.

Additionally, the pivot must occur at the head of the clause in order to apply the \kw{resolution} rule.
As a result, resolving clauses requires reasoning modulo associativity and commutativity.
To address the associativity issue, we propose a canonical representation for clauses.
For commutativity, instead of permuting the clauses, we simply provide the index of the pivot literal, allowing us to disregard its position in the clause.

\end{remark}

\begin{definition}[Clause encoding]\label{def:encoding-clause}
We define the type $\kw{Clause}$ to represent an Alethe clause as a list of propositions, thereby ensuring a canonical form.
\begin{align*}
&\tt{Clause} \index{$\tt{Clause}$}: \type \\
&\nil\index{$\nil$}: \tt{Clause} \\
&\veedot\index{$\veedot$}: \prop \ra \tt{Clause}  \ra \tt{Clause}
\end{align*}
The constructor $\veedot$ prepends an element to a list, and $\nil$ denotes the empty list.
\end{definition}

\begin{definition}[Concatenation of clauses]
The operator $\pp$ \index{$\pp$} is used to concatenate lists.
\begin{align*}
& \pp: \tt{Clause} \ra \tt{Clause} \ra \tt{Clause} \\
& \nil \mathop{\pp} x \re x \\
& (x \veedot y) \mathop{\pp} z \re x \veedot (y \mathop{\pp} z)
\end{align*}
\end{definition}

\begin{definition}[Proof on \kw{Clause}]\label{def:cl2disj}
Clauses are logically interpreted as disjunctions via the function $\cltodisj$, defined through rewriting rules. For convenience, we also introduce the predicate $\pid$, which asserts the provability of a clause.
\begin{align*}
& \kw{cl2disj} \index{$\kw{cl2disj}$}: \tt{Clause} \ra \prop \\
& \cltodisj~\nil \re \bot\\
& \cltodisj~(x \veedot y) \re x \lor (\cltodisj~y) \\
& \pid \index{$\pid$} (c : \tt{Clause}) \coloneqq \prf\,(\cltodisj~c)
\end{align*}
\end{definition}

We can now prove the equivalence between clause and disjunction.

\begin{lemma}[Clause elimination]\label{lemma:clause-elim}
For any $p \colon \prop$ and $q,r \colon \tt{Clause}$, If $\pid (p \veedot q)$ and $(\pid (p \veedot \nil) \ra  \pid r)$ and $(\pid q \ra  \pid r)$ then $\pid r$.
\end{lemma}
\begin{proof}
Since we have the equivalence in hypothesis 
\[
  \pid (p \veedot q) \equivL \prf\,(p \lor \cltodisj\,q)
\]
we apply the classic disjunction elimination rule.
Then we can conclude $\prf\,p \ra \prf\,(\cltodisj\,r)$ wih the hypothesis $\pid (p \veedot \nil) \ra  \pid r$, and we can conclude $\prf\,(\cltodisj\,q) \ra \prf\,(\cltodisj\,r)$
with the hypothesis $\pid q \ra  \pid r$.
\end{proof}

\smallskip

\begin{lemma}[Concatenation is disjunction]\label{lemma:clause-equiv-disj}
For any two clauses $a\,b$, the equivalence $\prf\,(\cltodisj(a~\pp~b)) \Leftrightarrow \prf\,(\cltodisj\,a \lor \cltodisj\,b)$ holds.
\end{lemma}
\begin{proof} By induction on $a$.
  \begin{itemize}
    \item For the base case $a = \nil$ we must show that
    \[
        \prf\, (\cltodisj (\nil\, \pp \, b)) \Leftrightarrow \prf\, (\cltodisj\,\nil \lor \cltodisj\,b)
    \]
    The implication ``$\Rightarrow$'' is trivial because $\nil\,\pp\,b$ rewrites to $b$.
    The implication ``$\Leftarrow$'' is proved using the standard elimination rule $\lor_e$ for disjunction, which requires proving
    \begin{itemize}
      \item $\prf\,(\cltodisj\,\nil) \ra \prf\,(\cltodisj\,(\nil\,\pp\,b))$
      \item as well as $\prf\,(\cltodisj\,b) \ra \prf\,(\cltodisj\,(\nil\,\pp\,b))$.
    \end{itemize}
    Both proofs are immediate since $\cltodisj\,\nil$ rewrites to $\bot$ and $\nil\,\pp\,b$ rewrites to $b$.
    \item For the case $a = h \veedot tl$ we may use the induction hypothesis $\prf\,(\cltodisj\, (tl\, \pp\, b)) \Leftrightarrow \prf\,(\cltodisj\,tl \lor \cltodisj\, b)$.
    The conclusion is then easy to prove based on the rewriting rules for the operators $\cltodisj$ and $\pp$, together with associativity of $\lor$.
    \end{itemize}
\end{proof}
