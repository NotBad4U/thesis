
\section{Encoding the logic of SMT in Lambdapi}
\label{sect:encoding}

We describe our embedding of the logic of SMT and Alethe into Lambdapi.
Our work applies to input problems expressed in the logics \texttt{UF}, \texttt{LIA} and \texttt{QF} or their sub-logics.
We begin by detailing the encoding of the SMT-LIB sorts used in these logics, which is necessary for reconstructing their corresponding Alethe proofs.
We then present our method for translating these proofs.

\subsection{A Prelude Encoding for Alethe}
\label{sec:encoding-prelude}

\begin{definition}[Prelude Encoding]
\label{def:defuniv}
The signature $\Sigma$ of our encoding contains the following definitions and rewrite rules that we use to encode Alethe proofs:
\begin{align*}
&\set\index{\set}: \type & &\prop\index{\prop}: \type \\
&\index{\el{}} \el{}: \set \rightarrow \type  & &\index{\prf}\prf{} : \prop \rightarrow \type \\
&\mathop{\leadsto}\index{$\leadsto$}: \set \rightarrow \set \rightarrow \set \quad \text{(infix)} & &o: \set \\
&\el\,(x \leadsto y) \hookrightarrow \el\,x \rightarrow \el\,y & &\el\,o\index{o}  \hookrightarrow \prop
\end{align*}
\end{definition}

The notions of term, proposition, and proof are not primitive in \lpm.
We ﬁrst deﬁne a notion analogousto the Predicate logic notion of term, to express the objects the theory speaks about, such as the natural number.
The constants \set{} and \prop{} (lines 1 and 6) are type universes ``à la Tarski'' \cite[\S Universes]{intuitype} in \lpm.
The type \set{} represents the universe of \textit{small types}, i.e.\ a subclass of types for which we can define equality.
SMT sorts are represented in \lpm{} as elements of type \set{}. Since elements of type \set{} are not types themselves, 
we also introduce a decoding function $\el: \set \rightarrow \type$ that  embed the terms of type \set{} into terms of type \type.
Therefore, our function \el{} interprets SMT sorts as \type.
Thus, we represent the terms of sort \lstinline[language=SMT,basicstyle=\ttfamily\normalsize]|Bool| of SMT by elements of type $\el{}\,o$.
The constructor $\leadsto$ (written infix) is used to encode SMT functions and predicates.

Jus as like \lpm{} does not contain a primitive notion for expressing the objects of the theory, it does not contain a primitive notion of proposition.
The constant \prop{} represents the universe of propositions. Predicates symbols are represented as constants of type $\set{} \ra \dots \ra \prop$ .
Similar to \set{}, elements of type \prop{} are not types themselves; they are mapped to types by the decoding function $\prf{}: \prop \rightarrow \type$.
Drawing an analogy with the Curry-de-Brujin-Howard isomorphism \cite{curryhoward}, this function embeds propositions into types by mapping each proposition $A$ to the type $\prf{}~A$, which represents its proofs.
However, the analogy is only partial in two important ways. First, the propositions themselves are not the types of their proofs: if $t$ is a proof of $A$, then it does not have the type $A$,
but the type $\prf{}A$.Second, the embedding is not surjective—meaning not all types correspond to proofs. For instance, neither \set{} nor \prop{} are themselves types of proofs. 

Consequently, a \emph{step} in an Alethe proof trace is represented as an inhabitant of type $\prf{}\,p$.

\subsection{Constructive connectives, quantifiers and classical facts}
\label{ssec:encoding-prop}

Given that SMT solvers operate under classical logic, we employ the constructive connectives and quantifiers,
while explicitly introducing the classical principles of the Law of the Excluded Middle and propositional extensionality.

\begin{definition}[Constructive connectives, quantifiers]
\begin{align}
& \top : \prop \\
& \bot : \prop \\
& \land : \prop \ra \prop \ra \prop \qquad \text{(written inﬁx)} \\
& \lor : \prop \ra \prop \ra \prop \qquad \text{(written inﬁx)} \\
& \Rightarrow : \prop \ra \prop \ra \prop \qquad \text{(written inﬁx)} \\
&  \prf (a \Rightarrow\,b) \re \prf a \ra \prf b \label{eq:imp}\\
& \neg a \is a \Rightarrow \bot \\
& \forall : \Pi {[a: \set]}, (\el\, a \ra \prop) \ra \prop \label{eq:forall}\\
& \prf{}(\forall\,p) \re \Pi x, \prf{p~x}\\
& \exists : \Pi {[a: \set]}, (\el\, a \ra \prop) \ra \prop \\
& {=} : \Pi [a : \set], \el\, a \ra \el\, a \ra \prop \qquad \text{(written inﬁx)} \\
& \epsilon: \Pi {[a: \set]}, (\el\,a \ra \prop) \ra \el\,a \\
& \epsilon_i: \Pi {[a: \set]}, \Pi (x : \el\,a), \Pi (P : \el\,a \ra \prop) \\
& \quad \ra \prf P\,x \ra \prf P\,(\epsilon\,P) \\
& \epsilon_{d}: \Pi {[a: \set]}, \Pi (P\,Q : \el\,a \ra \prop) \\
& \quad \ra \Pi x : \el\,a, \prf (P\,x = Q\,x) \ra (\epsilon \, P = \epsilon \, Q)
\end{align}
\end{definition}

Accordingto the Curry-de Bruijn-Howard correspondence, a proof of $A \Rightarrow B$ should have the type $\prf (A \Rightarrow B)$.
However, such a proof actually has type $\prf\,A \ra \prf\,B$. This means that the types $\prf (A \Rightarrow B)$ and $\prf\,A \ra \prf\,B$ must be identiﬁed.
To achieve this, we introduce the rewriting rule \cref{eq:imp}, allowing $\prf (A \Rightarrow B)$ to be rewritten as $\prf\,A \ra \prf\,B$.

We cannot assign the type $\Pi : \type, (X \ra \prop) \ra \prop$ to the universal quantifier, because in \lpm{} there is no mechanism to
for quantifying over variables of type \type. Instead, we assign the type $\Pi\,x:\set{},(\el\,x \ra \prop) \ra \prop$ to the generic universal quantiﬁer $(\forall)$ \cref{eq:forall}.
Thus, we will be able to quantify over SMT sorts that will be encoded as inhabit of type \set. Furthermore, the previously defined term $o: Set$, together with the rewrite rule $\el\,o\index{o}  \hookrightarrow \prop$
, enables quantification over propositions, rendering the universal quantifier impredicative.

Equality (=) over small types is parameterized over types
$\el\,a$ for the type parameter $[a : \set{}]$ (the square brackets indicate that this parameter need not be given explicitly).
We also define the choice operator $\epsilon$ (\cite[\S 2.1]{alethespec}) as illustrated above.
The intended interpretation for the $\epsilon$ operator is that $(\epsilon\,x,\, P~x)$ denotes some $x$ satisfying the predicate $P$, if there is one.
The characteristic proof rules for the $\epsilon$ operator are represented by
the constants $\epsilon_i$ for proving a predicate $P\,(\epsilon\,P)$ by exhibiting a witness $x$ such that $P\,x$ is provable,
and $\epsilon_d$ that asserts that the epsilon operator assigns the same witness to equivalent predicates $P$ and $Q$.
SMT logic enjoys the property of propositional completeness (also referred to as \emph{propositional degeneracy}) asserting that:
 \[
  \forall p,(p = \top) \lor (p = \bot) 
\]
Moreover, propositionally equivalent formulas are equal. We thus introduce the axioms in \cref{def:classical-facts}.

\begin{definition}[Classical facts]
\begin{align*}
\texttt{em}:\ & \Pi [p: \prop], \prf (p \lor \neg p) \\
\texttt{prop\_ext}:\ & \Pi [p\,q: \prop], \prf (p \Leftrightarrow q ) \rightarrow \prf (p = q)
\end{align*}
\label{def:classical-facts}
\end{definition}

\subsection{Representing Linear Integer Arithmetic (\textbf{LIA})}
\label{ssec:encoding-lia}

\begin{figure}
\centering
\begin{align*}\label{eq:eq1}
&\N: \type & &\bb{P}: \type & &\Z: \type \\
&|~0: \N  & &|~\tt{H} : \bb{P} & &|~\ZO: \Z \\
&|~\tt{+1}:\N \ra \N & &|~\tt{O}: \bb{P} \ra \bb{P} & &|~\ZPos: \bb{P} \ra \Z \\
& & &|~\tt{I}: \bb{P} \ra \bb{P} & &|~\ZNeg: \bb{P} \ra \Z \\
&\tt{nat}: \set & &\tt{pos}: \set & &\tt{int}: \set \\
&\el~\tt{nat} \re \N & &\el~\tt{pos} \re \bb{P} & &\el~\tt{int} \re \Z 
\end{align*}
\caption{Inductive type definitions for binary positive number, natural and integers}
\label{fig:sorts-constructors}
\end{figure}

\begin{figure}
\begin{framed}
{\footnotesize
\centering
% --- Integer Addition ---
\begin{align*}
&+: \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO + y \re y \\
& x + \ZO \re x \\
& (\tt{Zpos x}) + (\tt{Zpos y}) \re (\ZPos~(\tt{add}~x~y))  \\
& (\tt{Zpos x}) + (\tt{Zneg y}) \re (\tt{sub}~x~y)  \\
& (\tt{Zneg x}) + (\tt{Zpos y}) \re (\tt{sub}~y~x)  \\
& (\tt{Zneg x}) + (\tt{Zneg y}) \re \ZNeg~(\tt{add}~x~y)
\end{align*}
\noindent

% --- Positive Binary Arithmetic ---
\[
\begin{array}[t]{ll}
\begin{aligned}
&\tt{add} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{add}~(\tt{I}~x)~(\tt{I}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{add}~(\tt{I}~x)~(\tt{O}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{add}~(\tt{O}~x)~(\tt{I}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{add}~(\tt{O}~x)~(\tt{O}~q) \re \tt{O}~(\tt{add}~x~q) \\
& \tt{add}~x~\tt{H} \re \tt{succ}~x \\
& \tt{add}~\tt{H}~y \re \tt{succ}~y \\
\end{aligned}
&
\begin{aligned}
&\tt{mul} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{mul}~\tt{H}~y \re y \\
& \tt{mul}~y~\tt{H} \re y \\
& \tt{mul}~(\tt{O}~x)~y \re \tt{O}~(\tt{mul}~x~y) \\
& \tt{mul}~(\tt{I}~x)~y \re \\
& \quad \tt{add}~y~(\tt{O}~(\tt{mul}~x~y)) \\
\end{aligned}
\end{array}
\]
\noindent

\begin{align*}
&\tt{addc} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{addc}~(\tt{I}~x)~(\tt{I}~q) \re \tt{I}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{I}~x)~(\tt{O}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{O}~x)~(\tt{I}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{O}~x)~(\tt{O}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{addc}~x~\tt{H} \re \tt{add}~x~(\tt{O}~\tt{H}) \\
& \tt{addc}~\tt{H}~y \re \tt{add}~(\tt{O}~\tt{H})~y \\
\end{align*}
\noindent

% --- Multiplication ---
\begin{align*}
&\tt{*} : \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO *~\_ \re \ZO \\
& \_ *~\ZO \re \ZO \\
& \ZPos x *~\ZPos y \re \ZPos (\tt{mul}~x~y) \\
& \ZPos x *~\ZNeg    y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZPos y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZNeg    y \re \ZPos (\tt{mul}~x~y) \\
\end{align*}
}%
\caption{Arithmetic operations over binary positive numbers $\bb{P}$ and integers $\Z$}
\label{fig:arith-ops}
\end{framed}
\end{figure}

The definition we use of natural numbers and integers in Lambdapi in \cref{fig:sorts-constructors} follows a common encoding found in many other theories, including the one adopted in the Rocq standard library \cite{Rocq-refman}.
Natural numbers are defined inductively with the two constructors $0$ and the the successor function $+1$ written postfix.
The type $\bb{P}$  is an inductive type representing strictly positive integers in binary form.
Starting from 1 (represented by the constructor \tt{H}), one can add a new least significant digit via the constructor \tt{O} (digit 0) or the constructor \tt{I} (digit 1).
For example, we represent 5 (101b) as $\tt{I} (\tt{O} (\tt{H}))$. The type $\Z$ represents integers in binary form.
An integer is either zero (with constructor $\ZO$) or a strictly positive number $\ZPos$ (coded as a $\bb{P}$) or a strictly negative number $\ZNeg$.
We make use of Lambdapi's \lstinline[language=Lambdapi,basicstyle=\ttfamily\normalsize]|builtin| mechanism to enable decimal notation for numeric values, for instance, writing $2$ for $\ZPos (\mathop{\tt{O}} \tt{H})$.
to convert natural representations of values into elements of $\Z$.
To enable quantification over elements of these types, we introduce constants such as $\tt{int}:\set$ that represent codes for these types along with a rule for rewriting codes to their corresponding types, for example $\el~\tt{int} \re \Z$.
Arithmetic operations over these types are defined in \cref{fig:arith-ops}. This includes addition over $\Z$, denoted $(+)$, and over $\bb{P}$, denoted \texttt{add}.
These operations are implemented using rewrite rules, which necessitates proofs of both confluence and termination.
We use this encoding of integer operations for extending the embedding of Alethe proofs in Lambdapi described in \cite{ColtellacciMD24}.
In particular, the SMT sort $\textbf{Int}$ is mapped to $\el~\texttt{int}$, and the arithmetic operations of SMT to their counterparts in the Lambdapi encoding.


\begin{figure}
\begin{framed}
{\footnotesize
\centering
% --- Comparison and Integer comparison ---
\[
\begin{array}[t]{l@{\hspace{4em}}l}
\begin{aligned}
&\tt{Comp}: \type{} \\
&|~\tt{Eq}: \tt{Comp} \\
&|~\tt{Lt}: \tt{Comp} \\
&|~\tt{Gt}: \tt{Comp} \\
&\tt{comp}: \set \\
&\el{}~\tt{comp} \re \tt{Comp}
\end{aligned}
&
\begin{aligned}
&\doteq : \Z \ra \Z \ra \tt{Comp} \\
& \ZO \doteq \ZO \re \tt{Eq} \\
& \ZO \doteq \ZPos~\_ \re \tt{Lt} \\
& \ZO \doteq \ZNeg~\_ \re \tt{Gt} \\
& \ZPos~\_ \doteq \ZO \re \tt{Gt} \\
& \ZPos~p \doteq \ZPos~q \re \tt{cmp}~p~q \\
& \ZPos~\_ \doteq \ZNeg~\_ \re \tt{Gt} \\
& \ZNeg~\_ \doteq \ZO \re \tt{Lt} \\
& \ZNeg~\_ \doteq \ZPos~\_ \re \tt{Lt} \\
& \ZNeg~p \doteq \ZNeg~q \re \tt{cmp}~q~p
\end{aligned}
\\[3em]
\begin{aligned}
  &\tt{isGt} : \tt{Comp} \ra \B \\
  &\tt{isGt}~\tt{Eq} \re \tt{false} \\
  &\tt{isGt}~\tt{Lt} \re \tt{false} \\
  &\tt{isGt}~\tt{Gt} \re \tt{true}
\end{aligned}
&
\begin{aligned}
  &\tt{istrue} : \B \ra \prop \\
  &\tt{istrue}~\tt{true} \re \top \\
  &\tt{istrue}~\tt{false} \re \bot\\
  &\\
\end{aligned}
\end{array}
\]

\vspace{3em}

\[
\begin{array}{l@{\hspace{4em}}l}
\begin{aligned}
  &\tt{isEq} : \tt{Comp} \ra \B \\
  &\tt{isEq}~\tt{Eq} \re \tt{true} \\
  &\tt{isEq}~\tt{Lt} \re \tt{false} \\
  &\tt{isEq}~\tt{Gt} \re \tt{false}
\end{aligned}
&
\begin{aligned}
  &\tt{isLt} : \tt{Comp} \ra \B \\
  &\tt{isLt}~\tt{Eq} \re \tt{false} \\
  &\tt{isLt}~\tt{Lt} \re \tt{true} \\
  &\tt{isLt}~\tt{Gt} \re \tt{false}
\end{aligned}
\\[3em]
\begin{aligned}
  &\tt{isGt} : \tt{Comp} \ra \B \\
  &\tt{isGt}~\tt{Eq} \re \tt{false} \\
  &\tt{isGt}~\tt{Lt} \re \tt{false} \\
  &\tt{isGt}~\tt{Gt} \re \tt{true}
\end{aligned}
&
\begin{aligned}
  &\tt{istrue} : \B \ra \prop \\
  &\tt{istrue}~\tt{true} \re \top \\
  &\tt{istrue}~\tt{false} \re \bot\\
  &\\
\end{aligned}
\end{array}
\]
% --- Inequalities relations ---
\noindent
\begin{align*}
&\leq: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, \neg (\tt{istrue}(\tt{isGt}(x \doteq y))) \\
&<: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, (\tt{istrue}(\tt{isLt}(x \doteq y))) \\
&\geq: \Z \ra \Z \ra \prop \coloneq \lambda x,\lambda y, \neg (x < y) \\
&>: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, \neg (x \leq y)
\end{align*}
}%
\end{framed}
\caption{Definitions for inequalities over $\Z$.}
\label{fig:arith-inequalities-def}
\end{figure}

In \cref{fig:arith-inequalities-def}, we also introduce inductive types \tt{Comp} \index{\tt{Comp}} and $\B$ representing comparison operators and Booleans.
We will refer to the rewrites rules of \cref{fig:arith-ops} and \cref{fig:arith-inequalities-def} as $\ra_\Z$ and $\ra_\bb{P}$ in the following sections.
The function $\doteq : \Z \to \Z \to \texttt{Comp}$ compares two integers, relying on the auxiliary function $\texttt{cmp} : \bb{P} \to \bb{P} \to \texttt{Comp}$ to perform comparisons between strictly positive binary numbers.
Based on this comparison mechanism, we define inequality operators over $\Z$ as binary predicates, by reducing them to the decidable comparison $\doteq$. They reduce to $\top$, $\bot$ (or negated) by applying rules of $\ra_\Z$ and $\ra_\bb{P}$.
For example, $1 < 2 \hookrightarrow \tt{istrue}(\tt{isLt}(1 \doteq 2)) \hookrightarrow \tt{istrue}(\tt{isLt}(\tt{Lt})) \hookrightarrow \tt{istrue}(\tt{true}) \hookrightarrow \top$, with $1 = \mathop{\ZPos} \tt{H}$ and $2 = \mathop{\ZPos} (\mathop{\tt{O}} \tt{H})$.

\begin{lemma}[Confluence of $\ra_\bb{Z}$ and $\ra_\bb{P}$]
\begin{proof}
CSI \cite{CSI} automatically proves the confluence of $\ra_\bb{Z}$ and $\ra_\bb{P}$ by giving the polynomial interpretation:
\begin{align*}
[\tt{succ}(x)] = 4*x & &[\tt{add}(x, y)] = 4 * x + 4 * y + 2  & &[ {\tt{H}} ] = 4 \\
\end{align*}
\end{proof}
\label{lemma:confluenceZP}
\end{lemma}


\subsection{Representing Linear Arithmetic (\textbf{LA})}
\label{ssec:encoding-la}

\begin{figure}
\begin{framed}
\begin{align*}
& \Q: \type \\
& |~\tt{\#}: \Z \ra \bb{P} \ra \Q{} \quad \text{(written infix)}\\
&\\
& rational: \set \\
& \el{}\,\tt{rational} \re \Q
\end{align*}

\noindent

\begin{align*}
&\tt{Qnum}(n \,\#\, d) \ra n \\
&\tt{Qden}(n \,\#\, d) \ra d \\
&\tt{QDen}(q : \Q) \coloneq \ZPos(\tt{Qden}(q)) \\
&(n_1 \,\#\, d_1) \doteq_\Q (n_2 \,\#\, d_2) \ra (n_1 * d_2)~\doteq~(n_2 * d_1) \quad \text{(infix)} \\
&(n_1 \,\#\, d_1) =_\Q (n_2 \,\#\, d_2) \ra (n_1 * d_2) = (n_2 * d_1) \quad \text{(infix)} \\
&(n_1 \,\#\, d_1) \le_\Q (n_2 \,\#\, d_2) \ra (n_1 * d_2) \le (n_2 * d_1) \quad \text{(infix)} \\
&(n_1 \,\#\, d_1) <_\Q (n_2 \,\#\, d_2) \ra (n_1 * d_2) < (n_2 * d_1) \quad \text{(infix)} \\
&(n_1 \,\#\, d_1) \ge_\Q (n_2 \,\#\, d_2) \ra (n_1 * d_2) \ge (n_2 * d_1) \quad \text{(infix)} \\
&(n_1 \,\#\, d_1)  >_\Q (n_2 \,\#\, d_2) \ra (n_1 * d_2) > (n_2 * d_1) \quad \text{(infix)} \\
\\
&(n_1 \,\#\, d_1)~q+~(n_2 \,\#\, d_2) \ra \\
& \quad (n_1 * d_2 + n_2 * d_1) \,\#\, \text{mul}(d_1, d_2) \quad \text{(infix)}. \\
\end{align*}
\end{framed}
\caption{Encoding rational}
\label{fig:rational-sort}
\end{figure}


SMT solver define the sort \smtinline{Real}, but in practice the reconstruction of Alethe proof with the logic \textbf{\tt{LA}}
only require the rational number (\Q) for most of the case. We then only define the rational number \cref{fig:rational-sort} and we will translate SMT
term of sort \smtinline{Real} as lambdapi term of sort {\Q}. We follows the encoding of rational from Rocq \cite{Rocq-refman} that are constructed with a numerator of type {\Z} and a denominator of type {\PP} to prevent
to have zero as a denominator even if SMT-LIB allows in its format the denominator to be null. The immediate problem with this representation is the lack of canonicity.
In particular, from the Lambdapi point of view, $1 \# 2 \neq 2 \# 4$. We implemented a normalisation functions for rational numbers based on the a generalized GCD.
The function \tt{Zggcd} takes two integer $a$ and $b$ returns a triple $(g, (u, v))$ where $g = \tt{gcd}(a, b)$, and the integers $u$ and $v$ satisfy the \emph{Bézout identity}: $g = u \times a + v \times b$.
The complete auxiliary function (e.g. $\tt{ggcd}_\PP$) can be found in \cref{app:complete-gcd}. The function $|\_|$ compute the absolute value.

\begin{definition}[Zggcd]
\begin{align*}
&\tt{Zggcd}~\ZO~b \ra (|b|,~(\ZO,~\tt{sgn}~b)) \\
&\tt{Zggcd}~a~\ZO \ra (|a|,~(\tt{sgn}~a,~\ZO)) \\
&\tt{Zggcd}~(\ZPos~a)~(\ZPos~b) \ra \tt{let } (g,(u,v)) \coloneqq \tt{ggcd}_\PP~a~b~ \\
&\quad \tt{ in} (\ZPos(g),~(\ZPos(u),~\ZPos(v))) \\
&\tt{Zggcd}~(\ZPos~a)~(\ZNeg~b) \ra \tt{let } (g,(u,v)) \coloneqq \tt{ggcd}_\PP~a~b~ \\
&\quad \tt{ in} (\ZPos(g),~(\ZPos(u),~\ZNeg(v)) \\
&\tt{Zggcd}~(\ZNeg~a)~(\ZPos~b) \ra \tt{let } g,(u,v)) \coloneqq \tt{ggcd}_\PP~a~b~ \\
&\quad \tt{ in} (\ZPos(g),~(\ZNeg(u),~\ZPos(v))) \\
&\tt{Zggcd}~(\ZNeg~a)~(\ZNeg~b) \ra \tt{let } g,(u,v)) \coloneqq \tt{ggcd}_\PP~a~b~\\
&\quad \tt{ in} (\ZPos(g),~(\ZNeg(u),~\ZNeg(v))).
\end{align*}

with:

\[
\mathop{sgn}(z: \Z) = 
\left\{
\begin{array}{ll}
\phantom{-}1 & \text{if } z > 0, \\
\phantom{-}0 & \text{if } z = 0, \\
-1 & \text{if } z < 0.
\end{array}
\right.
\]
\end{definition}

\begin{lemma}[Correctness of \texttt{Zggcd}]
Let $a, b \in \Z$ be arbitrary integers. If 
\[
\texttt{Zggcd}(a, b) = (g, (a', b')),
\]
then the following equalities hold:
\[
a = g \cdot a' \quad \text{and} \quad b = g \cdot b'.
\]
\begin{proof}
TODO
\end{proof}
\end{lemma}

We can define the function  $\operatorname{Qred} :\Q \ra \Q$ \index{Qred} reduces a rational number to a canonical form by dividing both the numerator and the denominator by their greatest common divisor.
This canonical representative is unique for each rational equivalence class.

\begin{definition}[Qred]
\[
\operatorname{Qred}(q : \Q) \coloneqq 
\begin{aligned}[t]
  &\text{let } q_1 \coloneqq \operatorname{Qnum}(q), \\
  &\text{let } q_2 \coloneqq \operatorname{Qden}(q), \\
  &\text{let } (\_,(u,v)) \coloneqq \left( \operatorname{Zggcd}(q_1, \ZPos(q_2)) \right) \text{ in} \\
  &\quad u \,\#\, \operatorname{to\_pos}(v).
\end{aligned}
\]

with:

\[
\operatorname{to\_pos}(z) = 
\left\{
\begin{array}{ll}
p & \text{if } z = \operatorname{Zpos}~p, \\
\texttt{H} & \text{if } z = \operatorname{Zneg}~\_, \\
\texttt{H} & \text{if } z = \Z0.
\end{array}
\right.
\]
\end{definition}

We now establish two fundamental properties of $\operatorname{Qred}$: \emph{correctness}, which ensures that reduction preserves the value of a rational number,
and \emph{completeness}, which guarantees that equivalent rational numbers are reduced to the same canonical form.

\begin{lemma}[Correctness of Qred]
For any unreduced rational number $q: \Q$, we have $\operatorname{Qred}(q) =_{\Q} q$.
\begin{proof}
TODO
\end{proof}
\end{lemma}

\begin{lemma}[Completeness of Qred]
For any unreduced rational numbers $p\,q: \Q$, if $p =_\Q q$ then $\operatorname{Qred}(p) = \operatorname{Qred}(q)$. 
\begin{proof}
TODO
\end{proof}
\end{lemma}

Therefore, we define auxiliary operations, shown in \cref{fig:rational-sort}, whose results are reduced to canonical form using $\operatorname{Qred}$.

\begin{align*}
& p~+^r_\Q~q \is \operatorname{Qred}(p~+_\Q~q) \quad \text{(written infix)}, \\
& p~q-^r_\Q~q \is \operatorname{Qred}(p~-_\Q~q) \quad \text{(written infix)}, \\
& p~*_\Q~q \is \operatorname{Qred}(p~*_\Q~q) \quad \text{(written infix)}.
\end{align*}


\subsection{Encoding bitvector (WIP)}
\label{ssec:encoding-bv}

\begin{figure}
\begin{framed}
%************ Dependent pair **********************
% [a: Set] (p: τ a → Prop) inductive Σ : TYPE ≔
%     exist (x: τ a) : π (p x) → Σ p;
% symbol Sigma [a: Set]: (τ a → Prop) → Set;
% rule τ (Sigma $p)  ↪ Σ $p;
%*************************************************
\begin{align*}
&\Sigma : \forall a : \set{}, (\el{}~a \ra \prop): \type \\
&| exist : \Pi (a : \set{}), \prf (p~x) \ra \Sigma~p \\
&\\
& Sigma~[a: \set{}]: (\el{}~a \ra \prop) \ra \set{} \\
& \el{}~Sigma~p \re \Sigma~p \\
&\\
& s_1~[a: \set{}] [p:(\el{}~a \ra \prop)] (e: \Sigma~a~p): \el{}~a \\
& (exist~x~\_)~s_1 \re x\\
& s_2~[a: \set{}] [p:(\el{}~a \ra \prop)] (e: \Sigma~a~p): \prf{}(p~(e~s_1)) \\
& (exist~x~p)~s_2 \re p\\
\end{align*}

%************ bitvector ***************************
% injective symbol Fin (n: ℕ) ≔ Σ (λ x, istrue (x < n));
% injective symbol FinMk (n: ℕ) (m: ℕ) (isLT : π (m < n)): Fin n
%  ≔ @exist nat (λ x, istrue (x < n)) m isLT;
% symbol fin: ℕ →  Set;
% rule τ (fin $n) ↪ Fin $n;

% injective symbol BitVec n ≔ Fin (2 ^ n);
% symbol mkBv n v p : BitVec n  ≔ FinMk (2 ^ n) v p;
%*************************************************
\begin{align*}
& Fin~(n: \N) \coloneq \Sigma~(\lambda\,x, istrue(x < n)) \\
& FinMk~(n: \N) (m: \N) (islt: \prf (m < n)) : Fin~n \\
&\quad\is exist~(\lambda\,x, istrue(x <n))~m~islt\\
&\mathop{val}~[n]: \mathop{Fin} n \ra \N \is \lambda e, e~s\_1 \\
&\mathop{isLt}~[n] (f: \mathop{Fin} n): \prf (f~s_1 < n) \is f~s_2\\
&\\
& \hat{}: \N \ra \N \ra \N \qquad \text{(written inﬁx)}\\
& 0 ~\hat{}~ 1 \re 1 \N\\
& n ~\hat{}~ (m + 1) \re n * (n ~\hat{}~ m)\\
&\\
&BitVec~n \is Fin~(2~\hat{}~n) \\ 
& mkBv: \Pi(n: \N)(p: \prf~(istrue(n < 2~\hat{}~n))): BitVec~n\\
&\quad\is FinMk~(2~\hat{}~n)~n~p\\
&\\
&\mathop{to\_nat}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathbb{N} \\
&\,\mathop{to\_nat}\;n\;(\mathop{exist}(v,\_))\re v
\end{align*}
\end{framed}
\caption{Encoding bitvector}
\label{fig:bitvector-def}
\end{figure}

We interpret a bitvector $\mathop{BitVec}(w: \N)$ \index{$\mathop{BitVec}$} from the SMT logic \textbf{BV} as a number less than $2^w$  because we use the type $\mathop{Fin}$ as the internal representation of a bitvector as depicted in \cref{fig:bitvector-def}.
In particular, a $\mathop{Fin} n$ is a natural number $i$ with the constraint that $i < n$. It is the canonical type with $n$ elements. In the \cref{fig:bitvector-def}, we provide the definitions of $\mathop{Fin}$
which is a dependent pair type i.e. Sigma type ($\Sigma$), the definition of $\mathop{Fin} n$ and $\mathop{Bitvector} n$.

Alternative representations could include a vector of \B{},
formally $\mathop{BitVec}(w: \mathbb{N}) := \Sigma(\mathop{List\,\B})(\lambda(l: \mathop{List\,\B}),\mathop{length}l = w)$,
or a binary natural number encoding: $\mathop{BitVec}(w: \mathbb{N}) := \Sigma\,(\mathop{Bin\N})(\lambda (n:\mathop{Bin\N}), \mathop{size}\,n = w)$, where $\mathop{Bin\N}$
is an inductive type representing binary natural numbers greater than zero, built on top of $\mathbb{N}$.
However, like $\mathop{Fin}$, these structures are not currently available in Lambdapi's standard library.

We chose the $\mathop{Fin}$ representation over other possible encodings due to its relative efficiency.
If, in the future, Lambdapi's kernel adds support for efficient representations of natural numbers e.g.,
via overriding them with arbitrary-precision arithmetic libraries like GMP\footnote{\url{https://gmplib.org/}} bitvectors encoded with $\mathop{Fin}$ would likewise benefit from such optimizations.

We therefore chose to implement $\mathop{Fin}\,n$, as we believe it provides the most suitable and future-proof foundation for representing the $\mathop{BitVec}$ type,
particularly in light of potential enhancements to the kernel.


We recall that the constructor for bitvector in Alethe: $$\mathtt{bbT}\ \enum[n-1]{x}[][0]$$ with $x_i\in\{\bot,\top\}$, for $0\leq i< n$,
is the Boolean equivalent of the $i$-th bit of $x$ (from least to most significant). Thus $\enum[n-1]{x}[][0]$ is the Boolean bit-level interpretation corresponding to the bit-vector. 

\begin{example}[Bitvector construction]
The binary number $\#b0010$ is equivalent to:

\begin{lstlisting}[language=SMT]
(@bbT false true false false)
\end{lstlisting}
\end{example}

Because we encode \smtinline{Bool} terms as $\prop$, a list $\enum[n-1]{x}[][0]$ with $x_i \in {\bot, \top}$ is represented as a list of $\prop$ rather than elements of type $\mathbb{B}$.
To ensure that such a list is well-formed, we require a predicate that guarantees $x_i \in {\bot, \top}$ for each element.

\begin{lemma}[@bbT well-formed]
For any Boolean list $l : \mathbb{L}\,o$, if every element of $l$ is either $\top$ or $\bot$, then there exists a corresponding bitvector of $\mathop{size} l$ constructed by $\mathop{@bbT}$.
\label{lem:bbt}
\end{lemma}

We first define the function $\mathop{list2Nat}$, which computes the natural number corresponding to $\enum[n-1]{x}[][0]$
with $x_i \in {\bot, \top}$, and the function $\mathop{All}$, which defines a predicate requiring all elements of the list to satisfy a given property.
Briefly, the constructor $\Box$ of type $(\bb{L}\,a)$ represent the empty list of element of type $a$ that belongs to \set, and the constructor $x\,::\,xs$ add an element $(x: \el{} a)$ to a list $xs: \bb{L}a$.

\begin{definition}[bbT helper functions]
\begin{align*}
&\mathop{list2Nat}(\top \,::\, xs) \ra 2 * (\mathop{list2Nat}\,xs) + 1 \\
&\mathop{list2Nat}(\bot \,::\, xs) \ra 2 * (\mathop{list2Nat}\,xs) \\
&\mathop{list2Nat}(\Box) \ra 0
\end{align*}

\begin{align*}
&\mathop{All}\;p\;\Box \;\rightarrow\; \top \\
&\mathop{All}\;p\;(x \,\::\, l) \;\rightarrow\; (p\;x) \land \mathop{All}\;p\;l
\end{align*}
\end{definition}

Therefore, we can represent \cref{lem:bbt} as the constant given in \cref{def:eqbbt}.
To construct a bitvector from a list of \smtinline{Bool}, we must provide a proof that the list is well-formed.

\begin{definition}[Bitvector auxiliary constructor]
\begin{align*}
&\mathop{bbT}\,(l : \bb{L}\,o) : \prf (\mathop{All}\,(\lambda x.\; x = \top \lor x = \bot)\,l)\\
&\quad \ra \mathop{BitVec}(\mathop{size}\,l)
\end{align*}
\label{def:eqbbt}
\end{definition}


\subsubsection{Arithmetic}

The SMT-LIB language offers arithmetic operations on bitvectors, such as $\mathop{bvadd}$ and $\mathop{bvadd}$. 
Some of these operations are signed, while others are unsigned. In the implementation, bitvectors are represented as a wrapper around a Fin type with an appropriate bound.
Since $\mathop{Fin}$ itself wraps a natural number (\N), bitvector operations rely on corresponding functions and proofs defined over \N.

\begin{definition}[Bitvector arithmetic]
\begin{align*}
&\mathop{bvsub}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{sub}(2^n, x, y) \\
&\mathop{bvmul}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{mul}(2^n, x, y) \\
&\mathop{bvshiftl}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{shiftl}(2^n, x, y) \\
&\mathop{bvshiftr}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{shiftr}(2^n, x, y) \\
&\mathop{bvand}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{and}(2^n, x, y) \\
&\mathop{bvor}[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{or}(2^n, x, y)
\end{align*}
\end{definition}


\subsubsection{Bitwise Operators}


SMT-LIB define bitwise operators such as $\mathop{bvand}$ or $\mathop{bvlshr}$  (which shifts a bitvector to the right) for manipulating the individual bits of one or more bitvectors. 
 Following a similar strategy, we encoded these operations over \N and wrap the bitvector operations on them. To illustrate this approach, we focus on the $\mathop{bvand}$ operator.
We begin by defining its natural number analogue, $\mathop{land}$ with its correctness \cref{lem:correct-land}.

\begin{definition}[and operator for Nat]
We define a higher-order function \( \mathop{\mathrm{bitwise}} : (\mathbb{B} \ra \mathbb{B} \ra \mathbb{B}) \ra \mathbb{N} \ra \mathbb{N} \ra \mathbb{N} \ra \mathbb{N} \) by the following rewrite rules:
\begin{align*}
&\mathop{\mathrm{bitwise}}\,op\, 0\, a\, b \re 0 \\
&\mathop{\mathrm{bitwise}}\,op\, n{+}1\, a\, b \re \\
&\quad\left( \text{if } (\mathop{op}\,(\mathop{\mathrm{odd}}a)\, (\mathop{\mathrm{odd}}\,b)) 1\,0 \right) \\
&\quad+ 2 * \mathop{\mathrm{bitwise}}\,op\, n\, (\mathop{\mathrm{div2}}\,a)\,(\mathop{\mathrm{div2}}\,b)
\end{align*}
The auxiliaries functions \( \mathop{\mathrm{div2}} : \mathbb{N} \ra \mathbb{N} \) and the boolean \( \mathop{\mathrm{and}_\B} : \B \ra \B \ra \B \) are defined recursively as:
\begin{align*}
&\mathop{\mathrm{div2}}\,0 \re 0 \\
&\mathop{\mathrm{div2}}\,1 \re 0 \\
&\mathop{\mathrm{div2}}\,x{+}2 \re \mathop{\mathrm{div2}}\,x + 1 \\
&\\
&\mathop{\mathrm{and}_\B}(\mathrm{true},\, b) \re b \\
&\mathop{\mathrm{and}_\B}(b,\, \mathrm{true}) \re b \\
&\mathop{\mathrm{and}_\B}(\mathrm{false},\, \_) \re \mathrm{false} \\
&\mathop{\mathrm{and}_\B}(\_,\, \mathrm{false}) \re \mathrm{false}
\end{align*}
Then, we can define the natural number bolean and i.e. (\&\&) as:
\begin{equation*}
\&\&~(a\,b: \N): \N \is \mathop{bitwise}\,(and_\B)\,a\,a\,b \quad \text{(written infix)}
\end{equation*}
\end{definition}


\begin{lemma}[Correctness of Bitwise \&\&]
Let $n, m, i \in \N$. Then the $i$-th bit of the bitwise $\mathbin{\&\&}$ of $n$ and $m$ equals the conjunction of the $i$-th bits of $n$ and $m$, that is:
\[
\mathop{testbit} (n \mathbin{\&\&} m)~i = \mathop{andb}~(\mathop{testbit} n~i) (\mathop{testbit} m~i).
\]
with:
\begin{align*}
&\mathop{\mathrm{testbit}} : \N \ra \N \ra \B \\
&\mathop{\mathrm{testbit}}\,a,\,0 \re \mathop{\mathrm{odd}}\,a \\
&\mathop{\mathrm{testbit}}\,a,\,n{+}1 \re \mathop{\mathrm{testbit}}\,\mathop{\mathrm{div2}}(a),\, n
\end{align*}
\begin{proof}TODO\end{proof}
\label{lem:correct-land}
\end{lemma}

\begin{lemma}[Bitwise $\mathbin{\&\&}$ upper bound]
Let \( x, y, n : \N \), and suppose \( y < 2 \,\hat{}\, n \). Then:
\[
x \mathbin{\&\&} y < 2^n.
\]
\label{and_lt_two_pow}
\begin{proof} TODO \end{proof}
\end{lemma}

Finally, we can define the $\mathop{bvand}$ function.

\begin{definition}[Bitwise \emph{and} for bitvectors]
\begin{align*}
&\mathop{\mathrm{Fin.and}}~[n: \N]: \mathop{Fin} n \ra \mathop{Fin} n \ra \mathop{Fin} n\\
&\quad\is \lambda f1,\, \lambda f2,\, \mathop{\mathrm{FinMk}}~n~((\mathop{val} f1) \mathbin{\&\&} (\mathop{val} f2)) \\
&\quad (\mathop{and\_lt\_two\_pow}~(\mathop{val} f1)~(\mathop{val} f2)~n~(\mathop{isLt} f2)) \\
&\\
&\mathop{\mathrm{bvand}}~[n: \N]: \mathop{BitVec} n \ra \mathop{BitVec} n \ra \mathop{BitVec} n\\
&\quad\is \lambda x, \lambda y, \mathop{Fin.and}~(2~\hat{}~n)~x~y
\end{align*}
with $\mathop{and\_lt\_two\_pow}$ the constant for \cref{and_lt_two_pow}.
\end{definition}

\subsection{SMT-LIB helper operators distinct and ite}
\label{ssec:encoding-distinct-let-enc}

The SMT-LIB provides the operator \smtinline{(par (A) (distinct A A Bool :pairwise))}  denotes the function that
returns true iff its two arguments are not identical, and \smtinline{(par (A) (ite Bool A A A))} denotes the function that
returns its second argument or its third depending on whether its first argument is true or not.


\begin{definition}[Vectors and Distinctness Predicate encoding]
Let \( a : \mathop{\mathrm{Set}} \). We define the constant \( \mathop{\mathrm{Vec}}(a, n) \) inductively for \( n \in \N \) as:
\begin{align*}
&[a: \set] \mathop{\mathrm{Vec}}: \N \ra \type \\
&|\Box_\bb{V} : \mathop{\mathrm{Vec}}(a, 0) \\
&|\mathop{\mathrm{cons}}: \el\,a \ra \mathop{\mathrm{Vec}}(a, n) \ra  \mathop{\mathrm{Vec}}(a, n{+}1) \\
\end{align*}

We introduce the coding type for vector:
\begin{align*}
&\mathop{\mathrm{vector}}~(a: \set): \set \\
&\el (\mathop{\mathrm{vector}} a) \re \type
\end{align*}

We define the predicate \( \mathop{\mathrm{distinct}}: \Pi a,\, \Pi n \in \N,\, (\mathop{\mathrm{Vec}}\,a\,n) \ra \prop \) using the following rules:
\begin{align*}
&\mathop{\mathrm{distinct}}~\Box_\bb{V} \re \bot \\
&\mathop{\mathrm{distinct}}~(\mathop{\mathrm{cons}}(\_, \Box_\bb{V})) \re \top \\
&\mathop{\mathrm{distinct}}~(\mathop{\mathrm{cons}}(x,\, \mathop{\mathrm{cons}}(y,\, \Box_\bb{V}))) \re \neg (x = y) \\
&\mathop{\mathrm{distinct}}~(\mathop{\mathrm{cons}}(\_,\, \mathop{\mathrm{cons}}(\_,\, \mathop{\mathrm{cons}}(\_,\_)))) \re \bot
\end{align*}
\end{definition}

\begin{example}
\(
    \mathop{\mathrm{distinct}}~(\mathop{\mathrm{cons}}(1,\, \mathop{\mathrm{cons}}(2,\, \mathop{\mathrm{cons}}(3, \Box_\bb{V})))) \re \bot
\)
\end{example}

\begin{definition}[\texttt{ite}]
Let \( a: \set \) be a \set. We define a conditional expression:
\begin{align*}
\mathop{\mathrm{ite}} : \Pi [a: \set],\, \el\,o \ra \el\,a \ra \el\,a \ra \el\,a
\end{align*}

We also define the dependent eliminator:
\begin{align*}
&\mathop{\mathrm{ite\_ind}} : \Pi [a],\, \Pi (c : \el\,o)\, (t\, e : \el\,a)\, (p : \el\,a \ra \mathrm{Prop})\\
&\quad\left( \prf\,c \ra \prf(p~t) \right) \ra \\
&\quad\left( (\prf\,c \ra \prf\,\bot) \ra \prf(p~e) \right) \ra \\
&\quad\prf(p~(\mathop{\mathrm{ite}}~c~t~e)))
\end{align*}
\end{definition}
