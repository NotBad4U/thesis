
%*****************************************
\chapter{Encoding the logic of SMT in Lambdapi} \label{ch:encoding}
%*****************************************

We describe our embedding of the logic of SMT and Alethe into Lambdapi.
Our work applies to input problems expressed in the logics \texttt{UF}, \texttt{LIA}/\texttt{LA} and \texttt{BV} or their sub-logics.
We begin by detailing the encoding of the SMT-LIB sorts used in these logics, which is necessary for reconstructing their corresponding Alethe proofs.
We then present our method for translating these proofs.

\section{A Prelude Encoding for Alethe}
\label{sec:encoding-prelude}

\begin{definition}[Prelude Encoding]
\label{def:defuniv}
The signature $\Sigma$ of our encoding contains the following definitions and rewrite rules that we use to encode Alethe proofs:
\begin{align*}
&\set\index{\set}: \type & &\prop\index{\prop}: \type \\
&\index{\el{}} \el{}: \set \rightarrow \type  & &\index{\prf}\prf{} : \prop \rightarrow \type \\
&\mathop{\leadsto}\index{$\leadsto$}: \set \rightarrow \set \rightarrow \set \quad \text{(infix)} & &o: \set \\
&\el\,(x \leadsto y) \hookrightarrow \el\,x \rightarrow \el\,y & &\el\,o\index{o}  \hookrightarrow \prop
\end{align*}
\end{definition}

The notions of term, proposition, and proof are not primitive in \lpm.
We ﬁrst deﬁne a notion analogous to the predicate logic notion of term, to express the objects the theory speaks about, such as the natural number.
The constants \set{} and \prop{} in \cref{def:defuniv} are type universes ``à la Tarski'' \cite[\S Universes]{intuitype} in \lpm.
The type \set{} represents the universe of \textit{small types}, i.e.\ a subclass of types for which we can define equality.
SMT sorts are represented in \lpm{} as elements of type \set{}. Since elements of type \set{} are not types themselves, 
we also introduce a function $\el: \set \rightarrow \type$ that embeds the terms of type \set{} into terms of type \type.
Therefore, our function \el{} interprets SMT sorts as \type.
Thus, we represent the terms of sort \lstinline[language=SMT,basicstyle=\ttfamily\normalsize]|Bool| of SMT by elements of type $\el{}\,o$.
The constructor $\leadsto$ (written infix) is used to encode SMT functions and predicates.

Jus as \lpm{} does not contain a primitive notion for expressing the objects of the theory, it does not contain a primitive notion of proposition.
The constant \prop{} represents the universe of propositions. Predicate symbols are represented as constants of type $\set{} \ra \dots \ra \prop$ .
Similar to \set{}, elements of type \prop{} are not types themselves; they are mapped to types by the function $\prf{}: \prop \rightarrow \type$.
Drawing an analogy with the Curry-de-Brujin-Howard isomorphism \cite{curryhoward}, this function embeds propositions into types by mapping each proposition $A$ to the type $\prf\,A$, which represents its proofs.
However, the analogy is only partial in two important ways. First, the propositions themselves are not the types of their proofs: if $t$ is a proof of $A$, then it does not have the type $A$,
but the type $\prf\,A$. Second, the embedding is not surjective—meaning not all types correspond to proofs. For instance, neither \set{} nor \prop{} are themselves types of proofs. 

Consequently, a \emph{step} in an Alethe proof trace is represented as an inhabitants of type $\prf{}\,p$, for a suitable proposition $p$.

\section{Constructive connectives, quantifiers and classical facts}
\label{ssec:encoding-prop}

In our framework, we adopt the standard set of logical operators and axioms from intuitionistic logic.
However, in order to interface with SMT solvers—whose reasoning are based on classical logic, we extend our system with the law of excluded middle and propositional extensionality as an additional axioms.

\begin{definition}[Constructive connectives, quantifiers]
\begin{align}
& \top : \prop \\
& \bot : \prop \\
& \land : \prop \ra \prop \ra \prop \qquad \text{(written inﬁx)} \\
& \lor : \prop \ra \prop \ra \prop \qquad \text{(written inﬁx)} \\
& \Rightarrow : \prop \ra \prop \ra \prop \qquad \text{(written inﬁx)} \\
&  \prf\,(a \Rightarrow\,b) \re \prf\, a \ra \prf\,\,b \label{eq:imp}\\
& \neg a \is a \Rightarrow \bot \\
% & \mathop{\mathrm{xor}}~a~b \is (\neg a \land b) \lor (a \land \neg b) \\
& \forall : \Pi {[a: \set]}, (\el\, a \ra \prop) \ra \prop \label{eq:forall}\\
& \prf{}(\forall\,p) \re \Pi\, x, \prf{(p~x)}\\
& \exists : \Pi\, {[a: \set]}, (\el\, a \ra \prop) \ra \prop \\
& {=} : \Pi [a : \set], \el\, a \ra \el\, a \ra \prop \qquad \text{(written inﬁx)}
\end{align}
\end{definition}

According to the Curry-de Bruijn-Howard correspondence, a proof of $A \Rightarrow B$ should have the type $\prf\,(A \Rightarrow B)$.
However, such a proof actually has type $\prf\,A \ra \prf\,B$. This means that the types $\prf\,(A \Rightarrow B)$ and $\prf\,A \ra \prf\,B$ must be identiﬁed.
To achieve this, we introduce the rewriting rule \cref{eq:imp}, allowing $\prf\,(A \Rightarrow B)$ to be rewritten as $\prf\,A \ra \prf\,B$.

We cannot assign the type $\Pi : \type, (X \ra \prop) \ra \prop$ to the universal quantifier, because in \lpm{} there is no mechanism for quantifying over variables of type \type.
Instead, we assign the type $\Pi\,x:\set{},(\el\,x \ra \prop) \ra \prop$ to the generic universal quantiﬁer $(\forall)$ \cref{eq:forall}.
Thus, we will be able to quantify over SMT sorts that will be encoded as inhabit of type \set. Furthermore, the previously defined term $o: Set$, together with the rewrite rule $\el\,o\index{o}  \hookrightarrow \prop$
, enables quantification over propositions, rendering the universal quantifier impredicative.

\begin{example}[quantification over $\prop$ with $o$]
The eliminator for bottom can be formalized as:
\[ \bot_e : \prf\,(\bot \Rightarrow \forall (p: \el\,o), p) \]
\end{example}

Equality (=) over small types is parameterized over types $\el\,a$ for the type parameter $a : \set{}$.


\begin{definition} \label{def:eps}
We define the choice operator $\epsilon$ (\cite[\S 2.1]{alethespec}).
\begin{align}
& \epsilon: \Pi\, {[a: \set]}, (\el\,a \ra \prop) \ra \el\,a \\
& \epsilon_i: \Pi\, {[a: \set]}, \Pi (x : \el\,a), \Pi (P : \el\,a \ra \prop) \\
& \quad \ra \prf\,(P\,x) \ra \prf\, P\,(\epsilon\,P) \\
& \epsilon_{d}: \Pi\, {[a: \set]}, \Pi (P\,Q : \el\,a \ra \prop) \\
& \quad \ra \Pi\, x : \el\,a, \prf\,(P\,x = Q\,x) \ra (\epsilon \, P = \epsilon \, Q)
\end{align}
The intended interpretation for the $\epsilon$ operator is that $(\epsilon\,x,\, P~x)$ denotes some $x$ satisfying the predicate $P$, if there is one.
The characteristic proof rules for the $\epsilon$ operator are represented by the constants $\epsilon_i$ for proving a predicate $P\,(\epsilon\,P)$ by exhibiting a witness $x$ such that $P\,x$ is provable,
and $\epsilon_d$ that asserts that the epsilon operator assigns the same witness to equivalent predicates $P$ and $Q$.
\end{definition}

Overall, this corresponds to a shallow embedding, where the logical connectives in SMT are directly represented by their counterparts in Lambdapi.
SMT logic enjoys the property of propositional completeness (also referred to as \emph{propositional degeneracy}) asserting that:
 \[
  \forall p,(p = \top) \lor (p = \bot) 
\]
Moreover, propositionally equivalent formulas are equal.

\begin{definition}[Classical facts]
We introduce the classical axioms:
\begin{align*}
\texttt{em}:\ & \Pi\, [p: \prop], \prf\,(p \lor \neg p) \\
\texttt{prop\_ext}:\ & \Pi\, [p\,q: \prop], \prf\,(p \Leftrightarrow q ) \rightarrow \prf\,(p = q)
\end{align*}
\label{def:classical-facts}
\end{definition}

\section{Representing Linear Integer Arithmetic (\textbf{\uppercase{LIA}})}
\label{ssec:encoding-lia}

\begin{definition}[Encoding integers]\label{def:ints}
The definition we use of natural numbers and integers in Lambdapi follows a common encoding found in many other theories, including the one in the Rocq standard library \cite{Rocq-refman}.

\begin{align*}\label{eq:eq1}
&\N: \type & &\bb{P}: \type & &\Z: \type \\
&|~0: \N  & &|~\tt{H} : \bb{P} & &|~\ZO: \Z \\
&|~+\!1:\N \ra \N & &|~\tt{O}: \bb{P} \ra \bb{P} & &|~\ZPos: \bb{P} \ra \Z \\
& & &|~\tt{I}: \bb{P} \ra \bb{P} & &|~\ZNeg: \bb{P} \ra \Z \\
&\tt{nat}: \set & &\tt{pos}: \set & &\tt{int}: \set \\
&\el~\tt{nat} \re \N & &\el~\tt{pos} \re \bb{P} & &\el~\tt{int} \re \Z 
\end{align*}

Natural numbers are defined inductively with the two constructors $0$ and the the successor function $+\!1$ written postfix.
The type $\bb{P}$  is an inductive type representing strictly positive integers in binary form.
Starting from $1$ (represented by the constructor \tt{H}), one can add a new least significant digit via the constructor \tt{O} (digit 0) or the constructor \tt{I} (digit 1).
For example, we represent 5 (101b) as $\tt{I} (\tt{O} (\tt{H}))$. The type $\Z$ represents integers in binary form.
An integer is either zero (with constructor $\ZO$) or a strictly positive number $\ZPos$ (coded as a $\bb{P}$) or a strictly negative number $\ZNeg$.
To enable quantification over elements of these types, we introduce constants such as $\tt{int}:\set$ that represent codes for these types along with a rule for rewriting codes to their corresponding types, for example $\el~\tt{int} \re \Z$.
\end{definition}

We make use of Lambdapi's \lstinline[language=Lambdapi,basicstyle=\ttfamily\normalsize]|builtin| mechanism to enable decimal notation for numeric values, for instance, writing $2$ for $\ZPos (\mathop{\tt{O}} \tt{H})$ to convert natural representations of values into elements of $\Z$.

\begin{definition}[Integers operators]\label{def:arith-ops}
Arithmetic operations over these types are implemented using rewrite rules, which necessitates proofs of both confluence and termination.
We provide only the definitions of $(+)$ and $(*)$ over $\Z$:

\begin{align*}
&+: \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO +\, y \re y \\
& x + \ZO \re x \\
& (\tt{Zpos x}) + (\tt{Zpos y}) \re (\ZPos~(\tt{add}~x~y))  \\
& (\tt{Zpos x}) + (\tt{Zneg y}) \re (\tt{sub}~x~y)  \\
& (\tt{Zneg x}) + (\tt{Zpos y}) \re (\tt{sub}~y~x)  \\
& (\tt{Zneg x}) + (\tt{Zneg y}) \re \ZNeg~(\tt{add}~x~y)\\[1em]
&\tt{*} : \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO *~\_ \re \ZO \\
& \_ *~\ZO \re \ZO \\
& \ZPos x *~\ZPos y \re \ZPos (\tt{mul}~x~y) \\
& \ZPos x *~\ZNeg    y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZPos y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZNeg    y \re \ZPos (\tt{mul}~x~y) \\
\end{align*}
The definition of the auxiliaries functions $\kw{sub}$ and $\kw{mul}$ can be found in \cref{app:arith-def}.
\end{definition}

\begin{notation}
We will use the notation $+_\Z$ or $*_\Z$ to refer the operators defined in \cref{def:arith-ops} when the context need to be specified. 
\end{notation}

\begin{definition}[Inequalities operators for integer]\label{def:arith-inequalities-def}
We introduce inductive types \tt{Comp} \index{\tt{Comp}} and $\B$ representing comparison operators and Booleans.

\begin{align*}
&\tt{Comp}: \type{} & \B: \type{} \\
&|~\tt{Eq}: \tt{Comp} & |~\tt{true}: \B \\
&|~\tt{Lt}: \tt{Comp} & |~\tt{false}: \B \\
&|~\tt{Gt}: \tt{Comp} & \\
&\tt{comp}: \set & \tt{bool}: \set  \\
&\el{}~\tt{comp} \re \tt{Comp} & \el{}~\tt{bool} \re \B
\end{align*}


The function $\doteq$ compares two integers, relying on the auxiliary function $\texttt{cmp}$ to perform comparisons between strictly positive binary numbers.

% --- Comparison and Integer comparison ---
\[
\begin{array}[t]{l@{\hspace{4em}}l}
\begin{aligned}
&\doteq : \Z \ra \Z \ra \tt{Comp} \\
& \ZO \doteq \ZO \re \tt{Eq} \\
& \ZO \doteq \ZPos~\_ \re \tt{Lt} \\
& \ZO \doteq \ZNeg~\_ \re \tt{Gt} \\
& \ZPos~\_ \doteq \ZO \re \tt{Gt} \\
& \ZPos~p \doteq \ZPos~q \re \tt{cmp}~p~q \\
& \ZPos~\_ \doteq \ZNeg~\_ \re \tt{Gt} \\
& \ZNeg~\_ \doteq \ZO \re \tt{Lt} \\
& \ZNeg~\_ \doteq \ZPos~\_ \re \tt{Lt} \\
& \ZNeg~p \doteq \ZNeg~q \re \tt{cmp}~q~p
\end{aligned}
\\[3em]
\begin{aligned}
  &\tt{isGt} : \tt{Comp} \ra \B \\
  &\tt{isGt}~\tt{Eq} \re \tt{false} \\
  &\tt{isGt}~\tt{Lt} \re \tt{false} \\
  &\tt{isGt}~\tt{Gt} \re \tt{true}
\end{aligned}
\end{array}
\]

Based on this comparison mechanism, we define inequality operators over $\Z$ as binary predicates, by reducing them to the decidable comparison $\doteq$. They reduce to $\top$, $\bot$ (or negated).

\[
\begin{array}{l@{\hspace{4em}}l}
\begin{aligned}
  &\tt{isEq} : \tt{Comp} \ra \B \\
  &\tt{isEq}~\tt{Eq} \re \tt{true} \\
  &\tt{isEq}~\tt{Lt} \re \tt{false} \\
  &\tt{isEq}~\tt{Gt} \re \tt{false}
\end{aligned}
&
\begin{aligned}
  &\tt{isLt} : \tt{Comp} \ra \B \\
  &\tt{isLt}~\tt{Eq} \re \tt{false} \\
  &\tt{isLt}~\tt{Lt} \re \tt{true} \\
  &\tt{isLt}~\tt{Gt} \re \tt{false}
\end{aligned}
\\[3em]
\begin{aligned}
  &\tt{isGt} : \tt{Comp} \ra \B \\
  &\tt{isGt}~\tt{Eq} \re \tt{false} \\
  &\tt{isGt}~\tt{Lt} \re \tt{false} \\
  &\tt{isGt}~\tt{Gt} \re \tt{true}
\end{aligned}
&
\begin{aligned}
  &\tt{istrue} : \B \ra \prop \\
  &\tt{istrue}~\tt{true} \re \top \\
  &\tt{istrue}~\tt{false} \re \bot\\
  &\\
\end{aligned}
\end{array}
\]
% --- Inequalities relations ---
\noindent
\begin{align*}
&\leq: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, \neg (\tt{istrue}(\tt{isGt}(x \doteq y))) \\
&<: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, (\tt{istrue}(\tt{isLt}(x \doteq y))) \\
&\geq: \Z \ra \Z \ra \prop \coloneq \lambda x,\lambda y, \neg (x < y) \\
&>: \Z \ra \Z \ra \prop  \coloneq \lambda x,\lambda y, \neg (x \leq y)
\end{align*}
% }%
\end{definition}

\begin{example}[Inequality reduction]
For example,
\begin{align*}
  1 < 2
  &\ \re\ \tt{istrue}(\tt{isLt}(1 \doteq 2)) \\
  &\ \re\ \tt{istrue}(\tt{isLt}(\tt{Lt})) \\
  &\ \re\ \tt{istrue}(\tt{true}) \\
  &\ \re\ \top,
\end{align*}
with $1 = \ZPos~\tt{H}$ and $2 = \ZPos~(\tt{O}~\tt{H})$.
\end{example}

The SMT sort \smtinline{Int} is mapped to $\el~\texttt{int}$, and the arithmetic operations of SMT to their counterparts in the Lambdapi encoding.

\begin{notation}
We will refer to the rewrites rules of \cref{def:arith-ops} and \cref{def:arith-inequalities-def} as $\ra_\Z$ and $\ra_\bb{P}$ in the following sections.
\end{notation}

\begin{lemma}[Confluence of $\ra_\bb{Z}$ and $\ra_\bb{P}$]
\begin{proof}
CSI \cite{CSI} automatically proves the confluence of $\ra_\bb{Z}$ and $\ra_\bb{P}$.
% by giving the polynomial interpretation:
% \begin{align*}
% [\tt{succ}(x)] = 4*x & &[\tt{add}(x, y)] = 4 * x + 4 * y + 2  & &[ {\tt{H}} ] = 4 \\
% \end{align*}
\end{proof}
\label{lemma:confluenceZP}
\end{lemma}

\section{Representing Linear Arithmetic (\textbf{LA})}
\label{ssec:encoding-la}


% Rational numbers are formalized using a datatype called rat. This datatype is designed to represent rational numbers as fractions in their reduced form, ensuring mathematical precision and efficiency in proofs.
% The rat type is defined using a single constructor, Rat, which takes two arguments: an integer numerator and a positive integer denominator.
% The key aspect of this construction is the enforcement of the invariant that the denominator must always be positive and coprime with the numerator.
% This invariant guarantees that each rational number is represented uniquely, which simplifies comparisons and arithmetic operations.

% We define the rat type in Lambdapi is as follows:

SMT solver define the sort \smtinline{Real}, but in practice the reconstruction of Alethe proof with the logic \textbf{LA} only require the rational number (\Q) for most of the case.
In \cref{def:rat}, we follows the encoding of rational from Rocq \cite{Rocq-refman} \textsc{MathComp} library \cite{mathcomp}.
Rational numbers are represented as an inductive type with a single constructor $\kw{Rat}$, containing a pair of integers and a proof that they are coprime and that the second one is positive.
This invariant guarantees that each rational number is represented uniquely, which simplifies comparisons and arithmetic operations.

\begin{definition}[Rational]\label{def:rat}
We first define the boolean predicate of being \kw{coprime}. Two integers a and b are coprime if the only positive integer that is a divisor of both of them is $1$.
\begin{equation*}
\kw{coprime} (a~b: \el\,\kw{int}): \B \is  \kw{isEq}~(\kw{Zgcd}~|a|~|b| \doteq 1)
\end{equation*}
The function $\kw{Zgcd}$ returns the Greatest Common Divisor $(\mathop{GCD})$ between two terms of type $\Z$, and $|\_|$ is the absolute value function.
We then defines the inductive type:
\begin{align*}
& \Q: \type \\
& |~\kw{Rat}: \Pi\,[a~b: \el\,\kw{int}],\\
& \quad \prf\, (\kw{istrue} (\kw{isLt} (0 \doteq b) \mathbin{and} \kw{coprime}\,a\,b)) \ra \Q \\[1em]
&\kw{rat}: \set{} \\
&\el~\kw{rat} \re \Q
\end{align*}
\end{definition}

In the Following, we will use the notation $\frac{n}{d}$ to denotes a fractional pair of integers.


\begin{example}
We can define $\frac{0}{1}$ as $(\kw{Rat}~0~1~\top_i)$ since:
\[
\prf\, \kw{istrue} (\kw{isLt} (0 \doteq 1) \mathbin{and} \kw{coprime}\,0\,1) \equivL \prf\,\top 
\]
with $\top_i : \prf\,\top$.
\end{example}

This \emph{canonical representation} ensures uniqueness of representation (no two different pairs represent the same rational) and yields a decidable equality.
Next, we will define a constructor function that will compute reduced fraction from a pair of integers.
We first define the product type in \cref{def-product}, with the constant $\times: \set \ra \set \ra \set$.

\begin{definition}[Product type]\label{def-product}
\begin{align*}
&\textbf{Non dependent product type:} \\
&\quad \times : \text{Set} \to \text{Set} \to \text{Set} \quad \textit{(written infix)} \\
&\textbf{Pairing symbol:} \\
&(\mathbin{‚}) [a~b] : \el a \ra \el b \ra \el (a \times b)\\[1em]
&\textbf{Projections (written postfix):}  \\
&\quad {}_1 : \el\, (a \times b) \ra \el\, a \quad \text{with rewrite rule } (x \mathbin{‚} \_)_1 \re x \\
&\quad {}_2 : \el\, (a \times b) \ra \el\, b \quad \text{with rewrite rule } (\_ \mathbin{‚} y)_2 \re y
\end{align*}
\end{definition}

The pairing constructor is denoted by $(‚)$ (a comma-like symbol), which takes two terms $x : \el\,a$ and $y : \el\, b$ and produces a term $x \mathbin{‚} y : \el (a \times b)$.
Two projection symbols ${\_}_1$ and ${\_}_2$ extract the first and second components of a pair, respectively.

The constructor function $\kw{fracq}$, in \cref{def:fracq-def}, normalizes any integer pair to its reduced form and a proof that the invariant holds, so if two inputs represent the same rational number, 
the function $\kw{fracq}$ returns exactly the same $\Q$ value (with identical numerator/denominator and proof) e.g. $\kw{fracq} (2,4) \equivL \kw{fracq} (3,6)$.

\question{ac}{Should I go so much into details or just mention fracq without giving its def?}
\begin{definition}[fracq constructor]\label{def:fracq-def}
\begin{align*}
& \kw{fracq} : \Z \ra \Z \ra \Q \\
& \kw{fracq}~\_~Z0 \re \kw{Rat}~0~1~(\kw{fracq\_subproof}~1~0) \\
& \kw{fracq}~n~d \re \mathop{let} r \is \kw{fracq\_subdef}~(n, d)~\mathbin{in}\\
& \qquad \qquad \kw{Rat}~r_1~r_2~(\kw{fracq\_subproof}~n~d) \\
\end{align*}
The implementation involves several helper functions and lemmas:
\begin{align*}
&\kw{fracq\_subproof} (x~y : \el~int): \\
& \quad \mathop{let} p \is (\kw{fracq\_subdef}~x~y)~ \mathbin{in}\\
& \qquad \prf (\kw{istrue} (\kw{isLt} (0 \doteq p\,{}_2) \mathbin{and} \kw{coprime}\,p\,{}_1\,p\,{}_2)) \\
&\text{and}\\
& \kw{fracq\_subdef} (x : \el (\kw{int} \times \kw{int})): \el (\kw{int} \times \kw{int}) \\
& \kw{fracq\_subdef}~(x, y) \re\\
& \quad \kw{if}~(\kw{isLt} (0 \doteq y) \mathbin{and} \kw{coprime}\,x\,y)\\
& \quad \mathop{then}~(x,y) \\
& \quad \mathop{else}~\mathop{if}~(y \neq 0)~\mathop{then} \\
& \qquad \mathop{let}~g \is \kw{Zgcd}(x,y)~ \mathbin{in}  \\
& \qquad\qquad (-1^{(IsLt0(x) + IsLt0(y)))} * \mathop{div}~|x|~g‚ \mathop{div}~|y|~g) \\
& \qquad \mathop{else}~(0,1) \\
\end{align*}
Where
\begin{itemize}
\item $\kw{fracq\_subproof}$ :  A lemma proving that the result of:\\
  $\kw{fracq\_subdef}$ satisfies the required invariant,
\item $\kw{fracq\_subdef}$ : A helper function that computes the fractional part of a pair of integers.
It returns a positive denominator, and a sign encoded in the numerator. If the numerator is zero, the pair is replaced by $(0, 1)$.
Following the approach of \textsc{MathComp}, we imposes a computational normalization convention: whenever an invalid pair $(n, 0)$ is encountered, it is systematically mapped to a default rational $\frac{0}{1}$.
This ensures the normalization operation is total, deterministic, and easily computable without special case-handling downstream.

\item $\kw{IsLt0}: \Z \ra \Z$, a function that return $1$ if the argument is lower than $0$, and $0$ otherwise.
\end{itemize}
\end{definition}

Finally, we can then define the regular arithmetic operator over $\Q$ by using the $\kw{fracq}$ function.
For example, we define the addition $+_\Q$ symbol as follows:

\begin{align*}
&+_\Q : \Q \ra \Q \ra \Q \quad (\textit{written infix})\\ 
&(\kw{Rat}~n_1~d_1~\_) +_\Q (\kw{Rat}~n_2~d_2~\_) \re\\
&\qquad \kw{fracq}~(n_1 *_\Z d_2 +_\Z n_2 *_\Z d_1) (d_1 *_\Z d_2) \\
\end{align*}


\section{Encoding bitvectors (\textbf{\uppercase{BV}})}
\label{ssec:encoding-bv}

We interpret the sort of bitvectors \smtinline{ (_ BitVec w)} from the SMT logic \textbf{BV} as a number less than $2^w$. We use the type $\mathop{Fin}$ as the internal representation of a bitvector
that represents the set of natural numbers less than an arbitrary $w$. We first define the dependent pair type in Lambdapi necessary to encode \kw{Fin} using an inductive encoding.

\begin{definition}[Dependent pair]\label{dep-pair-def}
The type $\Sigma~p$ parameterized by a predicate $p$ on a type $\el\,a$, represents a dependent pair consisting of an element $x : \el\,a$ and a proof that $p~x$ holds.

\begin{align*}
&\Sigma : \forall a : \set{}, (\el{}~a \ra \prop): \type \\
&|~exist : \Pi (a : \set{}), \prf (p~x) \ra \Sigma~p \\
&\\
& Sigma~[a: \set{}]: (\el{}~a \ra \prop) \ra \set{} \\
& \el{}~Sigma~p \re \Sigma~p \\
&\\
& \textcolor{red}{s_1}~[a: \set{}] [p:(\el{}~a \ra \prop)] (e: \Sigma~a~p): \el{}~a \\
& (exist~x~\_)~\textcolor{red}{s_1} \re x\\
& s_2~[a: \set{}] [p:(\el{}~a \ra \prop)] (e: \Sigma~a~p): \prf{}(p~(e~\textcolor{red}{s_1})) \\
& (exist~x~p)~s_2 \re p\\
\end{align*}
The projections from this dependent pair are defined through the symbols $s_1$ and $s_2$, corresponding respectively to the first and second components of the pair.
The rewrite rule for $s_1$ extracts the value $x$ from a term of the form $\kw{exist}~x~\_$, while the rule for $s_2$ retrieves the proof that $(p~x)$ holds.
\end{definition}

\begin{definition}[Fin]\label{def:fin-def}
The type $\mathop{Fin} n$ is the type of natural numbers $i$ with the constraint that $i < n$.
It is the canonical type with $n$ elements.
\begin{align*}
& Fin~(n: \N) \coloneq \Sigma~(\lambda\,x, istrue(x < n)) \\
& FinMk~(n: \N) (m: \N) (islt: \prf (m < n)) : Fin~n \\
&\quad\is exist~(\lambda\,x, istrue(x <n))~m~islt\\
&\mathop{val}~[n]: \mathop{Fin} n \ra \N \is \lambda e, e~s\_1 \\
&\mathop{isLt}~[n] (f: \mathop{Fin} n): \prf (f~s_1 < n) \is f~s_2\\
\end{align*}
\end{definition}

\begin{definition}[Bitvector]\label{def:bv-def}
We define bitvectors as natural numbers bounded by powers of two and modular arithmetic representation.
We first introduce an infix exponentiation function $\_\,\hat{}\,\_$ on $\N$.
Using this, we define the type $BitVec~n$ as the finite type $Fin~(2~\hat~n)$ (written $Fin~2^n$), representing the set of natural numbers strictly less than $2^n$.
\begin{align*}
& \hat{}: \N \ra \N \ra \N \qquad \text{(written inﬁx)}\\
& 0 ~\hat{}~ 1 \re 1 \N\\
& n ~\hat{}~ (m + 1) \re n * (n ~\hat{}~ m)\\[1em]
&BitVec~n \is Fin~(2^n) \\ 
& mkBv: \Pi(n~m: \N)(p: \prf~(istrue(n < 2^n))): BitVec~n\\
&\quad\is FinMk~(2^n)~m~p
\end{align*}
Each bitvector of size $n$ is thus a natural number modulo $2^n$, capturing the behavior of (unsigned) integers with $n$ bits.
The function $mkBv$ then takes a size $n: \N$, an element $m$, and a proof $p$ that $m < 2^n$, and returns a bitvector of type $BitVec~n$.
Internally, this is constructed using $FinMk$, the constructor for the finite type $Fin~(2^n)$, ensuring that only values within the correct range can inhabit the bitvector type. 
\end{definition}

Alternative representations could include a vector of \B{},
formally $\mathop{BitVec}(w: \mathbb{N}) := \Sigma(\mathop{List\,\B})(\lambda(l: \mathop{List\,\B}),\mathop{length}l = w)$,
or a binary natural number encoding: $\mathop{BitVec}(w: \mathbb{N}) := \Sigma\,(\mathop{Bin\N})(\lambda (n:\mathop{Bin\N}), \mathop{size}\,n = w)$, where $\mathop{Bin\N}$
is an inductive type representing binary natural numbers greater than zero, built on top of $\mathbb{N}$.
However, like $\mathop{Fin}$, these structures are not currently available in Lambdapi's standard library.
We chose the $\mathop{Fin}$ representation over other possible encodings due to its relative efficiency.
If, in the future, Lambdapi's kernel adds support for efficient representations of natural numbers e.g.,
via overriding them with arbitrary-precision arithmetic libraries like GMP\footnote{\url{https://gmplib.org/}} bitvectors encoded with $\mathop{Fin}$ would likewise benefit from such optimizations.
We therefore chose to implement $\mathop{Fin}\,n$, as we believe it provides the most suitable and future-proof foundation for representing the $\mathop{BitVec}$ type,
particularly in light of potential enhancements to the kernel.


We recall that the constructor for bitvector in Alethe: $$\mathtt{bbT}\ \enum[n-1]{x}[][0]$$ with $x_i: \B$, for $0\leq i< n$,
is the Boolean equivalent of the $i$-th bit of $x$ (from least to most significant). Thus $\enum[n-1]{x}[][0]$ is the Boolean bit-level interpretation corresponding to the bit-vector. 

\begin{example}[Bitvector construction]
The binary number $\#b0010$ is equivalent to:

\begin{lstlisting}[language=SMT]
(@bbT false true false false)
\end{lstlisting}
\end{example}

\begin{definition}[bbT Alethe constructor]
The function \kw{bbT} maps a list of Boolean values ($\bb{L}~\kw{bool}$) to a bitvector whose size is determined by the length of the list.
\begin{equation*}
\kw{bbT} : \bb{L}~\kw{bool} \ra BitVec~(\kw{size}~l)
\end{equation*}
\end{definition}

\subsection{Bitvectors arithmetic}

The SMT-LIB language offers arithmetic operations on bitvectors, such as $\mathop{bvadd}$. 
Some of these operations are signed, while others are unsigned. In the Lambdapi representation, bitvectors are represented as a wrapper around a $Fin$ type with an appropriate bound.
Since $\mathop{Fin}$ itself wraps a natural number (\N), bitvector operations rely on corresponding functions and proofs defined over \N.
Arithmetic functions on bitvectors return results modulo the size of the bitvector, ensuring that computations wrap around according to the fixed width.
In order to illustrate the principle, we provide the definition of $\mathop{bvadd}$ in \cref{def:bv-add-def}.

\begin{definition}[Bitvector addition]\label{def:bv-add-def}
\begin{align*}
&\mathop{bvadd}\,[n : \mathbb{N}] : \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \ra \mathop{BitVec}(n) \\
&\quad\coloneq\; \lambda x, \lambda y, \; \mathop{Fin.add}~2^n~x~y \\
&\mathop{Fin.add}~: \mathop{Fin}~n \ra \mathop{Fin}~n \ra \mathop{Fin}~n \\
&\mathop{Fin.add}~: (\mathbin{exist}~x~p_x) (\mathbin{exist}~y~p_y) \\
&\re \mathop{FinMk}~n~((x + y) \mathbin{mod} n)~(modulo\_lt~(x * y)~x~n~p_x)
\end{align*}
The operator $\mathbin{mod}$ implement the modulo function for natural numbers and the lemma $modulo\_lt$
show that for any $x * y$ and $x$, if $x * y < n$, then $x \mathbin{\%} n < n$.
\end{definition}


\subsection{Bitwise Operators}

SMT-LIB define bitwise operators such as $\mathop{bvand}$ or $\mathop{bvlshr}$  (which shifts a bitvector to the right) for manipulating the individual bits of one or more bitvectors. 
Following a similar strategy, we encoded these operations over $\N$ and wrap the bitvector operations on them. We details our approach in \cref{app:bf-defs}.

\section{SMT-LIB helper operators}
\label{sec:encoding-helper-operator}

SMT-LIB provides the operator \smtinline{(par (A) (distinct A A Bool :pairwise))} that denotes the function that
returns true if its two arguments are not identical as defined in \cref{tab:distinct-spec}, and \smtinline{(par (A) (ite Bool A A A))} denotes the function that
returns its second argument or its third depending on whether its first argument is true or not.

\begin{table}
\caption{Specification of the \tt{distinct\_elim}rule in Alethe.}
\begin{tabular}{@{}ll@{}}
\multicolumn{2}{@{}l@{}}{\textbf{Rule 93:} R = \tt{distinct\_elim}} \\[0.5em]
\multicolumn{2}{@{}l@{}}{This rule eliminates the \tt{distinct} predicate.} \\
\multicolumn{2}{@{}l@{}}{When arguments are type \textbf{Bool}:} \\[0.5em]

\textit{i.} $\Gamma \vdash \ (\mathsf{distinct}\ \varphi\ \psi) \approx \lnot(\varphi \approx \psi)$ & \tt{R} \\[0.3em]
\textit{i.} $\Gamma \vdash \ (\mathsf{distinct}\ \varphi_1\ \varphi_2\ \varphi_3\ \ldots) \approx \bot$ & \tt{R} \\[0.8em]

\multicolumn{2}{@{}l@{}}{For all other sorts the rule is} \\[0.5em]
\textit{i.} $\Gamma \vdash \ (\mathsf{distinct}\ t_1 \ \ldots \ t_n) \approx \bigwedge_{i=1}^{n} \ \bigwedge_{j=i+1}^{n} \ t_i \neq t_j$ & \texttt{R}
\end{tabular}
\label{tab:distinct-spec}
\end{table}

\begin{definition}[Distinctness predicate]
We encode the distinct parameter of SMT by introducing a predicate over dependent vectors,
since both the size of the collection and the type of its elements influence how the predicate is computed.
Let \( a : \set \), we define the constant \( \mathop{\mathrm{Vec}}~a~n \) inductively for \( n : \N \) as:
\begin{align*}
&[a: \set] \mathop{\mathrm{Vec}}: \N \ra \type \\
&|~\Box_\bb{V} : \mathop{\mathrm{Vec}}\,a\, 0 \\
&|~\mathbin{::}_\bb{V}\,[n:\N]: \el\,a \ra \mathop{\mathrm{Vec}}\,a\,n \ra  \mathop{\mathrm{Vec}}\,a\,(n +1) \quad (\text{infix})\\
&\mathop{\mathrm{vector}}: \set \ra \N \ra \set \\
&\el~(\mathop{\mathrm{vector}}~a~(n: \N)) \re \mathop{\mathrm{Vec}}~a~n \\[1em]
& \kw{distinct}~[a: Set] [n: \N] : \kw{Vec}~a~n \ra \prop 
\end{align*}
\end{definition}

\begin{definition}[Distinctness eliminator]
To implement the behavior specified in \cref{tab:distinct-spec}, we formalize the elimination of distinct through a series of rewriting rules.
\begin{align*}
&\mathop{\mathrm{distinct}}~ \mathbin{\_}~\Box_\bb{V} \re \bot \\
&\mathop{\mathrm{distinct}}~\mathbin{\_}~ (x \mathbin{::}_\bb{V} \Box_\bb{V}) \re \top \\
&\mathop{\mathrm{distinct}}~\mathbin{\_}~ (x \mathbin{::}_\bb{V} y \mathbin{::}_\bb{V}  \Box_\bb{V}) \re \neg (x = y) \\
&\mathop{\mathrm{distinct}}~o~(x \mathbin{::}_\bb{V} y \mathbin{::}_\bb{V} z \mathbin{::}_\bb{V} tl)))) \re \bot \\
&\mathop{\mathrm{distinct}}~\_~(x \mathbin{::}_\bb{V} y \mathbin{::}_\bb{V} tl \mathbin{::}_\bb{V})))) \re \neg (x = y) \land \kw{distinct}~tl
\end{align*}

The first two rules capture the base cases: a \(\mathop{\mathrm{distinct}}\) check on an empty vector returns $\bot$, while a vector containing a single element trivially returns $T$.
The third rule handles the case of two elements, reducing to the negation of their equality.
For longer vectors, the fourth rule reflects the immediate elimination to  $\bot$ when parameter are type $\prop$ (\smtinline{Bool}),
while the final rule encodes the recursive elimination for others type than $\prop$. It process by requiring that the head element differs from the second and that the 
\(\mathop{\mathrm{distinct}}\) property holds for the remaining tail.
\end{definition}

\begin{example}
\(
    \mathop{\mathrm{distinct}}~(\bot \mathbin{::}_\bb{V} \top \mathbin{::}_\bb{V} \top \mathbin{::}_\bb{V} \Box_\bb{V}) \re \bot
\)
and
\(
    \mathop{\mathrm{distinct}}~(\top \mathbin{::}_\bb{V} \bot \mathbin{::}_\bb{V} \Box_\bb{V}) \re \neg (\top = \bot).
\)
\end{example}

\begin{definition}[\texttt{ite}]
We define a conditional expression:
\begin{align*}
\mathop{\mathrm{ite}} : \Pi [a: \set],\, \prop \ra \el\,a \ra \el\,a \ra \el\,a
\end{align*}
This conditional expression has the particularity that its condition is of type $\prop$ and not in \B.
We also define the induction principle:
\begin{align*}
&\mathop{\mathrm{ite\_ind}} : \Pi [a],\, \Pi (c : \el\,o)\, (t\, e : \el\,a)\, (p : \el\,a \ra \mathrm{Prop})\\
&\quad\left( \prf\,c \ra \prf(p~t) \right) \ra \\
&\quad\left( (\prf\,c \ra \prf\,\bot) \ra \prf(p~e) \right) \ra \\
&\quad\prf(p~(\mathop{\mathrm{ite}}~c~t~e)))
\end{align*}
\end{definition}

\section{Encoding clauses}

Alethe distinguishes between clauses that appear in steps, such as \colorbox{green!30}{(cl~$l_1 \dots l_n$)} in \cref{eq:step}, and ordinary disjunction \cite[\S 4]{alethespec}.
The syntax for clauses uses the \textcolor{purple}{\texttt{cl}} operator, while disjunction is represented as the standard SMT-LIB \textcolor{purple}{\texttt{or}}.
Alethe identifies a clause as a set of literals. As mentioned in \cref{ch:alethe}, Alethe identifies clauses that differ only in the order of literals. In particular, note that the ``literals'' appearing in clauses may actually be arbitrary formulas in Alethe.
It provides the \kw{or} rule for converting disjunctions into clauses:
\[
\begin{matrix*}[l]
  i. & \triangleright & \varphi_1 \lor \dots \lor \varphi_n  & (\dots) \\
  j. & \triangleright & (\texttt{\textcolor{purple}{cl}}~\varphi_1 \dots \varphi_n)  & (\kw{or}~i)[] \\
\end{matrix*}
\]

\begin{remark}[Lack of Structural Canonical Form in Disjunctive Clauses]
By interpreting a clause as a disjunction, a clause $cl~(l_1~l_2~l_3~l_4)$ will be then translated into $l_1 \lor (l_2 \lor (l_3 \lor l_4))$.
 Therefore, the concatenation of two clauses (what is happening in the conclusion of \texttt{resolution}) need not unify with the translated clause of the step. For example, taking 3 arbitrary steps:

\begin{itemize}
    \setlength{\itemsep}{5pt}
    \setlength{\parskip}{0pt}
    \item[] $A.~\triangleright~(\text{cl}~\textcolor{purple}{x_1}~\textcolor{blue}{x_2~x_3}) \quad (\dots)[\dots]$
    \item[] $B.~\triangleright~ (\text{cl}~\textcolor{purple}{\neg x_1}~\textcolor{orange}{y_2}~\textcolor{orange}{y_3}) \quad  (\dots)[\dots]$
    \item[] $C.~\triangleright~(\text{cl}~\textcolor{blue}{x_2~x_3}~\textcolor{orange}{y_2~y_3}) \quad (\texttt{resolution A B})[(\textcolor{purple}{x_1}~\texttt{true})]$
\end{itemize}

Interpreting a clause as a disjunction, we obtain a concatenated form such as $((\textcolor{blue}{x_2} \lor \textcolor{blue}{x_3}) \lor (\textcolor{orange}{y_2} \lor \textcolor{orange}{y_3}))$.
This aligns with the classical formulation of the \texttt{resolution} inference rule, expressed as $x \lor Y;\ \neg x \lor Z \vdash Y \lor Z$.
However, in {\lpm} $((\textcolor{blue}{x_2} \lor \textcolor{blue}{x_3}) \lor (\textcolor{orange}{y_2} \lor \textcolor{orange}{y_3})) \nequiv_{\beta\Sigma} (\textcolor{blue}{x_2} \lor (\textcolor{blue}{x_3} \lor (\textcolor{orange}{y_2} \lor \textcolor{orange}{y_3})))
\nequiv_{\beta\Sigma} (((\textcolor{blue}{x_2} \lor \textcolor{blue}{x_3}) \lor \textcolor{orange}{y_2}) \lor \textcolor{orange}{y_3})$ , even though these forms are semantically identical.

Additionally, if the pivot does not occur at the head of the clause, contrary to the expectation of the resolution rule,
which requires the pivot to be in the leading position. As a result, resolving clauses requires reasoning modulo associativity and commutativity.
To address the associativity issue, we propose a canonical representation for clauses.
For commutativity, we will show in \cref{ssec:refl-reso} that permuting two clauses preserves their semantics, and thus they can be regarded as identical.

\end{remark}

\begin{definition}[Clause encoding]\label{def:encoding-clause}
We define the type $\kw{Clause}$ to represent an Alethe clause as a list of propositions, thereby ensuring a canonical form.
\begin{align*}
&\texttt{Clause}: \type \\
&\nil: \texttt{Clause} \\
&\veedot: \prop \ra \texttt{Clause}  \ra \texttt{Clause}
\end{align*}
The constructor $\veedot$ prepends an element to a list, and $\nil$ denotes the empty list.
\end{definition}

\begin{definition}[Concatenation of clause]
The operator $\pp$ is used to concatenate lists. 
\begin{align*}
& \pp: \texttt{Clause} \ra \texttt{Clause} \ra \texttt{Clause} \\
& \nil \mathop{\pp} x \re x \\
& (x \veedot y) \mathop{\pp} z \re x \veedot (y \mathop{\pp} z)
\end{align*}
\end{definition}

\begin{definition}[Proof on \kw{Clause}]
Clauses are logically interpreted as disjunctions via the function $\cal{F}$, defined through rewriting rules. For convenience, we also introduce the predicate $\pid$, which asserts the provability of a clause.
\begin{align*}
& \cal{F}: \texttt{Clause} \ra \prop \\
& \cal{F}~\nil \re \bot\\
& \cal{F}~(x \veedot y) \re x \lor (\cal{F}~y) \\
& \pid (c : \texttt{Clause}) \coloneqq \prf\,(\cal{F}~c)
\end{align*}
\end{definition}

We can now prove the equivalence between clause and disjunction.

\begin{lemma}[Clause elimination]\label{lemma:clause-elim}
For any $p \colon \prop$ and $q,r \colon \texttt{Clause}$, If $\pid (p \veedot q)$ and $(\pid (p \veedot \nil) \ra  \pid r)$ and $(\pid q \ra  \pid r)$ then $\pid r$.
\end{lemma}
\begin{proof}
Since the hypothesis $\pid (p \veedot q)$ is equivalent to $\prf\,(p \lor \cal{F}\,q)$, we apply the classic disjunction elimination rule.
Then we can conclude $\prf\,p \ra \prf\,(\cal{F}\,r)$ wih the hypothesis $\pid (p \veedot \nil) \ra  \pid r$, and we can conclude $\prf\,(\cal{F}\,q) \ra \prf\,(\cal{F}\,r)$
with the hypothesis $\pid q \ra  \pid r$.
\end{proof}

\smallskip

\begin{lemma}[Concatenation is disjunction]\label{lemma:clause-equiv-disj}
For any two clauses $a\,b$, the equivalence $\prf\,(\cal{F}(a~\pp~b)) \Leftrightarrow \prf\,(\cal{F}\,a \lor \cal{F}\,b)$ holds.
\end{lemma}
\begin{proof} By induction on $a$.
  \begin{itemize}
    \item For the base case $a = \nil$ we must show that
    \[
        \prf\, (\cal{F} (\nil\, \pp \, b)) \Leftrightarrow \prf\, (\cal{F}\,\nil \lor \cal{F}\,b)
    \]
    The implication ``$\Rightarrow$'' is trivial because $\nil\,\pp\,b$ rewrites to $b$. The implication ``$\Leftarrow$'' is proved using the standard elimination rule $\lor_e$ for disjunction, which requires proving $\prf\,(\cal{F}\,\nil) \ra \prf\,(\cal{F}\,(\nil\,\pp\,b))$ as well as $\prf\,(\cal{F}\,b) \ra \prf\,(\cal{F}\,(\nil\,\pp\,b))$. Both proofs are immediate since $\cal{F}\,\nil$ rewrites to $\bot$ and $\nil\,\pp\,b$ rewrites to $b$.
    \item For the case $a = h \veedot tl$ we may use the induction hypothesis $\prf\,(\cal{F}\, (tl\, \pp\, b)) \Leftrightarrow \prf\,(\cal{F}\,tl \lor \cal{F}\, b)$. The conclusion is then easy to prove based on the rewriting rules for the operators $\cal{F}$ and $\pp$, together with associativity of $\lor$.
    \end{itemize}
\end{proof}
