%*****************************************
\chapter{Correctness of the translation}\label{ch:soundness}
%*****************************************

An Alethe proof trace is a non-empty list $[c_1, \dots, c_n]$ of steps such that $c_n$ derives the empty clause: \smtinline{(cl)}.
Moreover, the justification of every step may only refer to earlier steps, such that the proof trace can be represented as a directed acyclic graph.
We recall the definition of a well-formed Alethe proof trace \cite[Def.\ 7.2]{alethespec}.

\smallskip 

Proving correctness of the translation amounts to showing that any valid Alethe proof trace is translated into a Lambdapi proof of the empty clause: $\prfcl\, \nil$.
% This follows from the following theorem for proof traces containing the Alethe commands \kw{assume}, \kw{equiv\_pos2}, \kw{cong}, \kw{resolution}, \kw{subproof}, \kw{bind}, and \kw{sko\_forall}.

We first recall that a \emph{valid} Alethe proof (\cref{def:valid-alethe-proof}) is a finite trace of proof steps where each clause is justified either by an inference rule or by reference to previously established clauses.
Validity requires that the trace is well-formed (\cref{def:well-formed-alethe}), in the sense that the rule applied at each step is among the supported Alethe rules, that all dependencies point to earlier steps in the trace, and that the conclusion clause is exactly the one prescribed by the semantics of the rule.
In this way, a valid proof ensures that every clause in the trace is correctly derived from earlier clauses or assumptions, so that the final clause faithfully represents the logical consequence of the whole derivation.

\begin{theorem}[Correctness of reconstruction]\label{theorem:soundness}
  For any valid Alethe proof trace prefix:
  \[
    P = [c_1, \dots, c_i]
  \]
  , and $\mathcal{C}(c_i)$ is \emph{well-formed}. Furthermore, if
  \[
    c_i.\,\Gamma\, \triangleright \varphi_1 \dots \varphi_m \, (\mathcal{R}\,P)[A]
  \]
  then
  \[
    \vdash_\Sigma c_i : \pid (\E{\varphi_1} \veedot \dots  \veedot \E{\varphi_m} \veedot \nil) \coloneq M_i.
  \] If $M_i$ is provided it is a proof term inhabiting the type of the translated clause.
\end{theorem}
\begin{proof}
  Inductively, assume that the theorem holds for the shorter trace prefix $P = [c_1, \dots, c_{n-1}]$, which is also a valid proof trace prefix, and consider the rule $R$ that is applied for establishing $c_n$.
  \begin{itemize}
  \item Case $R = \kw{assume}$. Then the assertion obviously holds, and no proof term is provided.
  \item For tautologous and simple deduction rules, the proofs follow a similar approach. We illustrate them with two cases:
  \begin{itemize}
  \item Case $R = \kw{equiv\_pos2}$.
    Using the interpretation of clauses as disjunctions (\kw{cl2disj} \cref{def:cl2disj}), the clause
    \[
       \prfcl (\neg(\E{\varphi_1} = \E{\varphi_2}) \veedot (\neg \E{\varphi_1}) \veedot \E{\varphi_2} \veedot \nil)
    \]
    corresponds to the disjunction
    \[
      \prf (\neg(\E{\varphi_1} = \E{\varphi_2}) \;\lor\; \neg \E{\varphi_1} \;\lor\; \E{\varphi_2}).
    \]
    This is classically valid.
    Indeed, the disjunction rewrites to  $\E{\varphi_1} = \E{\varphi_2} \implies \neg \E{\varphi_1} \;\lor\; \E{\varphi_2}$, so we have $\neg \E{\varphi_2} \lor \E{\varphi_2}$ by substituting and then it is a tautology by excluded middle.
  \item Case $R = \kw{cong}$. Since $P$ is a valid proof trace prefix, the conclusion of the step must be of the form $(f~t_1 \ldots t_m) \approx (f~u_1 \ldots u_m)$ and the justification must refer to previous steps $i_j.\,\Gamma\,\triangleright t_j \approx u_j$.
  By assumption, we therefore have in Lambdapi that $\vdash_{\Sigma} c_j: \pid (t_j = u_j)$, and an application of rule $\kw{cong}_m$ proves the assertion.
  \end{itemize}
  The rest of the supported tautologous and simple deductions can be found in \cref{app:alethe-rules-supported}.
  \item Case $R = \kw{resolution}$. The assertion follows from \cref{th:resolution} since the resolution rule is a chain of resolutions of clauses.
  \item Case $R = \kw{subproof}$. The assertion follows from \cref{lem:subproof}, cf.\ \cref{app:subproof}, and the assumption that $P$ is a valid Alethe trace prefix.
  \item Case $R = \kw{contraction}$.
    The assertion follows from \cref{thm:contraction-correct}, since the rule contracts a clause already established in a previous step. 
    By the induction hypothesis, that earlier step is valid, and therefore the contracted clause is also valid under the assumption that $P$ is a valid Alethe trace prefix.
  \item Case $R = \kw{bind}$. The assertion follows from Lemmas~\ref{lem:bind-exists} and~\ref{lem:bind-forall} and the assumption that $P$ is a valid Alethe trace prefix.
  \item Case $R = \kw{sko\_forall}$. Again relying on the assumption that $P$ is a valid Alethe trace prefix, the assertion follows from \cref{lem:sko-forall} and the definition of the translation in \cref{fig:sko-forall}.
  \item Case $R = \kw{la\_generic}$ with the coefficients $[a_1 ,\dots, a_n]$ given. The assertion that the translated clause:
    \[
        \prfcl (\neg(\E{\varphi^1_1} \bowtie \E{\varphi^1_2}) \veedot \dots \veedot  \neg(\E{\varphi^k_1} \bowtie \E{\varphi^k_2}) \veedot \nil)
    \]
    with $\bowtie = \{ \geq, \leq, <, >, = \}$ leads to a contraction follows from the normalisation \cref{thm:norm-correct} and reification \cref{thm:reify-correct}, which ensures the correctness of the reification of arithmetic expressions in order to prove a contraction,
    together with the lemmas (\cref{app:alethe-rules-supported}) establishing the normalisation of disjunctions of inequalities and the coefficients $[\E{a_1} ,\dots, \E{a_n}]$. 
  \end{itemize}
    The case of \kw{lia\_generic} is handled by relying on the Carcara elaboration of linear arithmetic reasoning (see \cref{ssec:elaboration-lia}). 

\end{proof}

We do not formally assert correctness for the simplification and evaluation proof steps, because the latter rely on transformations that are not entirely known to us, but we provide a best-effort translation for these commands. Further Alethe commands are left for future work.
