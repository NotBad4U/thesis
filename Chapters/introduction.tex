%************************************************
\chapter{Introduction}\label{ch:introduction}
%************************************************


Several proof assistants employ \emph{hammers} for discharging goals to automatic theorem provers (ATPs), including SMT solvers. Examples include Sledgehammer \cite{Sledgehammer} for Isabelle/HOL and CoqHammer \cite{coqhammer1,coqhammer2} for Coq.
The hammer translates the conjecture and facts supplied by the user or harvested
from the context to the input language of the back-end, invokes it, and in the
case of success attempts to reconstruct the proof in the logic of the proof
assistant, based on a trace of the proof found by the back-end.
%
This process can benefit from detailed proofs by the back-ends.
%
For example, adoption by Sledgehammer of the Alethe format generated by the SMT solver veriT \cite{isabelle1,isabelle2} cut the failure rate of reconstruction by 50\% and reduced the checking time by 13\%. These results encouraged us to base our approach on the Alethe trace format.

\emph{SMTCoq} \cite{smtcoq} is a fully certified Coq plugin that checks proof witnesses coming from external SAT and SMT solvers. For proof reconstruction, SMTCoq relies on computational reflection: the certificate is directly processed by the reduction mechanism of Coq's kernel.
We initially attempted to convert the SMTCoq proof certificate to Lambdapi. However, we found the proof term generated by computational reflection, including subterms corresponding to arithmetic decision procedures in Micromega \cite{micromega}, to be too complex to be converted to Lambdapi.
%
Moreover, SMTCoq is based on an old version of the Alethe proof format, which is
only supported by older versions of the veriT solver.

\emph{Carcara} \cite{carcara} is an independent proof checker and proof elaborator for SMT proof traces in the Alethe format that is implemented in Rust. Although Carcara is not a certified checker like SMTCoq, it allows a coarse-grained proof trace, containing implicit steps, to be elaborated to a fine-grained one that includes more detailed steps or adds missing parameters. The resulting trace can be easier to check by a proof assistant, and our work benefits particularly from Carcara's proof trace elaboration given the lack of meta-programming in the vernacular language of Lambdapi.

This article is an extended version of our previous workshop paper \cite{ColtellacciMD24}. We added \cref{sect:elaboration} that describes the novel elaboration passes added to Carcara for facilitating the reconstruction of the translated Alethe proofs. Besides, our earlier work suffered from scalability issues when checking long proof traces, which may contain large terms. We introduce an approach based on computational reflection for checking hyper-resolution steps, described in \cref{sec:refl-reso}, and we employ parallel threads for checking independent proof steps. Together, these improvements allow us to tackle larger benchmarks as shown in \cref{sect:evaluation}.
In addition, we added support for more Alethe rules, increasing the number of proofs that can be reconstructed, and we integrated automatic decision procedures (\cref{ssec:eval-recon}) into our reconstruction to allow us to support built-in theory steps whose proofs are not provided in the proof trace by the solver.
