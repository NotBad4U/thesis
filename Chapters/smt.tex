\chapter{Satisfiability Modulo Theories}\label{ch:smt}


\section{SMT Solvers}

Satisfiability Modulo Theories (SMT) \cite{Barrett2021SatisfiabilityMT} solvers are automated reasoning tools that extend SAT solving \cite{chaff,minitsat} by combining propositional search with reasoning in background theories.
These theories formalize the fundamental data types of computer science, including integers and rationals, floating-point numbers, strings, arrays, sequences, records, and finite sets.
By incorporating the essential algebraic properties of such types as built-in reasoning modules, SMT solvers can handle them natively rather than treating them as uninterpreted.
SMT solvers are widely used in software and hardware verification \cite{application-smt-hardware}, constraint solving \cite{awssmt,application-smt2}, and automated theorem proving \cite{coqhammer1,Sledgehammer}.

SMT solvers take as input a logical formula and determine whether it is \emph{satisfiable}, that is, whether there exists an assignment to the formula's variables that makes it true.
In this sense, they function as constraint solvers.
In many applications, however, the goal is not merely to establish that a property, expressed as a formula $F$, holds in some instance, but rather that it holds universally.
Formally, this amounts to proving that $F$ is \emph{valid}. To verify validity with an SMT solver, this can be done with SMT solvers by checking
if the \emph{negation} of the formula, $\neg F$,  is false in all cases i.e. \emph{unsatisfiable}. A proof of the \emph{unsatisfiability} of $\neg F$ provides evidence that $F$ is valid.
Thus, SMT solvers provide not only a means of solving constraints but also a method for establishing theorems, since valid formulas are commonly referred to as theorems.

Modern \emph{hammer} tools, such as Sledgehammer \cite{Sledgehammer} for Isabelle/HOL \cite{isabelle-hol-ref}, CoqHammer \cite{coqhammer1} for Rocq \cite{Rocq-refman}, and the SMT integration in Lean \cite{lean-smt}, make systematic use of SMT solvers to automate proof search.
Their purpose is to bridge interactive theorem provers with powerful automated reasoning backends.
Given a conjecture, the hammer translates the goal and relevant lemmas into a form suitable for external solvers, including SMT solvers, and then attempts to discharge the proof obligation automatically.
If the SMT solver succeeds in showing that the translated problem is valid, the hammer reconstructs or certifies a corresponding proof inside the interactive prover.
In this way, SMT solvers act as critical engines for proof automation, providing fast search capabilities that complement the expressive but more manual environments of interactive theorem proving.

\section{Terms and Sorts}

The SMT-LIB initiative \cite{smtlib} defines a standardized input language and logical framework for SMT solvers, specifies a set of common background theories, and maintains an extensive collection of benchmarks.
The SMT-LIB logic is a many-sorted first-order logic with equality.

\begin{definition}[Terms]\label{def:smt-grammar}
The following grammar rule describes the construction of terms $t$
\begin{equation*}
t ::= t \pipe x \pipe f~x \pipe f^\sigma t^* \pipe \exists (x: \sigma)^+. t \pipe \forall (x: \sigma)^+. t \pipe \mathrel{\kw{let}} (x = t)^+ \mathrel{\kw{in}} t
\end{equation*}
The notation $()^*$ denotes a possibly empty and finite list, and $()^+$ a finite list with at least one member.
\end{definition}

Since the SMT-LIB logic is many-sorted, every term has an associated sort $\sigma$.
To avoid ambiguous sorts, there is a syntax to concretize the sort of a function symbol $f^\sigma$.
Third, this term language also encompasses terms with Boolean sort, so that no distinction is made between terms and formulas.
Moreover, symbols such as equality and the Boolean connectives are not treated as primitive syntax but are instead provided by the special \emph{theory Core}.

Well-sortedness in SMT-LIB is defined with respect to a \emph{signature}, which specifies the available sorts and function symbols from which terms can be constructed.
The concrete signature depends on the selected background theories, but it can also be extended by the user with uninterpreted sorts and symbols through dedicated commands.
While SMT-LIB in general supports parametric sorts and sort terms, these features are not used in our setting.


A formula without free variables is called a \emph{sentence}.
A term without any variables is called a \emph{ground term}. A formula that is a ground term is a \emph{ground formula}.

\begin{notation}
Since the symbol $\Sigma$ is already used for Lambdapi signatures, and SMT-LIB also employs $\Sigma$ for its own signature, we instead denote SMT signature by $\Theta$.  
\end{notation}

\begin{definition}[Signature]\label{def:smt-signature}
A signature is a tuple $\Theta = (\Theta^\cal{S}, \Theta^\cal{F}, \Theta^\cal{X}, V, R)$
\begin{itemize}
    \item  a finite set $\Theta^\cal{S}$  of sort symbols that contains the symbol \smtinline{Bool};
    \item The infinite set $\Theta^\cal{X}$ contains the variables;
    \item a set $\Theta^\cal{F}$ of function symbols;
    \item a partial mapping $V$ from $\Theta^\cal{X}$ to $\Theta^\cal{S}$ that assigns sorts to some variables,
    \item and a ranking relation $R \subseteq \Theta^\cal{F} \times (\Theta^\cal{S})^+$. The relation must be left-total: for
    all $f \in \Theta^\cal{F}$ there is a $\eta \in (\Theta^\cal{S})^+$ such that $f \mathrel{R} \eta$. The set $(\Theta^\cal{S})^+$ 
    is the set of non-empty finite lists over the sort symbols in $\Theta^\cal{S}$.
\end{itemize}
\end{definition}

A rank denotes the expected sort of the symbol's arguments and the return sort.
Since the SMT-LIB logic allows ad-hoc polymorphism (overloading), $R$ is not left-unique.

\begin{definition}[Well-sorted Term]
A term $t$ generated by the grammar rules in \cref{def:smt-signature} is \emph{well-sorted} for a signature $\Theta$ if $t$ has sort $\sigma$.  
Let $\Theta[x_1 : \sigma_1, \dots, x_n : \sigma_n]$ denote the signature for which the function $V$ maps $x_i$ to $\sigma_i$ for $i \in 1,\dots,n$ and otherwise corresponds to $V$ of $\Theta$.  
The term $t$ has sort $\sigma$ if a judgment $\Theta \vdash t : \sigma$ is derivable by the following sorting rules:
\[
\begin{array}{l}
\begin{prooftree}
\hypo{x : \sigma \in \Theta}
\infer1{\Theta \vdash x : \sigma}
\end{prooftree}
\\[2em]
\begin{prooftree}
\hypo{\Theta \vdash t : \sigma}
\infer1{\Theta \vdash (t) : \sigma}
\end{prooftree}
\\[2em]
\begin{prooftree}
\hypo{\Theta \vdash t_1 : \sigma_1 \quad \dots \quad \Theta \vdash t_k : \sigma_k}
\infer1[if $\begin{cases} f : \sigma_1 \cdots \sigma_k \sigma \in \Theta, \\ f : \sigma_1 \cdots \sigma_k \sigma' \notin \Theta \text{ for all } \sigma' \neq \sigma \end{cases}$]{\Theta \vdash f\, t_1 \cdots t_k : \sigma}
\end{prooftree}
\\[2em]
\begin{prooftree}
\hypo{\Theta \vdash t_1 : \sigma_1 \quad \dots \quad \Theta \vdash t_k : \sigma_k}
\infer1[(if $f : \sigma_1 \cdots \sigma_k \sigma \in \Theta$)]{\Theta \vdash f t_1 \cdots t_k : \sigma}
\end{prooftree}
\\[2em]
\begin{prooftree}
\hypo{\Theta[x_1 : \sigma_1, \dots, x_{k+1} : \sigma_{k+1}] \vdash t : \kw{Bool}}
\infer1[(if $Q \in \{\forall, \exists\}$)]{\Theta \vdash Q\, x_1 : \sigma_1 \cdots x_{k+1} : \sigma_{k+1} . t : \kw{Bool}}
\end{prooftree}
\\[2em]
\begin{prooftree}
\hypo{
  \begin{matrix}
    \Sigma \vdash t_1 : \sigma_1 \dots  \Sigma \vdash t_{k+1} : \sigma_{k+1}  \\
    \Sigma[x_1 : \sigma_1, \dots, x_{k+1} : \sigma_{k+1}] \vdash t : \sigma
  \end{matrix}
}
\infer1[(if $x_i$ are all distinct)]{\Sigma \vdash (\kw{let } x_1 = t_1 \cdots x_{k+1} = t_{k+1} \kw{ in } t) : \sigma}
\end{prooftree}
\end{array}
\]
\end{definition}



\section{semantics}

To define the semantic of the SMT-LIB logic, we use the notion of $\Theta$-structure.

\begin{definition}[$\Theta$-structure]
Let $\Theta$ be a signature.  
A \emph{$\Theta$-structure} is a tuple $\cal{A} = (U, I)$ of a set $U$, the \emph{universe}, and a mapping $I$.
\begin{itemize}
    \item Each sort $\sigma \in \Theta^{S}$ is mapped to a non-empty set $I(\sigma) \subseteq U$, the \emph{domain} of $\sigma$.  
    The mapping is such that $U = \bigcup_{\sigma \in \Theta^{S}} I(\sigma)$.
    \item For each sort $\sigma_1 \dots \sigma_n \sigma$, $I(\sigma_1 \dots \sigma_n \sigma)$ is the set of total functions from $I(\sigma_1) \times \dots \times I(\sigma_n)$ to $I(\sigma)$.
    \item $I(\mathsf{Bool}) = \{\mathsf{true}, \mathsf{false}\}$, where $\mathsf{true}$ and $\mathsf{false}$ are distinct and both are elements of $U$.
    \item Each ranked function symbol $f : \sigma$ (i.e., each constant) is mapped such that $I(f : \sigma) \in I(\sigma)$.
    \item Each ranked function symbol $f : \sigma_1 \dots \sigma_n \sigma \in \Theta$ is mapped to a total function from $I(\sigma_1 \dots \sigma_n \sigma)$.
\end{itemize}
\end{definition}



A $\Theta$-interpretation $\cal{I}$ is a pair $(\cal{A}, \nu)$ of a $\Theta$-structure $\cal{A}$ and a valuation $\nu$
that assigns meaning to terms and formulas, given a $\cal{A}$ structure and a variable assignment, so that we can decide whether a formula is true or false.
This mapping  function is denoted $\llbracket \_ \rrbracket^{\cal{I}}$.

\begin{definition}[$\Theta$-interpretation]\label{def:smt-interpretation}
Let $\Theta$ be a signature and $\cal{I}$ a $\Theta$-interpretation.  
For every well-sorted term $t$ with sort $\sigma$, the mapping $\llbracket t \rrbracket^{\cal{I}}$ is defined recursively as follows:

\[
\llbracket x \rrbracket^{\cal{I}} = \nu(x : \sigma)
\]
where $\cal{I} = (\cal{A}, \nu)$.

\[
\llbracket \hat{f}\; t_1 \dots t_n \rrbracket^{\cal{I}}
   = \cal{A}(f : \sigma_1 \dots \sigma_n \sigma)(a_1, \dots, a_n)
\]
where
\[
\begin{cases}
   \cal{I} = (\cal{A}, \nu) \text{ with signature } \Theta, \\
   \hat{f} = f \text{ or } \hat{f} = f^{\sigma}, \\
   \Theta \vdash t_i : \sigma_i \text{ and } a_i = \llbracket t_i \rrbracket^{\cal{I}}, \quad i=1,\dots,n.
\end{cases}
\]

\[
\llbracket \text{let } x_1 = t_1 \cdots x_n = t_n \text{ in } t \rrbracket^{\cal{I}}
    = \llbracket t \rrbracket^{\cal{I}'}
\]
where
\[
\begin{cases}
   \cal{I} \text{ has signature } \Theta, \\
   \Theta \vdash t_i : \sigma_i \text{ and } a_i = \llbracket t_i \rrbracket^{\cal{I}}, \quad i=1,\dots,n, \\
   \cal{I}' = \cal{I}[x_1 : \sigma_1 \mapsto a_1, \dots, x_n : \sigma_n \mapsto a_n].
\end{cases}
\]

\[
\llbracket \exists x_1 : \sigma_1 \cdots x_n : \sigma_n . t \rrbracket^{\cal{I}} = \text{true}
\;\;\text{iff}\;\; \llbracket t \rrbracket^{\cal{I}'} = \text{true for some }\cal{I}' 
\]
where
\[
\begin{cases}
   \cal{I} = ((U,I),\nu), \\
   (a_1,\dots,a_n) \in I(\sigma_1) \times \cdots \times I(\sigma_n), \\
   \cal{I}' = \cal{I}[x_1 : \sigma_1 \mapsto a_1, \dots, x_n : \sigma_n \mapsto a_n].
\end{cases}
\]

\[
\llbracket \forall x_1 : \sigma_1 \cdots x_n : \sigma_n . t \rrbracket^{\cal{I}} = \text{true}
\;\;\text{iff}\;\; \llbracket t \rrbracket^{\cal{I}'} = \text{true for all }\cal{I}'
\]
where
\[
\begin{cases}
   \cal{I} = ((U,I),\nu), \\
   (a_1,\dots,a_n) \in I(\sigma_1) \times \cdots \times I(\sigma_n), \\
   \cal{I}' = \cal{I}[x_1 : \sigma_1 \mapsto a_1, \dots, x_n : \sigma_n \mapsto a_n].
\end{cases}
\]
\end{definition}

The notions of satisfiability and falsifiability are defined in the standard way.
A $\Theta$-interpretation satisfies a formula $\varphi$ if $\llbracket \varphi \rrbracket^{\mathcal{A}} = \kw{true}$.
Conversely, it falsifies $\varphi$ if $\llbracket \varphi \rrbracket^{\mathcal{A}} = \kw{false}$.
A formula $\varphi$ is \emph{satisfiable} if there exists a $\Theta$-interpretation that satisfies it, and \emph{unsatisfiable} if no such interpretation exists.

The notion of a \emph{model} applies only to sentences, i.e., formulas without free variables.
In this case, the valuation $\nu$ is irrelevant.
A model of a sentence $\varphi$ is a $\Theta$-structure $\mathcal{A}$ such that every (equivalently, at least one) $\Theta$-interpretation $(\mathcal{A}, \nu)$ satisfies $\varphi$.
As usual, $\models$ denotes semantic entailment. A set of sentences $\Gamma$ entails a sentence $\psi$ if every model of $\Gamma$ is also a model of $\psi$.
This is written $\Gamma \models \psi$, and if $\Gamma$ contains a single sentence $\varphi$, it is abbreviated $\varphi \models \psi$.

\section{Theories}

As discussed above, well-sortedness in SMT-LIB is defined relative to a signature.
The SMT-LIB language further permits the combination of theories, provided their signatures are compatible.
Two signatures are compatible if they share the same sort symbols and assign identical sorts to all variables.
The combination of two compatible theories is then defined as the class of $\Theta$-structures whose projections onto the signatures of the component theories are models of those theories.

A \emph{logic} in SMT-LIB consists of a specific signature $\Theta$, a theory $\mathcal{T}$, and a restriction on the set of admissible sentences.
These restrictions are typically syntactic and serve to exclude ill-formed expressions.
For instance, in the logic of linear arithmetic, the multiplication of two variables is not permitted.
Following common usage in the SMT community, we will not always maintain a strict distinction between the terms "logic" and "theory".

\begin{definition}[Models]
A $\Theta$-theory $\cal{T}$ is a class of $\Theta$-structure on a signature $\Theta$.
These structures are the \emph{models} of the theory $\cal{T}$.
\end{definition}

Defining theories this way gives us the flexibility to declare theories as either specific models, or as the $\Theta$-structures that satisfies a set of sentences which are called axioms.

\begin{definition}[Satisfiability and Entailment In a Theory]
A $\Theta$-sequence is satisfiable in a theory $\cal{T}$ if and only if it is satisfied by one of the models
of $\cal{T}$. A set $\Gamma$ of $\Theta$-sequences $\cal{T}$-entails a $\Theta$-sequence $\varphi$ denoted
$\Gamma \models_{\cal{T}} \varphi$ if and only if every model of $\cal{T}$ that satisfies all sentences in $\Gamma$ satisfies $\varphi$ as well.
\end{definition}

In what follows, we briefly introduce some of the logics that will be used in the subsequent chapters.

\subsection{The Core theory}

This theory is used by every SMT-LIB logic. It contains the usual Boolean connective $\land, \lor, \neg, \to, \kw{xor}, \kw{distinct}, \kw{ite}$.
Equality, denoted by $\simeq$ (= in SMT-LIB), is also part of this theory.
The \emph{Core theory} does not contain a dedicated "if and only if" connective.
Instead equality with Boolean sorts is used.

\question{ac}{add distinct + ite def?}

\begin{remark}
Since SMT-LIB is restricted to ASCII characters, it uses the strings \smtinline{and, or, not, =>, xor} for boolean  connectives. 
\end{remark}

\subsection{Uninterpreted Symbols}

The logic \textbf{UF} (for uninterpreted functions) allows the declaration of new function symbols.
The prefix \textbf{QF} (for quantifier-free) may be applied to any logic to indicate that quantifiers are disallowed.
The simplest extension of the core theory is therefore \textbf{QF\_UF}, denoting quantifier-free uninterpreted functions.
This logic excludes quantifiers and introduces no additional symbols beyond those of the core theory.

\subsection{The theory of linear arithmetic}

\begin{table}
\centering
\begin{tabular}{lll}
\toprule
\textbf{Symbol} & \textbf{String} & \textbf{Rank} \\
\midrule
$-$ & \tt{-} & Int Int \\
    &            & Real Real \\
$-$ & \tt{-} & Int Int Int \\
    &            & Real Real Real \\
$+$ & \tt{+} & Int Int Int \\
    &            & Real Real Real \\
$\times$ & \tt{*} & Int Int Int \\
    &               & Real Real Real \\
\tt{div} & \tt{div} & Int Int Int \\
/ & \tt{/} & Real Real Real \\
\tt{mod} & \tt{mod} & Int Int Int \\
\tt{abs} & \tt{abs} & Int Int \\
$\leq$ & \tt{<=} & Int Int Bool \\
    &                & Real Real Bool \\
$<$ & \tt{<} & Int Int Bool \\
    &             & Real Real Bool \\
$\geq$ & \tt{>=} & Int Int Bool \\
    &               & Real Real Bool \\
$>$ & \tt{>} & Int Int Bool \\
    &             & Real Real Bool \\
\tt{to\_real} & \tt{to\_real} & Int Real \\
\tt{to\_int}  & \tt{to\_int} & Real Int \\
\tt{is\_int}  & \tt{is\_int} & Real Bool \\
\tt{divisible} $n$ & \tt{(\_ divisible n )} & Int Bool \\
\bottomrule
\end{tabular}
\caption{Function symbols of the real and integers theory.}
\label{tab:real-int-funs}
\end{table}

Linear arithmetic in SMT-LIB is specified by the theories of reals (\textbf{LA}) and integers (\textbf{LIA}), together with syntactic constraints ensuring that arithmetic expressions remain linear.

The signature of the theory of reals and integers contains two additional sorts: \smtinline{Int} and \smtinline{Real} , along with the function symbols listed in \cref{tab:real-int-funs}.
Most of these functions are overloaded to operate uniformly on both integers and reals.
Their interpretation is standard, with the exception of division. 
Since SMT-LIB does not support partial functions, terms such as \((/~x~0.0)\) are well-defined , although the standard leaves their interpretation unconstrained.
Consequently, for each real constant \(v\), the term \((\approx~v~(/~t~0.0))\) admits a model.
The same consideration applies to integer division (\texttt{div}).

\subsection{Bit-vectors}


\begin{table}
\centering
\begin{tabular}{lll}
\toprule
\textbf{Symbol} & \textbf{String} & \textbf{Rank} \\
\midrule
$\sim$ & \tt{bvnot} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$!$   & \tt{bvneg} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\&\&$ & \tt{bvand} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$||$  & \tt{bvor}  & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\oplus$& \tt{bvxor} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\uparrow$ & \tt{bvnand} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\downarrow$ & \tt{bvnor}  & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\odot$ & \tt{bvxnor} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$+$ & \tt{bvadd} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$-$ & \tt{bvsub} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\times$ & \tt{bvmul} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
/\(_u\) & \tt{bvudiv} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
/\(_s\) & \tt{bvsdiv} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\bmod_u$ & \tt{bvurem} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\bmod_s$ & \tt{bvsrem} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\mathrm{mod}_s$ & \tt{bvsmod} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\ll$ & \tt{bvshl}  & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\gg_u$ & \tt{bvlshr} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\gg_s$ & \tt{bvashr} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$\circ$ & \tt{concat} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;m\)\; \(\mathrm{BitVec}\;(n{+}m)\) \\
— & \tt{(\_ extract i j)} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;(i{-}j{+}1)\) \\
— & \tt{(\_ repeat k)} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;(k\cdot n)\) \\
— & \tt{(\_ zero\_extend k)} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;(n{+}k)\) \\
— & \tt{(\_ sign\_extend k)} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;(n{+}k)\) \\
— & \tt{(\_ rotate\_left k)} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
— & \tt{(\_ rotate\_right k)} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\) \\
$<$\(_u\) & \tt{bvult} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; Bool \\
$\le$\(_u\) & \tt{bvule} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; Bool \\
$>$\(_u\) & \tt{bvugt} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; Bool \\
$\ge$\(_u\) & \tt{bvuge} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; Bool \\
$<$\(_s\) & \tt{bvslt} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; Bool \\
$\le$\(_s\) & \tt{bvsle} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; Bool \\
$>$\(_s\) & \tt{bvsgt} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; Bool \\
$\ge$\(_s\) & \tt{bvsge} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; Bool \\
\tt{bvcomp} & \tt{bvcomp} & \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;n\)\; \(\mathrm{BitVec}\;1\) \\
\tt{int2bv} & \tt{((\_ \tt{int2bv}~n))} & Int \;\(\mathrm{BitVec}\;n\) \\
\tt{bv2int} & \tt{bv2int} & \(\mathrm{BitVec}\;n\)\; Int \\
\bottomrule
\end{tabular}
\caption{SMT-LIB Bit-Vector theory function symbols (sizes \(n,m,k,i,j\) are numerals).}
\label{tab:bv-funs}
\end{table}

Bitvectors in SMT-LIB are defined by the theory \textbf{BV}.
Its signature introduces the sort \smtinline{(_ BitVec n)} for every fixed width $n \geq 1$, together with the function symbols listed in \cref{tab:bv-funs}.
The semantics of these operations follow standard fixed-width, two's complement bitvector arithmetic, including modular addition, subtraction, multiplication, and division, as well as bitwise logical and shift operators.
All operations are total, since results are wrapped modulo $2^n$.


\section{Solving SMT Problems}

The core idea of SMT solving is to combine propositional reasoning with theory reasoning.
The standard method for propositional reasoning is \emph{conflict-driven clause learning} (CDCL) \cite{dpll}.
In its extension CDCL($\mathcal{T}$), propositional reasoning is separated from theory reasoning by constructing an abstract version of the input problem in which every literal is replaced by a propositional variable.
The CDCL engine then decides which propositional variables, and hence which literals, must hold.
The theory solver checks whether these literals are consistent with the background theory.
If they are, the problem is solved; otherwise, the theory solver generates new clauses that are added back into the propositional search.
When the problem contains quantifiers, an additional instantiation component is required.

\begin{remark}
This style of SMT solving is known as the \emph{lazy} approach.
By contrast, the \emph{eager} approach encodes the entire input problem directly into propositional logic, ensuring that satisfiability is preserved by the translation.
The resulting propositional formula can then be handed to any standard SAT solver.
\end{remark}


\begin{figure}
\begin{tikzpicture}[
  node distance=8pt and 8pt, font=\scriptsize
]
    % Inner boxes
    \node (Box1) [draw, rounded corners=3pt, align=center] {CDLC};
    \node (Box2) [draw, rounded corners=3pt, align=center, below=of Box1] {Theory Solver};
    
    % Larger box around the two
    \node (Container) [draw, minimum width=5cm, rounded corners=3pt, thick, fit=(Box1) (Box2), inner sep=10pt] {};
    
    % Instantiation Procedure above Container
    \node (Box3) [draw, rounded corners=3pt, above=of Container] {Instantiation Procedure};

    % Outer container
    \node (Container2) [draw, minimum width=7cm, rounded corners=3pt, thick, fit=(Container) (Box3), inner sep=10pt] {};

    % Left and right columns aligned by TOP (north)
    \node (L1) [draw, rounded corners=3pt, align=center,
                anchor=north] at ([xshift=-5cm]Container2.north) {Problem};
    % \node (L2) [draw, rounded corners=3pt, below=of L1] {Preprocess};
    \node (L2) [draw, rounded corners=3pt, align=center, anchor=center] at (L1.center |- Box1.center) {Preprocess};


    \node (R1) [draw, rounded corners=3pt, align=center,
                anchor=north] at ([xshift=5cm]Container2.north) {Sat};
    \node (R2) [draw, rounded corners=3pt, below=of R1] {Unsat};
    \node (R3) [draw, rounded corners=3pt, below=of R2] {Timeout};

    %  \draw [-> ] (Box1.east) to [bend left=60,looseness=3] (Box2.east);
    %  \draw [-> ] (Box2.west) to [bend left=60,looseness=3] (Box1.west);
    \draw[->] (Box1.east) to[out=0,   in=0,   looseness=2] (Box2.east);
    \draw[->] (Box2.west) to[out=180, in=180, looseness=2] (Box1.west);


    \draw[->] (Box3.east) to[out=0,   in=0,   looseness=1.8] (Container.east);
    \draw[->] (Container.west)      to[out=180, in=180, looseness=1.8] (Box3.west);


    \draw[->] ([yshift=44pt]Container2.east) -- (R1.west);
    \draw[->] ([yshift=22pt]Container2.east) -- (R2.west);
    \draw[->] ([yshift=0pt]Container2.east) -- (R3.west);

    \draw [-> ] (L2) to (Container2);

    \draw [-> ] (L1) to (L2);
\end{tikzpicture}
\caption{The main loop of an SMT solver.}
\label{fig:CDCL}
\end{figure}

\cref{fig:CDCL} illustrates the operation of a CDCL($\mathcal{T}$)-based SMT solver on a problem with quantifiers.
The solver first preprocesses the input.
Then two procedures cooperate to refute the problem: the ground solver, i.e. the combination of the propositional CDCL engine with the theory solvers restricted to quantifier-free formulas, either refutes it at the ground level or produces a ground model.
For quantifier-free problems this is sufficient, whereas in the presence of quantifiers the instantiation procedure is applied to the ground model, either producing new ground lemmas or establishing satisfiability.
A \emph{ground model} is an assignment to the variables of a quantifier-free formula that satisfies all ground literals with respect to the background theories.
Ground models are obtained from the combination of the CDCL engine with the theory solvers, prior to any reasoning about quantifiers.

Given an input sentence (i.e., a closed term of sort \texttt{Bool}), an SMT solver applies several preprocessing steps before entering the solving phase.
This produces an equisatisfiable problem $F$ in clause normal form.
To optimize the ground solver, ground subformulas are fully clausified.
Quantified formulas, however, are treated differently: they are usually neither converted into prenex form nor clausified, and strong quantifiers \cite{BAAZ2001273} are typically not fully Skolemized.
Preserving the original structure of quantified formulas is crucial for certain instantiation techniques.


Preprocessing also includes lightweight rewriting of quantified formulas.
For example, the term $(\bot \to \varphi_1) \to \varphi_2$ is simplified to $\varphi_2$.
Skolemization is another preprocessing step, but its application is largely implementation dependent.
The abstract CDCL($\mathcal{T}$) calculus itself only addresses ground reasoning.
In practice, solvers such as cvc5 and veriT, in their default configurations, Skolemize only outermost strong quantifiers.


The inner loop of the SMT solver, shown in \cref{fig:CDCL}, attempts to construct a model of the quantifier-free part of the problem.
The CDCL engine first searches for a propositional model of the abstracted problem.
The theory solvers then verify whether the literals in this propositional model are consistent with their respective background theories.
If they are, the literals form a ground model.


If the SMT solver finds that no propositional model exists (i.e., the abstraction is propositionally unsatisfiable), the original problem is \emph{unsatisfiable} and solving terminates.
Otherwise, the propositional model is passed to the theory solvers.
Their operation depends on the background theories involved, and their calculi may differ substantially.
When multiple theories are present, their solvers must also be combined.
In all cases, the theory solver evaluates the candidate model: if it is consistent with the theories, the literals constitute a ground model of the quantifier-free fragment of the sentence; otherwise, contradictions are reported back.

\section{SMT proof}

Since SMT applications crucially rely on correct results, ensuring solver correctness becomes paramount.
Ensuring the correctness of SMT solvers is a significant challenge, as these tools have large and highly optimized code bases that evolve rapidly. 
Rather than attempting to certify the entire solver implementation, a promising approach is to instrument SMT solvers to produce \emph{proofs} of their results \cite{proof-smt}.

Proof production drastically reduces the size of the trusted code base, since only the proof checker must be trusted, not the entire solver.
Beyond this fundamental advantage, proof infrastructure provides multiple benefits:  it enforces modularity and clarity in the solver’s code, often uncovering bugs in the process;
it serves as a powerful debugging aid, where failed or incorrect proof generation highlights faults in the solver;
and it offers a form of test oracle, since an incorrect proof can be detected  by an independent checker \cite{10.1007/978-3-319-66107-0_18}. 

When a solver determines satisfiability, it may return a model, while in the unsatisfiable case,  a proof of inconsistency provides a verifiable guarantee of correctness. 
However, producing well-formed proofs is itself non-trivial: errors may arise from faulty proof steps, cycles in proof graphs, or reliance on unsupported assumptions. 
Efficiency is another key concern, as proof generation must not significantly  degrade solver performance. 

A common technique is \emph{lazy proof generation}, where the solver constructs a high-level proof sketch  during the search, delaying the expansion of detailed lemmas until after unsatisfiability is established. 
This reduces implementation effort, minimizes performance overhead, and ensures that only  relevant proof material is expanded.
Lazy proof generation is a key feature of the DRAT \cite{drat} proof format used by SAT solvers, and several ways of expanding (also known as elaborating) DRAT proofs have been proposed \cite{10.1007/978-3-319-63046-5_14,DBLP:conf/cade/KieslRH18, 10.1007/978-3-319-63046-5_15}.
This line of work also inspired investigations in the SMT setting \cite{lazy-proof-smt}, where lazy proof generation was developed for CVC4, the predecessor of cvc5 \cite{cvc4}.

Despite progress, current proof-producing SMT solvers still face shortcomings:  some produce proofs that are too shallow, requiring complex external checking; 
others leave performance-critical components outside of proof production; 
and many rely on monolithic proof formats, limiting interoperability. 
Nevertheless, proof production remains the most promising avenue for ensuring SMT solver correctness  without certifying their entire, complex code base \cite{LFSC}.
