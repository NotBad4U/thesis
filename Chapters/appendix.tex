%********************************************************************
% Appendix
%*******************************************************
% If problems with the headers: get headings in appendix etc. right
%\markboth{\spacedlowsmallcaps{Appendix}}{\spacedlowsmallcaps{Appendix}}
\chapter{Appendix}

\section{Confluence of the rewriting rules of integers and positive binary number}
\label{app:confluence-int-pos}

The rules presented below represent the relations $\ra_\bb{Z}$ and $\ra_\bb{P}$ encoded in the TRS\footnote{\url{http://www.lri.fr/~marche/tpdb/format.html}} format accepted by the \cite{CSI} tool.
These rules can be used to rerun the tool in order to verify the confluence property.


\begin{lstlisting}[language=trs, caption=Rewriting rule of $\bb{Z}$ and $\bb{P}$ in the TRS format]
(VAR
  a: Z
  b: Z
  x : P
  q : P
  y : P
)
(RULES
  ~(Z0) -> Z0
  ~(Zpos(p)) -> Zneg(p)
  ~(Zneg(p)) -> Zpos(p)
  ~(~(a)) -> a
  ~(add(a,b)) -> add(~(a), ~(b))

  double(Z0) -> Z0
  double(Zpos(p)) -> Zpos(O(p))
  double(Zneg(p)) -> Zneg(O(p))
  
  succ_double(Z0) -> Zpos(H)
  succ_double(Zpos(p)) -> Zpos(I(p))
  succ_double(Zneg(p)) -> Zneg(pos_pred_double(p))
  
  pred_double(Z0) -> Zneg(H)
  pred_double(Zpos(p)) -> Zpos(pos_pred_double(p))
  pred_double(Zneg(p)) -> Zneg(I(p))

  sub(I(p), I(q)) -> double(sub(p, q))
  sub(I(p), O(q)) -> succ_double(sub(p, q))
  sub(I(p), H) -> Zpos(O(p))
  sub(O(p), I(q)) -> pred_double(sub(p, q))
  sub(O(p), O(q)) -> double(sub(p, q))
  sub(O(p), H) -> Zpos(pos_pred_double(p))
  sub(H, I(q)) -> Zneg(O(q))
  sub(H, O(q)) -> Zneg(pos_pred_double(q))
  sub(H, H) -> Z0

  +(Z0,a) -> a
  +(a,Z0) -> a
  +(Zpos(x), Zpos(y)) -> Zpos(add(x, y))
  +(Zpos(x), Zneg(y)) -> sub(x, y)
  +(Zneg(x), Zpos(y)) -> sub(y, x)
  +(Zneg(x), Zneg(y)) -> Zneg(add(x, y))
  
  mult(Z0, a) -> Z0
  mult(a, Z0) -> Z0
  mult(Zpos(x), Zpos(y)) -> Zpos(mul(x, y))
  mult(Zpos(x), Zneg(y)) -> Zneg(mul(x, y))
  mult(Zneg(x), Zpos(y)) -> Zneg(mul(x, y))
  mult(Zneg(x), Zneg(y)) -> Zpos(mul(x, y))


  succ(I(x)) -> O(succ(x))
  succ(O(x)) -> I(x)
  succ(H) -> O(H)
  add(I(x), I(q)) -> O(addcarry(x, q))
  add(I(x), O(q)) -> I(add(x, q))
  add(O(x), I(q)) -> I(add(x, q))
  add(O(x), O(q)) -> O(add(x, q))
  add(x, H) -> succ(x)
  add(H, y) -> succ(y)

  addcarry(I(x), I(q)) -> I(addcarry(x, q))
  addcarry(I(x), O(q)) -> O(addcarry(x, q))
  addcarry(O(x), I(q)) -> O(addcarry(x, q))
  addcarry(O(x), O(q)) -> I(add(x, q))
  addcarry(x, H) -> add(x, O(H))
  addcarry(H, y) -> add(O(H), y)
  
  pos_pred_double(I(x)) -> I(O(x))
  pos_pred_double(O(x)) -> I(pos_pred_double(x))
  pos_pred_double(H) -> H
  
  mul(I(x), y) -> add(x, O(mul(x,y)))
  mul(O(x), y) -> O(mul(x, y))
  mul(H, y) -> y
)
\end{lstlisting}

\section{Arithmetic definitions}\label{app:arith-def}
\label{app:arith-defs}

\begin{definition}[Integer arithmetic functions]
{\footnotesize
% \centering
% --- Integer Addition ---
\begin{align*}
&+: \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO + y \re y \\
& x + \ZO \re x \\
& (\tt{Zpos x}) + (\tt{Zpos y}) \re (\ZPos~(\tt{add}~x~y))  \\
& (\tt{Zpos x}) + (\tt{Zneg y}) \re (\tt{sub}~x~y)  \\
& (\tt{Zneg x}) + (\tt{Zpos y}) \re (\tt{sub}~y~x)  \\
& (\tt{Zneg x}) + (\tt{Zneg y}) \re \ZNeg~(\tt{add}~x~y)
\end{align*}
\noindent

\begin{align*}
& \kw{succ}: \bb{P} \ra \bb{P} \\
& \kw{succ}~(I~x) \re O (\kw{succ}~x) \\
& \kw{succ}~(O~x) \re I (\kw{succ}~x) \\
& \kw{succ}~(H) \re O H
\end{align*}

% --- Positive Binary Arithmetic ---
\[
\begin{array}[t]{ll}
\begin{aligned}
&\tt{add} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{add}~(\tt{I}~x)~(\tt{I}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{add}~(\tt{I}~x)~(\tt{O}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{add}~(\tt{O}~x)~(\tt{I}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{add}~(\tt{O}~x)~(\tt{O}~q) \re \tt{O}~(\tt{add}~x~q) \\
& \tt{add}~x~\tt{H} \re \tt{succ}~x \\
& \tt{add}~\tt{H}~y \re \tt{succ}~y \\
\end{aligned}
&
\begin{aligned}
&\tt{mul} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{mul}~\tt{H}~y \re y \\
& \tt{mul}~y~\tt{H} \re y \\
& \tt{mul}~(\tt{O}~x)~y \re \tt{O}~(\tt{mul}~x~y) \\
& \tt{mul}~(\tt{I}~x)~y \re \\
& \quad \tt{add}~y~(\tt{O}~(\tt{mul}~x~y)) \\
\end{aligned}
\end{array}
\]
\noindent

\begin{align*}
&\tt{addc} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{addc}~(\tt{I}~x)~(\tt{I}~q) \re \tt{I}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{I}~x)~(\tt{O}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{O}~x)~(\tt{I}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{O}~x)~(\tt{O}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{addc}~x~\tt{H} \re \tt{add}~x~(\tt{O}~\tt{H}) \\
& \tt{addc}~\tt{H}~y \re \tt{add}~(\tt{O}~\tt{H})~y \\
\end{align*}
\noindent

% --- Multiplication ---
\begin{align*}
&\tt{*} : \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO *~\_ \re \ZO \\
& \_ *~\ZO \re \ZO \\
& \ZPos x *~\ZPos y \re \ZPos (\tt{mul}~x~y) \\
& \ZPos x *~\ZNeg    y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZPos y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZNeg    y \re \ZPos (\tt{mul}~x~y) \\
\end{align*}
}%
\end{definition}

\begin{definition}[Complete definition of \tt{sub} function]
\begin{align*}
& \kw{sub} : \bb{P} \ra \bb{P} \ra \bb{Z} \\
& \kw{sub}~(I~p)~(I~q) \re \kw{double}~(\kw{sub}~p~q) \\
& \kw{sub}~(I~p)~(O~q) \re \kw{succ\_double}~(\kw{sub}~p~q) \\
& \kw{sub}~(I~p)~H \re \kw{Zpos}~(O~p) \\
& \kw{sub}~(O~p)~(I~q) \re \kw{pred\_double}~(\kw{sub}~p~q) \\
& \kw{sub}~(O~p)~(O~q) \re \kw{double}~(\kw{sub}~p~q) \\
& \kw{sub}~(O~p)~H \re \kw{Zpos}~(\kw{pos\_pred\_double}~p) \\
& \kw{sub}~H~(I~q) \re \kw{Zneg}~(O~q) \\
& \kw{sub}~H~(O~q) \re \kw{Zneg}~(\kw{pos\_pred\_double}~q) \\
& \kw{sub}~H~H \re \kw{Z0} \\[1em]
%
& \kw{pos\_pred\_double} : \bb{P} \ra \bb{P} \\
& \kw{pos\_pred\_double}~(I~x) \re I~(O~x) \\
& \kw{pos\_pred\_double}~(O~x) \re I~(\kw{pos\_pred\_double}~x) \\
& \kw{pos\_pred\_double}~H \re H \\[1em]
%
& \kw{double} : \bb{Z} \ra \bb{Z} \\
& \kw{double}~Z0 \re Z0 \\
& \kw{double}~(\kw{Zpos}~p) \re \kw{Zpos}~(O~p) \\
& \kw{double}~(\kw{Zneg}~p) \re \kw{Zneg}~(O~p) \\[1em]
%
& \kw{succ\_double} : \bb{Z} \ra \bb{Z} \\
& \kw{succ\_double}~Z0 \re \kw{Zpos}~H \\
& \kw{succ\_double}~(\kw{Zpos}~p) \re \kw{Zpos}~(I~p) \\
& \kw{succ\_double}~(\kw{Zneg}~p) \re \kw{Zneg}~(\kw{pos\_pred\_double}~p) \\[1em]
%
& \kw{pred\_double} : \bb{Z} \ra \bb{Z} \\
& \kw{pred\_double}~Z0 \re \kw{Zneg}~H \\
& \kw{pred\_double}~(\kw{Zpos}~p) \re \kw{Zpos}~(\kw{pos\_pred\_double}~p) \\
& \kw{pred\_double}~(\kw{Zneg}~p) \re \kw{Zneg}~(I~p)
\end{align*}
\end{definition}

\begin{definition}[cmp]\label{def:cmp-pos}
\begin{align*}
& \kw{cmp\_acc} : \bb{P} \ra \kw{Comp} \ra \bb{P} \ra \kw{Comp} \\
\\
& \kw{cmp\_acc}~(\kw{I}~x)~c~(\kw{I}~q) \re \kw{cmp\_acc}~x~c~q \\
& \kw{cmp\_acc}~(\kw{I}~x)~\_~(\kw{O}~q) \re \kw{cmp\_acc}~x~\kw{Gt}~q \\
& \kw{cmp\_acc}~(\kw{I}~\_)~\_~\kw{H} \re \kw{Gt} \\
& \kw{cmp\_acc}~(\kw{O}~x)~\_~(\kw{I}~q) \re \kw{cmp\_acc}~x~\kw{Lt}~q \\
& \kw{cmp\_acc}~(\kw{O}~x)~c~(\kw{O}~q) \re \kw{cmp\_acc}~x~c~q \\
& \kw{cmp\_acc}~(\kw{O}~\_)~\_~\kw{H} \re \kw{Gt} \\
& \kw{cmp\_acc}~\kw{H}~\_~(\kw{I}~\_) \re \kw{Lt} \\
& \kw{cmp\_acc}~\kw{H}~\_~(\kw{O}~\_) \re \kw{Lt} \\
& \kw{cmp\_acc}~\kw{H}~c~\kw{H} \re c \\
\\
& \kw{cmp}~x~y \is \kw{cmp\_acc}~x~\kw{Eq}~y
\end{align*}
\end{definition}

\section{Supported Alethe rules}
\label{app:alethe-rules-supported}

% \begin{figure}[H]
% \centering
% \begin{tabular}{|cccc|}
% \hline
% \kw{assume} & \kw{subproof} & \kw{resolution} & \kw{th\_resolution}  \\
% \kw{true} & \kw{false} & \kw{not\_not} & \kw{forall\_inst}   \\
% \kw{refl} & \kw{eq\_reflexive} & \kw{eq\_transitive} & \kw{eq\_congruent} \\
% \kw{eq\_congruent\_pred} & \kw{and\_pos} & \kw{and\_neg} & \kw{or\_pos} \\
% \kw{or\_neg} & \kw{xor\_pos1} & \kw{xor\_pos2} & \kw{xor\_neg1} \\
% \kw{xor\_neg2}  & \kw{xor\_pos1} & \kw{contraction} & \kw{bind} \\
% \kw{implies\_pos} & \kw{implies\_neg1}  & \kw{implies\_neg2} & \kw{equiv\_pos1} \\
% \kw{equiv\_pos2} & \kw{equiv\_neg1}  & \kw{equiv\_neg2} & \kw{ite\_pos1} \\
% \kw{ite\_pos1} & \kw{ite\_pos2} & \kw{ite\_neg1} & \kw{ite\_neg2}  \\
% \kw{distinct\_elim} & \kw{eq\_symmetric} & \kw{sko\_exist} & \kw{sko\_forall} \\
% \kw{and} & \kw{not\_or} & \kw{not\_and} & \kw{reordering} \\
% \kw{symm} & \kw{not\_symm} & \kw{eq\_symmetric} & \kw{equiv\_simplify} \\
% \kw{not\_simplify} & \kw{ite\_simplify} & \kw{implies\_simplify} & \kw{ac\_simp} \\
% \hline
% \end{tabular}
% \caption{List of Alethe rules supported in our reconstruction.}
% \end{figure}

\begin{figure}[H]
\centering
\begin{tabular}{|ccc|}
\hline
\kw{ac\_simp} & \kw{and} & \kw{and\_neg} \\
\kw{and\_pos} & \kw{assume} & \kw{bind} \\
\kw{contraction} & \kw{distinct\_elim} & \kw{eq\_congruent} \\
\kw{eq\_congruent\_pred} & \kw{eq\_reflexive} & \kw{eq\_symmetric} \\
\kw{eq\_transitive} & \kw{equiv\_neg1} & \kw{equiv\_neg2} \\
\kw{equiv\_pos1} & \kw{equiv\_pos2} & \kw{equiv\_simplify} \\
\kw{false} & \kw{forall\_inst} & \kw{implies\_neg1} \\
\kw{implies\_neg2} & \kw{implies\_pos} & \kw{implies\_simplify} \\
\kw{ite\_neg1} & \kw{ite\_neg2} & \kw{ite\_pos1} \\
\kw{ite\_pos2} & \kw{ite\_simplify} & \kw{la\_generic} \\
\kw{lia\_generic} & \kw{not\_and} & \kw{not\_not} \\
\kw{not\_or} & \kw{not\_simplify} & \kw{not\_symm} \\
\kw{or} & \kw{or\_neg} & \kw{or\_pos} \\
\kw{refl} & \kw{reordering} & \kw{resolution} \\
\kw{sko\_exist} & \kw{sko\_forall} & \kw{subproof} \\
\kw{symm} & \kw{th\_resolution} & \kw{true} \\
\kw{xor\_neg1} & \kw{xor\_neg2} & \kw{xor\_pos1} \\
\kw{xor\_pos2} & & \\
\hline
\end{tabular}
\caption{List of Alethe rules supported in our reconstruction (alphabetical order, 3 columns).}
\end{figure}


$\kw{th\_resolution}$ and $\kw{resolution}$ denote the same rule.
The difference only distinguishes if the rule was introduced by the SAT solver or a theory solver.
The Alethe formats include 102 rules (excluding the rule \kw{hole}), and we currently support 52 of them. However, some rules in the format
are used exclusively by veriT, and do not appear in cvc5 proof traces. Among the unsupported rules, 14 are for linear arithmetic and 3 for bitvectors.

\begin{figure}[H]
\centering
\begin{tabular}{|cc|}
\hline
\kw{arith-elim-lt} & \kw{arith-geq-norm} \\
\kw{arith-geq-norm1} & \kw{arith-geq-norm2} \\
\kw{arith-geq-tighten} & \kw{arith-leq-norm} \\
\kw{bool-and-de-morgan} & \kw{bool-and-false} \\
\kw{bool-and-flatten} & \kw{bool-and-true} \\
\kw{bool-double-not-elim} & \kw{bool-eq-false} \\
\kw{bool-eq-true} & \kw{bool-impl-elim} \\
\kw{bool-impl-false1} & \kw{bool-impl-false2} \\
\kw{bool-impl-true2} & \kw{bool-impl-true2} \\
\kw{bool-or-de-morgan} & \kw{bool-or-false} \\
\kw{bool-or-flatten} & \kw{distinct-binary-elim} \\
\kw{eq-refl} & \kw{eq-symm} \\
\hline
\end{tabular}
\caption{List of RARE rules supported in our reconstruction (alphabetical order, 2 columns).}
\end{figure}