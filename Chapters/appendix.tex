% !TeX root = main.tex
%********************************************************************
% Appendix
%*******************************************************
% If problems with the headers: get headings in appendix etc. right
%\markboth{\spacedlowsmallcaps{Appendix}}{\spacedlowsmallcaps{Appendix}}
\chapter{Appendix}

\section{Confluence of the rewriting rules of integers and positive binary number}
\label{app:confluence-int-pos}

The rules presented below represent the relations $\ra_\bb{Z}$ and $\ra_\bb{P}$ encoded in the TRS\footnote{\url{http://www.lri.fr/~marche/tpdb/format.html}} format accepted by the \cite{CSI} tool.
These rules can be used to rerun the tool in order to verify the confluence property.


\begin{lstlisting}[language=trs, caption=Rewriting rule of $\bb{Z}$ and $\bb{P}$ in the TRS format]
(VAR
  a: Z
  b: Z
  x : P
  q : P
  y : P
)
(RULES
  ~(Z0) -> Z0
  ~(Zpos(p)) -> Zneg(p)
  ~(Zneg(p)) -> Zpos(p)
  ~(~(a)) -> a
  ~(add(a,b)) -> add(~(a), ~(b))

  double(Z0) -> Z0
  double(Zpos(p)) -> Zpos(O(p))
  double(Zneg(p)) -> Zneg(O(p))
  
  succ_double(Z0) -> Zpos(H)
  succ_double(Zpos(p)) -> Zpos(I(p))
  succ_double(Zneg(p)) -> Zneg(pos_pred_double(p))
  
  pred_double(Z0) -> Zneg(H)
  pred_double(Zpos(p)) -> Zpos(pos_pred_double(p))
  pred_double(Zneg(p)) -> Zneg(I(p))

  sub(I(p), I(q)) -> double(sub(p, q))
  sub(I(p), O(q)) -> succ_double(sub(p, q))
  sub(I(p), H) -> Zpos(O(p))
  sub(O(p), I(q)) -> pred_double(sub(p, q))
  sub(O(p), O(q)) -> double(sub(p, q))
  sub(O(p), H) -> Zpos(pos_pred_double(p))
  sub(H, I(q)) -> Zneg(O(q))
  sub(H, O(q)) -> Zneg(pos_pred_double(q))
  sub(H, H) -> Z0

  +(Z0,a) -> a
  +(a,Z0) -> a
  +(Zpos(x), Zpos(y)) -> Zpos(add(x, y))
  +(Zpos(x), Zneg(y)) -> sub(x, y)
  +(Zneg(x), Zpos(y)) -> sub(y, x)
  +(Zneg(x), Zneg(y)) -> Zneg(add(x, y))
  
  mult(Z0, a) -> Z0
  mult(a, Z0) -> Z0
  mult(Zpos(x), Zpos(y)) -> Zpos(mul(x, y))
  mult(Zpos(x), Zneg(y)) -> Zneg(mul(x, y))
  mult(Zneg(x), Zpos(y)) -> Zneg(mul(x, y))
  mult(Zneg(x), Zneg(y)) -> Zpos(mul(x, y))


  succ(I(x)) -> O(succ(x))
  succ(O(x)) -> I(x)
  succ(H) -> O(H)
  add(I(x), I(q)) -> O(addcarry(x, q))
  add(I(x), O(q)) -> I(add(x, q))
  add(O(x), I(q)) -> I(add(x, q))
  add(O(x), O(q)) -> O(add(x, q))
  add(x, H) -> succ(x)
  add(H, y) -> succ(y)

  addcarry(I(x), I(q)) -> I(addcarry(x, q))
  addcarry(I(x), O(q)) -> O(addcarry(x, q))
  addcarry(O(x), I(q)) -> O(addcarry(x, q))
  addcarry(O(x), O(q)) -> I(add(x, q))
  addcarry(x, H) -> add(x, O(H))
  addcarry(H, y) -> add(O(H), y)
  
  pos_pred_double(I(x)) -> I(O(x))
  pos_pred_double(O(x)) -> I(pos_pred_double(x))
  pos_pred_double(H) -> H
  
  mul(I(x), y) -> add(x, O(mul(x,y)))
  mul(O(x), y) -> O(mul(x, y))
  mul(H, y) -> y
)
\end{lstlisting}

\section{Arithmetic definitions}\label{app:arith-def}
\label{app:arith-defs}

\begin{definition}[Integer arithmetic functions]
{\footnotesize
% \centering
% --- Integer Addition ---
\begin{align*}
&+: \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO + y \re y \\
& x + \ZO \re x \\
& (\tt{Zpos x}) + (\tt{Zpos y}) \re (\ZPos~(\tt{add}~x~y))  \\
& (\tt{Zpos x}) + (\tt{Zneg y}) \re (\tt{sub}~x~y)  \\
& (\tt{Zneg x}) + (\tt{Zpos y}) \re (\tt{sub}~y~x)  \\
& (\tt{Zneg x}) + (\tt{Zneg y}) \re \ZNeg~(\tt{add}~x~y)
\end{align*}
\noindent

\begin{align*}
& \kw{succ}: \bb{P} \ra \bb{P} \\
& \kw{succ}~(I~x) \re O (\kw{succ}~x) \\
& \kw{succ}~(O~x) \re I (\kw{succ}~x) \\
& \kw{succ}~(H) \re O H
\end{align*}

% --- Positive Binary Arithmetic ---
\[
\begin{array}[t]{ll}
\begin{aligned}
&\tt{add} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{add}~(\tt{I}~x)~(\tt{I}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{add}~(\tt{I}~x)~(\tt{O}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{add}~(\tt{O}~x)~(\tt{I}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{add}~(\tt{O}~x)~(\tt{O}~q) \re \tt{O}~(\tt{add}~x~q) \\
& \tt{add}~x~\tt{H} \re \tt{succ}~x \\
& \tt{add}~\tt{H}~y \re \tt{succ}~y \\
\end{aligned}
&
\begin{aligned}
&\tt{mul} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{mul}~\tt{H}~y \re y \\
& \tt{mul}~y~\tt{H} \re y \\
& \tt{mul}~(\tt{O}~x)~y \re \tt{O}~(\tt{mul}~x~y) \\
& \tt{mul}~(\tt{I}~x)~y \re \\
& \quad \tt{add}~y~(\tt{O}~(\tt{mul}~x~y)) \\
\end{aligned}
\end{array}
\]
\noindent

\begin{align*}
&\tt{addc} : \bb{P} \ra \bb{P} \ra \bb{P} \\
& \tt{addc}~(\tt{I}~x)~(\tt{I}~q) \re \tt{I}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{I}~x)~(\tt{O}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{O}~x)~(\tt{I}~q) \re \tt{O}~(\tt{addc}~x~q) \\
& \tt{addc}~(\tt{O}~x)~(\tt{O}~q) \re \tt{I}~(\tt{add}~x~q) \\
& \tt{addc}~x~\tt{H} \re \tt{add}~x~(\tt{O}~\tt{H}) \\
& \tt{addc}~\tt{H}~y \re \tt{add}~(\tt{O}~\tt{H})~y \\
\end{align*}
\noindent

% --- Multiplication ---
\begin{align*}
&\tt{*} : \bb{Z} \ra \bb{Z} \ra \bb{Z} \\
& \ZO *~\_ \re \ZO \\
& \_ *~\ZO \re \ZO \\
& \ZPos x *~\ZPos y \re \ZPos (\tt{mul}~x~y) \\
& \ZPos x *~\ZNeg    y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZPos y \re \ZNeg    (\tt{mul}~x~y) \\
& \ZNeg    x *~\ZNeg    y \re \ZPos (\tt{mul}~x~y) \\
\end{align*}
}%
\end{definition}

\begin{definition}[Complete definition of \tt{sub} function]
\begin{align*}
& \kw{sub} : \bb{P} \ra \bb{P} \ra \bb{Z} \\
& \kw{sub}~(I~p)~(I~q) \re \kw{double}~(\kw{sub}~p~q) \\
& \kw{sub}~(I~p)~(O~q) \re \kw{succ\_double}~(\kw{sub}~p~q) \\
& \kw{sub}~(I~p)~H \re \kw{Zpos}~(O~p) \\
& \kw{sub}~(O~p)~(I~q) \re \kw{pred\_double}~(\kw{sub}~p~q) \\
& \kw{sub}~(O~p)~(O~q) \re \kw{double}~(\kw{sub}~p~q) \\
& \kw{sub}~(O~p)~H \re \kw{Zpos}~(\kw{pos\_pred\_double}~p) \\
& \kw{sub}~H~(I~q) \re \kw{Zneg}~(O~q) \\
& \kw{sub}~H~(O~q) \re \kw{Zneg}~(\kw{pos\_pred\_double}~q) \\
& \kw{sub}~H~H \re \kw{Z0} \\[1em]
%
& \kw{pos\_pred\_double} : \bb{P} \ra \bb{P} \\
& \kw{pos\_pred\_double}~(I~x) \re I~(O~x) \\
& \kw{pos\_pred\_double}~(O~x) \re I~(\kw{pos\_pred\_double}~x) \\
& \kw{pos\_pred\_double}~H \re H \\[1em]
%
& \kw{double} : \bb{Z} \ra \bb{Z} \\
& \kw{double}~Z0 \re Z0 \\
& \kw{double}~(\kw{Zpos}~p) \re \kw{Zpos}~(O~p) \\
& \kw{double}~(\kw{Zneg}~p) \re \kw{Zneg}~(O~p) \\[1em]
%
& \kw{succ\_double} : \bb{Z} \ra \bb{Z} \\
& \kw{succ\_double}~Z0 \re \kw{Zpos}~H \\
& \kw{succ\_double}~(\kw{Zpos}~p) \re \kw{Zpos}~(I~p) \\
& \kw{succ\_double}~(\kw{Zneg}~p) \re \kw{Zneg}~(\kw{pos\_pred\_double}~p) \\[1em]
%
& \kw{pred\_double} : \bb{Z} \ra \bb{Z} \\
& \kw{pred\_double}~Z0 \re \kw{Zneg}~H \\
& \kw{pred\_double}~(\kw{Zpos}~p) \re \kw{Zpos}~(\kw{pos\_pred\_double}~p) \\
& \kw{pred\_double}~(\kw{Zneg}~p) \re \kw{Zneg}~(I~p)
\end{align*}
\end{definition}

\begin{definition}[cmp]\label{def:cmp-pos}
\begin{align*}
& \kw{cmp\_acc} : \bb{P} \ra \kw{Comp} \ra \bb{P} \ra \kw{Comp} \\
\\
& \kw{cmp\_acc}~(\kw{I}~x)~c~(\kw{I}~q) \re \kw{cmp\_acc}~x~c~q \\
& \kw{cmp\_acc}~(\kw{I}~x)~\_~(\kw{O}~q) \re \kw{cmp\_acc}~x~\kw{Gt}~q \\
& \kw{cmp\_acc}~(\kw{I}~\_)~\_~\kw{H} \re \kw{Gt} \\
& \kw{cmp\_acc}~(\kw{O}~x)~\_~(\kw{I}~q) \re \kw{cmp\_acc}~x~\kw{Lt}~q \\
& \kw{cmp\_acc}~(\kw{O}~x)~c~(\kw{O}~q) \re \kw{cmp\_acc}~x~c~q \\
& \kw{cmp\_acc}~(\kw{O}~\_)~\_~\kw{H} \re \kw{Gt} \\
& \kw{cmp\_acc}~\kw{H}~\_~(\kw{I}~\_) \re \kw{Lt} \\
& \kw{cmp\_acc}~\kw{H}~\_~(\kw{O}~\_) \re \kw{Lt} \\
& \kw{cmp\_acc}~\kw{H}~c~\kw{H} \re c \\
\\
& \kw{cmp}~x~y \is \kw{cmp\_acc}~x~\kw{Eq}~y
\end{align*}
\end{definition}

\section{Supported Alethe rules}
\label{app:alethe-rules-supported}

% \begin{figure}[H]
% \centering
% \begin{tabular}{|cccc|}
% \hline
% \kw{assume} & \kw{subproof} & \kw{resolution} & \kw{th\_resolution}  \\
% \kw{true} & \kw{false} & \kw{not\_not} & \kw{forall\_inst}   \\
% \kw{refl} & \kw{eq\_reflexive} & \kw{eq\_transitive} & \kw{eq\_congruent} \\
% \kw{eq\_congruent\_pred} & \kw{and\_pos} & \kw{and\_neg} & \kw{or\_pos} \\
% \kw{or\_neg} & \kw{xor\_pos1} & \kw{xor\_pos2} & \kw{xor\_neg1} \\
% \kw{xor\_neg2}  & \kw{xor\_pos1} & \kw{contraction} & \kw{bind} \\
% \kw{implies\_pos} & \kw{implies\_neg1}  & \kw{implies\_neg2} & \kw{equiv\_pos1} \\
% \kw{equiv\_pos2} & \kw{equiv\_neg1}  & \kw{equiv\_neg2} & \kw{ite\_pos1} \\
% \kw{ite\_pos1} & \kw{ite\_pos2} & \kw{ite\_neg1} & \kw{ite\_neg2}  \\
% \kw{distinct\_elim} & \kw{eq\_symmetric} & \kw{sko\_exist} & \kw{sko\_forall} \\
% \kw{and} & \kw{not\_or} & \kw{not\_and} & \kw{reordering} \\
% \kw{symm} & \kw{not\_symm} & \kw{eq\_symmetric} & \kw{equiv\_simplify} \\
% \kw{not\_simplify} & \kw{ite\_simplify} & \kw{implies\_simplify} & \kw{ac\_simp} \\
% \hline
% \end{tabular}
% \caption{List of Alethe rules supported in our reconstruction.}
% \end{figure}

\begin{figure}[H]
\centering
\begin{tabular}{|ccc|}
\hline
\kw{ac\_simp} & \kw{and} & \kw{and\_neg} \\
\kw{and\_pos} & \kw{assume} & \kw{bind} \\
\kw{contraction} & \kw{distinct\_elim} & \kw{eq\_congruent} \\
\kw{eq\_congruent\_pred} & \kw{eq\_reflexive} & \kw{eq\_symmetric} \\
\kw{eq\_transitive} & \kw{equiv\_neg1} & \kw{equiv\_neg2} \\
\kw{equiv\_pos1} & \kw{equiv\_pos2} & \kw{equiv\_simplify} \\
\kw{false} & \kw{forall\_inst} & \kw{implies\_neg1} \\
\kw{implies\_neg2} & \kw{implies\_pos} & \kw{implies\_simplify} \\
\kw{ite\_neg1} & \kw{ite\_neg2} & \kw{ite\_pos1} \\
\kw{ite\_pos2} & \kw{ite\_simplify} & \kw{la\_generic} \\
\kw{lia\_generic} & \kw{not\_and} & \kw{not\_not} \\
\kw{not\_or} & \kw{not\_simplify} & \kw{not\_symm} \\
\kw{or} & \kw{or\_neg} & \kw{or\_pos} \\
\kw{refl} & \kw{reordering} & \kw{resolution} \\
\kw{sko\_exist} & \kw{sko\_forall} & \kw{subproof} \\
\kw{symm} & \kw{th\_resolution} & \kw{true} \\
\kw{xor\_neg1} & \kw{xor\_neg2} & \kw{xor\_pos1} \\
\kw{xor\_pos2} & & \\
\hline
\end{tabular}
\caption{List of Alethe UF rules supported in our reconstruction (alphabetical order).}
\end{figure}

$\kw{th\_resolution}$ and $\kw{resolution}$ denote the same rule.
The difference only distinguishes if the rule was introduced by the SAT solver or a theory solver.
The Alethe formats include 102 rules (excluding the rule \kw{hole}), and we currently support 52 of them. However, some rules in the format
are used exclusively by veriT, and do not appear in cvc5 proof traces. Among the unsupported rules, 14 are for linear arithmetic and 3 for bitvectors.

\begin{figure}[H]
\centering
\begin{tabular}{|ll|}
\hline
\kw{comp\_simplify} & \kw{evaluate} \\
\kw{la\_disequality} & \kw{la\_generic} \\
\kw{la\_tautology} & \kw{la\_totality} \\
\kw{lia\_generic} & \\
\hline
\end{tabular}
\caption{List of LIA/LA rules supported in our reconstruction (alphabetical order).}
\label{fig:linear-arith-rules}
\end{figure}

\begin{figure}[H]
\centering
\begin{tabular}{|cc|}
\hline
\kw{arith-elim-gt} & \kw{arith-elim-leq} \\
\kw{arith-elim-lt} & \kw{arith-geq-norm} \\
\kw{arith-geq-norm1} & \kw{arith-geq-norm2} \\
\kw{arith-geq-tighten} & \kw{arith-int-eq-elim} \\
\kw{arith-leq-norm} & \kw{arith-poly-norm} \\
\kw{arith-refl-geq} & \kw{arith-refl-leq} \\
\kw{arith-refl-lt} & \kw{bool-and-de-morgan} \\
\kw{bool-and-false} & \kw{bool-and-flatten} \\
\kw{bool-and-true} & \kw{bool-double-not-elim} \\
\kw{bool-eq-false} & \kw{bool-eq-true} \\
\kw{bool-impl-elim} & \kw{bool-impl-false1} \\
\kw{bool-impl-false2} & \kw{bool-impl-true2} \\
\kw{bool-or-de-morgan} & \kw{bool-or-false} \\
\kw{bool-or-flatten} & \kw{distinct-binary-elim} \\
\kw{eq-refl} & \kw{eq-symm} \\
\hline
\end{tabular}
\caption{List of RARE rules supported in our reconstruction (alphabetical order).}
\end{figure}

\section{Translation example involving more Alethe features}
\label{app:translation-example}

This section present an extended SMT input problem example below that illustrates a more complex case of proof reconstruction involving several advanced features of the Alethe format and our translation framework.
Compared to \cref{lst:smt-ex-intro,lst:input-smtexampleproof} examples presented in previous chapters, this instance contains nested \emph{subproofs} (\cref{sec:subproof}) that demonstrate the use of local assumptions and their discharge within the Alethe structure.
It also makes use of the \kw{contraction} rule (\cref{sec:contraction-recon}) and of RARE simplification steps that normalize arithmetic expressions through rule-based rewriting.
Furthermore, the example features \emph{N-ary} rules (\cref{sec:nary-rule-recon}), which operate over variable-length connectives.

\lstinputlisting[language=SMT,caption={SMT Input Problem},label={lst:input-ex-app}]{Assets/app_ex.smt2}

The corresponding proof generated by \textsf{cvc5} for this problem is shown below in the Alethe format.

\lstinputlisting[language=SMT,caption={Alethe Proof of \cref{lst:input-ex-app} Found by cvc5},label={lst:proof-ex-app}]{Assets/app_ex.alethe}

Finally, the Alethe trace is translated into Lambdapi as shown in the listing below.

\lstinputlisting[language=Lambdapi, caption={Lambdapi Translation of \cref{lst:proof-ex-app}}, label={lst:lp-ex-app}, mathescape=true]{Assets/app_ex.lp}

The module imports \texttt{Alethe}, \texttt{Simplify}, \texttt{Rare}, and \texttt{Clause}, which provide the prelude and the encodings for first-order reasoning, clause manipulation, and simplification used throughout the reconstruction. 
The declarations of sorts \(\kw{S1}, \kw{S3}, \dots\) and function symbols \(\kw{f1}, \kw{f2}, \dots\) correspond to the SMT symbols defined in \cref{lst:input-ex-app}, while the abbreviations \(\kw{p2}, \kw{p3}, \dots\) (lines~25-33) denote shared subterms introduced to factorize repeated expressions and optimize memory usage.
Steps \(\kw{t0}\)–\(\kw{t4}\) apply tautological Alethe rules (e.g., \kw{implies\_neg1}), equality reflexivity and symmetry, and congruence (\texttt{cong2}), illustrating our translation of first-order logical reasoning and equality handling (\cref{ch:reconstruction-ul}). 
The fragment \(\kw{t5\_t0}\)–\(\kw{t5\_t2}\), spanning lines~56–87, reconstructs the nested subproof from \cref{lst:proof-ex-app} (lines~32–39).
A concrete example of a contraction step (\cref{sec:contraction-recon}) appears in \(\kw{t9}\), starting at line~108.
Finally, the \kw{resolutionL} (e.g., line~77) and \kw{resolutionR} (e.g., line~92) lemmas correspond to two instances of \cref{th:resolution}: the former operates when the negated pivot appears on the left of the clause, and the latter when it occurs on the right.
Overall, this example demonstrates how our framework integrates advanced Alethe features such as subproofs, contraction, RARE-based simplification, and N-ary reasoning into a unified, checkable proof reconstruction using Lambdapi.

\section{Complete benchmark results}
\label{app:complete-benchmarks-results}

We collect the complete benchmark results for all configurations and benchmark suites considered in this work.
We start with a global summary of the benchmark samples in \cref{tab:all-benchmarks} below.
For each step of our pipeline, SMT solving with cvc5, proof elaboration with Carcara, and translation to Lambdapi, we first report the numbers of successful runs, internal errors, and timeouts in \cref{tab:benchmarks-app,tab:benchmarks-translate}.
We then present detailed timing measurements for these steps in \cref{tab:benchmarks-cvc5-time,tab:benchmarks-carcara-time},
followed by box plots that visualize the distribution of checking times for cvc5 and Carcara in \cref{fig:all-carcara-time-boxplot,fig:carcara-time-boxplot},
and for the Lambdapi translation on small and large proofs in \cref{fig:lambdapi-translation-small-time,fig:lambdapi-translation-large-time}.
To make some plots fit more on the page, we abbreviate benchmark samples using the acronyms defined in the \emph{acronym} column of \cref{tab:all-benchmarks}.
We do not comment on these figures individually, since the qualitative observations about timeouts, reconstruction failures,
and performance trends are the same as those already discussed in \cref{ch:evaluation}.


\begin{table}[t]
\centering
\caption{Summary of benchmark.}
{%
\scriptsize
\pgfplotstabletypeset[
  font=\ttfamily,
  col sep=comma,
  every even row/.style={
    before row={\rowcolor[gray]{0.9}}},
  every head row/.style={
    before row=\toprule,after row=\midrule},
  every last row/.style={
    after row=\bottomrule},
  columns={name, acronym,logic,cvc5_count},
  columns/name/.style={string type},
  columns/acronym/.style={string type},
  columns/logic/.style={string type, column name={logic}},
    columns/cvc5_count/.style={column name={number of proofs}},
]{Assets/benchs/all.csv}%
}
\label{tab:all-benchmarks}
\end{table}


\begin{table}[t]
\centering
\caption{cvc5 and Alethe elaboration results.}
{%
\scriptsize
\pgfplotstabletypeset[
  font=\ttfamily,
  col sep=comma,
  every even row/.style={
    before row={\rowcolor[gray]{0.9}}},
  every head row/.style={
    before row=\toprule,after row=\midrule},
  every last row/.style={
    after row=\bottomrule},
  columns={acronym,logic, cvc5_count,cvc5_results, elaboration_results},
  columns/acronym/.style={string type},
  columns/logic/.style={string type, column name={logic}},
  columns/cvc5_count/.style={column name={number}},
  columns/cvc5_results/.style={string type, column name={cvc5}},
  columns/elaboration_results/.style={string type, column name={alethe}},
]{Assets/benchs/all.csv}%
}
\label{tab:benchmarks-app}
\end{table}

\begin{table}[t]
\centering
{%
\scriptsize
\caption{Time measurements for cvc5 in seconds. }
\label{tab:benchmarks-cvc5-time}
\pgfplotstabletypeset[
  font=\ttfamily,
  col sep=comma,
  every even row/.style={
    before row={\rowcolor[gray]{0.9}}},
  every head row/.style={
    before row=\toprule,after row=\midrule},
  every last row/.style={
    after row=\bottomrule},
  columns={acronym, cvc5_mean,cvc5_min,cvc5_q1,cvc5_median,cvc5_q3,cvc5_max},
  columns/acronym/.style={string type},
  % columns/cvc5_count/.style={
  % column name={number},
  %   /pgf/number format/fixed,
  %   /pgf/number format/precision=0, % No decimal places for integers
  % },
  columns/cvc5_mean/.style={column name={mean}},
  columns/cvc5_min/.style={column name={min}},
  columns/cvc5_q1/.style={column name={Q1}},
  columns/cvc5_median/.style={column name={median}},
  columns/cvc5_q3/.style={column name={Q3}},
  columns/cvc5_max/.style={column name={max}},
  /pgf/number format/precision=2,
  /pgf/number format/fixed,
  /pgf/number format/fixed zerofill=true,
]{Assets/benchs/all.csv}%
}
\end{table}


% https://tex.stackexchange.com/questions/399163/create-boxplots-from-file
% https://tex.stackexchange.com/questions/117435/read-boxplot-prepared-values-from-a-table/117439#117439
\makeatletter
\pgfplotsset{
    boxplot prepared from table/.code={
        \def\tikz@plot@handler{\pgfplotsplothandlerboxplotprepared}%
        \pgfplotsset{
            /pgfplots/boxplot prepared from table/.cd,
            #1,
        }
    },
    /pgfplots/boxplot prepared from table/.cd,
        table/.code={\pgfplotstablecopy{#1}\to\boxplot@datatable},
        row/.initial=0,
        make style readable from table/.style={
            #1/.code={
                \normalfont
                \pgfplotstablegetelem{\pgfkeysvalueof{/pgfplots/boxplot prepared from table/row}}{##1}\of\boxplot@datatable
                \pgfplotsset{boxplot/#1/.expand once={\pgfplotsretval}}
            }
        },
        make style readable from table=lower whisker,
        make style readable from table=upper whisker,
        make style readable from table=lower quartile,
        make style readable from table=upper quartile,
        make style readable from table=median,
        make style readable from table=lower notch,
        make style readable from table=upper notch
}
\makeatother

\pgfplotstableread[col sep=comma]{Assets/benchs/cvc5time.csv}\cvctable

\pgfplotstablegetrowsof{\cvctable}
\pgfmathtruncatemacro{\NumRows}{\pgfplotsretval} % total number of rows

% Put this in the preamble or before the figure:
\pgfplotscreateplotcyclelist{benchcolors}{%
  {draw=rxpurple, fill=rxpurple!10},
  {draw=rxpink, fill=rxpink!10},
  {draw=darkpurple, fill=darkpurple!10},
  {draw=midpurple,  fill=midpurple!10},
  {draw=purple2,    fill=purple2!10},
  {draw=RoyalBlue,  fill=RoyalBlue!10},
  {draw=black,      fill=black!10},
  {draw=MidnightBlue,  fill=MidnightBlue!10},
}

\begin{figure}[t]
\begin{tikzpicture}
\begin{axis}[
  width=\textwidth,
  height=\textheight,
  boxplot/draw direction=x,
  cycle list name=benchcolors,
  ytick={1,...,\NumRows},
  yticklabels from table={\cvctable}{acronym},
  yticklabel style={font=\ttfamily},
  xmode=log,
  log basis x=10,
  xlabel={Checking time (ms), $\log(1 + t)$ scale},
  xlabel style={ font=\ttfamily },
  ylabel={Benchmarks},
  ylabel style={ font=\ttfamily },
  legend cell align={left},
  legend style={
    font=\ttfamily\scriptsize,
    at={(0.5,-0.05)},
    anchor=north,
  },
  legend columns=3,
]
\pgfmathtruncatemacro\TotalRows{\NumRows-1}
\pgfplotsinvokeforeach{0,...,\TotalRows}
{
  \addplot+[
  boxplot prepared from table={
    table=\cvctable,
    row=#1,
    lower whisker=min,
    lower quartile=q1,
    upper quartile=q3,
    upper whisker=max,
    median=median
  },
  boxplot prepared,
  area legend
  ] coordinates{};

    % --- single point at lt for this sample ---
  \pgfplotstablegetelem{#1}{mean}\of\cvctable
  \pgfmathsetmacro{\meanvalue}{\pgfplotsretval} % x = lt
  \pgfmathtruncatemacro{\cat}{#1+1}           % y = 1,2,3,... (row index)

  \addplot+[
    only marks,
    mark=*,
    mark size=1.2pt,
    forget plot,    % do not create legend entries for every point
  ] coordinates {(\meanvalue,\cat)};
}
\end{axis}
\end{tikzpicture}
\caption{cvc5 times.}
\label{fig:all-carcara-time-boxplot}
\end{figure}


\begin{table}[t]
\centering
{%
\scriptsize
\caption{Time measurements for Carcara elaboration.} 
\label{tab:benchmarks-carcara-time}
\pgfplotstabletypeset[
  font=\ttfamily,
  col sep=comma,
  every even row/.style={
    before row={\rowcolor[gray]{0.9}}},
  every head row/.style={
    before row=\toprule,after row=\midrule},
  every last row/.style={
    after row=\bottomrule},
  columns={acronym, logic,elaboration_count, elaboration_mean,elaboration_min,elaboration_q1,elaboration_median,elaboration_q3,elaboration_max},
  columns/acronym/.style={string type},
  columns/logic/.style={string type},
  columns/name/.style={string type},
  columns/elaboration_count/.style={
    column name={number},
    /pgf/number format/fixed,
    /pgf/number format/precision=0, % No decimal places for integers
  },
  columns/elaboration_mean/.style={column name={mean}},
  columns/elaboration_min/.style={column name={min}},
  columns/elaboration_q1/.style={column name={Q1}},
  columns/elaboration_median/.style={column name={median}},
  columns/elaboration_q3/.style={column name={Q3}},
  columns/elaboration_max/.style={column name={max}},
  /pgf/number format/precision=2,
  /pgf/number format/fixed,
  /pgf/number format/fixed zerofill=true,
]{Assets/benchs/all.csv}%
}
\end{table}

\pgfplotstableread[col sep=comma]{Assets/benchs/carcaratime.csv}\carcaratime

\pgfplotstablegetrowsof{\carcaratime}
\pgfmathtruncatemacro{\NumRows}{\pgfplotsretval} % total number of rows

\begin{figure}[t]
\begin{tikzpicture}
\begin{axis}[
  width=\textwidth,
  height=\textheight,
  boxplot/draw direction=x,
  cycle list name=benchcolors,
  ytick={1,...,\NumRows},
  yticklabels from table={\carcaratime}{acronym},
  yticklabel style={font=\ttfamily},
  xmode=log,
  log basis x=10,
  xlabel={Checking time (ms), $\log(1 + t)$ scale},
  xlabel style={ font=\ttfamily },
  ylabel={Benchmarks},
  ylabel style={ font=\ttfamily },
  legend cell align={left},
  legend style={
    font=\ttfamily\scriptsize,
    at={(0.5,-0.05)},
    anchor=north,
  },
  legend columns=3,
]
\pgfmathtruncatemacro\TotalRows{\NumRows-1}
\pgfplotsinvokeforeach{0,...,\TotalRows}
{
  \addplot+[
  boxplot prepared from table={
    table=\carcaratime,
    row=#1,
    lower whisker=min,
    lower quartile=q1,
    upper quartile=q3,
    upper whisker=max,
    median=median
  },
  boxplot prepared,
  area legend
  ] coordinates{};

    % --- single point at lt for this sample ---
  \pgfplotstablegetelem{#1}{mean}\of\carcaratime
  \pgfmathsetmacro{\meanvalue}{\pgfplotsretval} % x = lt
  \pgfmathtruncatemacro{\cat}{#1+1}           % y = 1,2,3,... (row index)

  \addplot+[
    only marks,
    mark=*,
    mark size=1.2pt,
    forget plot,    % do not create legend entries for every point
  ] coordinates {(\meanvalue,\cat)};
}
\end{axis}
\end{tikzpicture}
\caption{Carcara elaboration times.}
\label{fig:carcara-time-boxplot}
\end{figure}


\begin{table}[t]
\centering
{%
\scriptsize
\caption{Translation results.} 
\label{tab:benchmarks-translate}
\pgfplotstabletypeset[
  font=\ttfamily,
  col sep=comma,
  every even row/.style={
    before row={\rowcolor[gray]{0.9}}},
  every head row/.style={
    before row=\toprule,after row=\midrule},
  every last row/.style={
    after row=\bottomrule},
  columns={name, logic,translate_small_results, translate_large_results},
  columns/name/.style={string type},
  columns/logic/.style={string type},
  columns/translate_small_results/.style={string type, column name={translate}},
  columns/translate_large_results/.style={string type, column name={translate XL}},
]{Assets/benchs/all.csv}%
}
\end{table}


\pgfplotstableread[col sep=comma]{Assets/benchs/lpsmalltime.csv}\lpsmalltime

\pgfplotstablegetrowsof{\lpsmalltime}
\pgfmathtruncatemacro{\NumRows}{\pgfplotsretval} % total number of rows

\begin{figure}[t]
\begin{tikzpicture}
\begin{axis}[
  width=\textwidth,
  height=\textheight,
  boxplot/draw direction=x,
  cycle list name=benchcolors,
  ytick={1,...,\NumRows},
  yticklabels from table={\lpsmalltime}{acronym},
  yticklabel style={font=\ttfamily},
  xmode=log,
  log basis x=10,
  xlabel={Checking time (ms), $\log(1 + t)$ scale},
  xlabel style={ font=\ttfamily },
  ylabel={Benchmarks},
  ylabel style={ font=\ttfamily },
  legend cell align={left},
  legend style={
    font=\ttfamily\scriptsize,
    at={(0.5,-0.10)},
    anchor=north,
  },
  legend columns=3,
  % enlarge x limits=false,       % remove left/right padding
  % enlarge y limits=false,       % remove top/bottom padding
]
\pgfmathtruncatemacro\TotalRows{\NumRows-1}
\pgfplotsinvokeforeach{0,...,\TotalRows}
{
  \addplot+[
  boxplot prepared from table={
    table=\lpsmalltime,
    row=#1,
    lower whisker=min,
    lower quartile=q1,
    upper quartile=q3,
    upper whisker=max,
    median=median
  },
  boxplot prepared,
  area legend
  ] coordinates{};

    % --- single point at lt for this sample ---
  \pgfplotstablegetelem{#1}{mean}\of\lpsmalltime
  \pgfmathsetmacro{\meanvalue}{\pgfplotsretval} % x = lt
  \pgfmathtruncatemacro{\cat}{#1+1}           % y = 1,2,3,... (row index)

  \addplot+[
    only marks,
    mark=*,
    mark size=1.2pt,
    forget plot,    % do not create legend entries for every point
  ] coordinates {(\meanvalue,\cat)};
  % \pgfplotstablegetelem{#1}{name}\of\lpsmalltime
  % \edef\thisname{\pgfplotsretval}
  % \pgfplotstablegetelem{#1}{acronym}\of\lpsmalltime
  % \edef\thisacro{\pgfplotsretval}
  % \addlegendentryexpanded{\thisname\;(\thisacro)}
}
\end{axis}
\end{tikzpicture}
\caption{Lambdapi translation times for small problems.}
\label{fig:lambdapi-translation-small-time}
\end{figure}

\pgfplotstableread[col sep=comma]{Assets/benchs/lplargetime.csv}\lplargetime

\pgfplotstablegetrowsof{\lplargetime}
\pgfmathtruncatemacro{\NumRows}{\pgfplotsretval} % total number of rows

% Put this in the preamble or before the figure:
\pgfplotscreateplotcyclelist{benchcolors}{%
  {draw=rxpurple, fill=rxpurple!10},
  {draw=rxpink, fill=rxpink!10},
  {draw=darkpurple, fill=darkpurple!10},
  {draw=midpurple,  fill=midpurple!10},
  {draw=purple2,    fill=purple2!10},
  {draw=RoyalBlue,  fill=RoyalBlue!10},
  {draw=black,      fill=black!10},
  {draw=MidnightBlue,  fill=MidnightBlue!10},
}

\begin{figure}[t]
\begin{tikzpicture}
\begin{axis}[
  width=0.9\textwidth,
  height=0.8\textheight,
  boxplot/draw direction=x,
  cycle list name=benchcolors,
  ytick={1,...,\NumRows},
  yticklabels from table={\lplargetime}{acronym},
  yticklabel style={font=\ttfamily},
  xmode=log,
  log basis x=10,
  xlabel={Checking time (ms), $\log(1 + t)$ scale},
  xlabel style={ font=\ttfamily },
  ylabel={Benchmarks},
  ylabel style={ font=\ttfamily },
  legend cell align={left},
  legend style={
    font=\ttfamily\scriptsize,
    at={(0.5,-0.10)},
    anchor=north,
  },
  legend columns=3,
  % enlarge x limits=false,       % remove left/right padding
  % enlarge y limits=false,       % remove top/bottom padding
]
\pgfmathtruncatemacro\TotalRows{\NumRows-1}
\pgfplotsinvokeforeach{0,...,\TotalRows}
{
  \addplot+[
  boxplot prepared from table={
    table=\lplargetime,
    row=#1,
    lower whisker=min,
    lower quartile=q1,
    upper quartile=q3,
    upper whisker=max,
    median=median
  },
  boxplot prepared,
  area legend
  ] coordinates{};

    % --- single point at lt for this sample ---
  \pgfplotstablegetelem{#1}{mean}\of\lplargetime
  \pgfmathsetmacro{\meanvalue}{\pgfplotsretval} % x = lt
  \pgfmathtruncatemacro{\cat}{#1+1}           % y = 1,2,3,... (row index)

  \addplot+[
    only marks,
    mark=*,
    mark size=1.2pt,
    forget plot,    % do not create legend entries for every point
  ] coordinates {(\meanvalue,\cat)};
}
\end{axis}
\end{tikzpicture}
\caption{Lambdapi translation times for large proofs.}
\label{fig:lambdapi-translation-large-time}
\end{figure}